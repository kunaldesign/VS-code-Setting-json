/*! For license information please see 605.js.LICENSE.txt */
exports.id=605,exports.ids=[605],exports.modules={3359:(e,t,s)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.DefaultTunnelRelayStreamFactory=void 0;const i=s(8277);t.DefaultTunnelRelayStreamFactory=class{async createRelayStream(e,t,s,n){if((0,i.isNode)())return await i.SshHelpers.openConnection(e,[t],Object.assign({},s&&{Authorization:`tunnel ${s}`}),n);{const n=[t];return s&&n.push(s),await i.SshHelpers.openConnection(e,n)}}}},9605:function(e,t,s){"use strict";var i=this&&this.__createBinding||(Object.create?function(e,t,s,i){void 0===i&&(i=s),Object.defineProperty(e,i,{enumerable:!0,get:function(){return t[s]}})}:function(e,t,s,i){void 0===i&&(i=s),e[i]=t[s]}),n=this&&this.__exportStar||function(e,t){for(var s in e)"default"===s||Object.prototype.hasOwnProperty.call(t,s)||i(t,e,s)};Object.defineProperty(t,"__esModule",{value:!0}),n(s(9246),t),n(s(1625),t),n(s(6698),t),n(s(7820),t),n(s(30),t),n(s(3589),t),n(s(360),t),n(s(8277),t),n(s(9246),t),n(s(9725),t),n(s(1625),t),n(s(5666),t),n(s(7771),t),n(s(3359),t),n(s(9747),t),n(s(5726),t)},6698:(e,t)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.MultiModeTunnelClient=void 0,t.MultiModeTunnelClient=class{constructor(){this.clients=[],this.connectionModes=this.clients?[...new Set(...this.clients.map((e=>e.connectionModes)))]:[]}get acceptLocalConnectionsForForwardedPorts(){return!!this.clients.find((e=>e.acceptLocalConnectionsForForwardedPorts))}set acceptLocalConnectionsForForwardedPorts(e){this.clients.forEach((t=>t.acceptLocalConnectionsForForwardedPorts=e))}connect(e,t){if(!e)throw new Error("Tunnel cannot be null");return new Promise((e=>{}))}connectToForwardedPort(e,t){throw new Error("Method not implemented.")}waitForForwardedPort(e,t){throw new Error("Method not implemented.")}dispose(){this.clients.forEach((e=>{e.dispose()}))}}},7820:(e,t,s)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.MultiModeTunnelHost=void 0;const i=s(1719);class n{constructor(){this.hosts=[]}async start(e){let t=[];this.hosts.forEach((s=>{t.push(s.start(e))})),await Promise.all(t)}async addPort(e){let t=[];return this.hosts.forEach((s=>{t.push(s.addPort(e))})),await Promise.all(t),e}async removePort(e){let t=!0,s=[];return this.hosts.forEach((t=>{s.push(t.removePort(e))})),(await Promise.all(s)).forEach((e=>{t=t&&e})),t}async updatePort(e){let t=[];return this.hosts.forEach((s=>{t.push(s.updatePort(e))})),await Promise.all(t),e}dispose(){this.hosts.forEach((e=>{e.dispose()}))}}t.MultiModeTunnelHost=n,n.hostId=(0,i.v4)()},30:(e,t,s)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.RetryTcpListenerFactory=void 0;const i=s(1808);t.RetryTcpListenerFactory=class{async createTcpListener(e,t,s,n){if(!e)throw new TypeError("Local IP address is required.");let r=i.createServer();for(let s=0;;s++){let n=10===s?0:t+s;try{return await new Promise(((t,s)=>{r.listen({host:e,port:n,ipv6Only:i.isIPv6(e)}),r.on("listening",(()=>{t(r)})),r.on("error",(e=>{s(e)}))}))}catch(e){console.log("Listening on port "+n+" failed: "+e),console.log("Incrementing port and trying again");continue}}}}},3589:(e,t)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.SessionPortKey=void 0,t.SessionPortKey=class{constructor(e,t){this.sessionId=e,this.port=t}equals(e){return this.port===e.port&&this.sessionId===e.sessionId}toString(){return this.port+"_"+this.sessionId.toString("base64")}}},360:(e,t,s)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.SshChannelForwarder=void 0;const i=s(2126),n=s(2045);t.SshChannelForwarder=class{constructor(e,t){this.receiveQueue=new i.Queue,this.receiveSemaphore=new n.Semaphore(0),this.channel=e,this.client=t,this.stream=t.getStream(),this.init()}async init(){await this.forwardFromStreamToChannel(new Buffer(4096)),await this.forwardFromChannelToStream()}onChannelDataReceived(e,t){let s=new Buffer(t.length);t.copy(s),this.receiveQueue.enqueue(s);try{this.receiveSemaphore.acquire()}catch(e){}this.channel.adjustWindow(t.length)}onChannelClosed(e,t){this.channelClosedEvent=t;try{this.receiveSemaphore.acquire()}catch(e){}}async forwardFromChannelToStream(){try{let e;do{e=await this.forwardFromChannelToStreamAsync()}while(e)}catch(e){console.log(`Unexpected error reading channel stream: ${e}`)}}async forwardFromChannelToStreamAsync(){var e,t;try{await this.receiveSemaphore.acquire()}catch(e){return this.closeStream(!0),!1}let s=this.receiveQueue.dequeue();if(!s){if(null!=this.channelClosedEvent){let s=null!==(e=this.channelClosedEvent.errorMessage)&&void 0!==e?e:null===(t=this.channelClosedEvent.error)||void 0===t?void 0:t.message,i=s?`Forwarder channel ${this.channel.channelId} closed with error: ${s}`:`Forwarder channel ${this.channel.channelId} closed.`;console.log(i),this.closeStream(!!s)}return!1}try{return await this.stream.write(s),!0}catch(e){return this.closeStream(!0),!1}}closeStream(e){try{e?this.client.Client.close():this.stream.close()}catch(e){return void console.log(`PortForwardingService unexpected error closing connection: ${e}`)}console.log(`Channel forwarder ${e?"aborted":"closed"} connection.`)}async forwardFromStreamToChannel(e){try{let t;do{t=await this.forwardFromStreamToChannelAsync(e)}while(t)}catch(e){console.log(`Unexpected error reading channel stream: ${e}`)}}async forwardFromStreamToChannelAsync(e){let t,s=null;try{const s=await this.stream.read(e.byteLength);t=null==s?void 0:s.byteLength}catch(e){s=e,t=0}if(t&&t>0)return await this.channel.send(e.slice(0,t)),!0;if(s){const e=`Channel forwarder stream read error: ${s}`;console.log(e),await this.channel.close("SIGABRT",s.toString())}else{const e="Channel forwarder reached end of stream.";console.log(e),await this.channel.send(new Buffer("")),await this.channel.close()}return!1}}},8277:(e,t,s)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.RelayConnectionError=t.RelayErrorType=t.isNode=t.SshHelpers=void 0;const i=s(2126),n=s(454);class r{static getRelayUri(e,t,s){if(!e)throw new Error("Does not have a relay endpoint.");return e.replace("sb:","wss:").replace(".net/",".net:443/$hc/")+`?sb-hc-action=${s}&sb-hc-token=`+encodeURIComponent(t||"")}static openConnection(e,s,i,n){return(0,t.isNode)()?r.nodeSshStreamFactory(e,s,i,n):r.webSshStreamFactory(new WebSocket(e,s))}static createSshClientSession(){return r.createSshSession((e=>new i.SshClientSession(e)))}static createSshServerSession(e){return r.createSshSession((t=>new i.SshServerSession(t,e)))}static createWebSocketStreamAdapter(e){return new i.WebSocketStream(new o(e))}static webSshStreamFactory(e){return e.binaryType="arraybuffer",new Promise(((t,s)=>{e.onopen=()=>{t(new i.WebSocketStream(e))},e.onerror=e=>{s(new Error("Failed to connect to relay url"))}}))}static createSshSession(e){const t=new i.SshSessionConfiguration;t.keyExchangeAlgorithms.splice(0),t.keyExchangeAlgorithms.push(i.SshAlgorithms.keyExchange.ecdhNistp384Sha384),t.keyExchangeAlgorithms.push(i.SshAlgorithms.keyExchange.ecdhNistp256Sha256),t.keyExchangeAlgorithms.push(i.SshAlgorithms.keyExchange.dhGroup14Sha256),t.protocolExtensions.push(i.SshProtocolExtensionNames.sessionReconnect),t.protocolExtensions.push(i.SshProtocolExtensionNames.sessionLatency);const s=t.encryptionAlgorithms.indexOf(i.SshAlgorithms.encryption.aes256Gcm);return-1!==s&&t.encryptionAlgorithms.splice(s,1),e(t)}static nodeSshStreamFactory(e,t,s,r){const h=new n.client(r);return new Promise(((n,r)=>{h.on("connect",(e=>{n(new i.WebSocketStream(new o(e)))})),h.on("connectFailed",(e=>{e.message&&e.message.startsWith("Error: ")&&(e.message=e.message.substr(7));let t=a.ServerError;/status: 401/.test(e.message)?(e.message="error.relayClientUnauthorized",t=a.Unauthorized):/status: 403/.test(e.message)?(e.message="error.relayClientForbidden",t=a.Unauthorized):/status: 404 Endpoint does not exist/.test(e.message)?(e.message="error.relayEndpointNotFound",t=a.EndpointNotFound):/status: 404 There are no listeners connected/.test(e.message)?(e.message="error.relayListenerOffline",t=a.ListenerOffline):/status: 500/.test(e.message)?(e.message="error.relayServerError",t=a.ServerError):e.message="error.relayConnectionError "+e.message,r(new c(e.message,{errorType:t}))})),h.connect(e,t,void 0,s)}))}}t.SshHelpers=r;class o{constructor(e){this.connection=e}set onmessage(e){e&&this.connection.on("message",(t=>{e({data:t.binaryData})}))}set onclose(e){e&&this.connection.on("close",((t,s)=>{e({code:t,reason:s,wasClean:!(t||s)})}))}send(e){Buffer.isBuffer(e)?this.connection.sendBytes(e):this.connection.sendBytes(Buffer.from(e))}close(e,t){e||t?this.connection.drop(e,t):this.connection.close()}}var a;t.isNode=()=>"undefined"!=typeof process&&void 0!==process.release&&"node"===process.release.name,function(e){e[e.ConnectionError=1]="ConnectionError",e[e.Unauthorized=2]="Unauthorized",e[e.EndpointNotFound=3]="EndpointNotFound",e[e.ListenerOffline=4]="ListenerOffline",e[e.ServerError=5]="ServerError"}(a=t.RelayErrorType||(t.RelayErrorType={}));class c extends Error{constructor(e,t){super(e),this.errorContext=t}}t.RelayConnectionError=c},9246:(e,t)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0})},9725:(e,t,s)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.TunnelClientBase=void 0;const i=s(2126),n=s(1607),r=s(30),o=s(8277),a=s(3862),c=s(3730);t.TunnelClientBase=class{constructor(){this.sshSessionClosedEmitter=new c.Emitter,this.acceptLocalConnectionsForForwardedPortsValue=(0,o.isNode)(),this.connectionModes=[],this.sshSessionClosed=this.sshSessionClosedEmitter.event,this.trace=(e,t,s,i)=>{}}get isSshSessionActive(){var e;return!!(null===(e=this.sshSession)||void 0===e?void 0:e.isConnected)}hasForwardedChannels(e){var t;if(!this.isSshSessionActive)return!1;const s=null===(t=this.sshSession)||void 0===t?void 0:t.activateService(n.PortForwardingService),i=null==s?void 0:s.remoteForwardedPorts,r=null==i?void 0:i.find((t=>t.remotePort===e));return!!r&&i.getChannels(r).length>0}get acceptLocalConnectionsForForwardedPorts(){return this.acceptLocalConnectionsForForwardedPortsValue}set acceptLocalConnectionsForForwardedPorts(e){if(e!==this.acceptLocalConnectionsForForwardedPortsValue){if(e&&!(0,o.isNode)())throw new Error("Cannot accept local connections for forwarded ports on this platform.");this.acceptLocalConnectionsForForwardedPortsValue=e,this.activatePfsIfNeeded()}}get forwardedPorts(){var e;let t=null===(e=this.sshSession)||void 0===e?void 0:e.activateService(n.PortForwardingService);return null==t?void 0:t.remoteForwardedPorts}async connect(e,t){if(!e)throw new Error("Tunnel cannot be null");if(!e.endpoints)throw new Error("Tunnel endpoints cannot be null");if(this.sshSession)throw new Error("Already connected. Use separate instances to connect to multiple tunnels.");if(0===e.endpoints.length)throw new Error("No hosts are currently accepting connections for the tunnel.");let s,i=a.List.groupBy(e.endpoints,(e=>e.hostId));if(t){if(s=i.get(t),!s)throw new Error("The specified host is not currently accepting connections to the tunnel.")}else{if(i.size>1)throw new Error("There are multiple hosts for the tunnel. Specify a host ID to connect to.");s=i.entries().next().value[1]}await this.connectClient(e,s)}onRequest(e){e.request.requestType!==n.PortForwardingService.portForwardRequestType&&e.request.requestType!==n.PortForwardingService.cancelPortForwardRequestType||(e.isAuthorized=!0)}async startSshSession(e){let t=new i.SshSessionConfiguration;t.addService(n.PortForwardingService),this.sshSession=new i.SshClientSession(t),this.sshSession.trace=this.trace,this.sshSession.onClosed((e=>this.onSshSessionClosed(e))),this.sshSession.onAuthenticating((e=>this.onSshServerAuthenticating(e))),this.activatePfsIfNeeded(),this.sshSession.onRequest((e=>this.onRequest(e))),await this.sshSession.connect(e);await this.sshSession.authenticate({username:"tunnel",password:void 0})}activatePfsIfNeeded(){if(!this.sshSession)return;const e=this.sshSession.activateService(n.PortForwardingService);this.acceptLocalConnectionsForForwardedPortsValue&&(0,o.isNode)()?e.tcpListenerFactory=new r.RetryTcpListenerFactory:e.acceptLocalConnectionsForForwardedPorts=!1}async connectToForwardedPort(e,t){const s=this.getSshSessionPfs();if(!s)throw new Error("Failed to connect to remote port. Ensure that the client has connected by calling connectClient.");return s.connectToForwardedPort(e,t)}async waitForForwardedPort(e,t){const s=this.getSshSessionPfs();if(!s)throw new Error("Port forwarding has not been started. Ensure that the client has connected by calling connectClient.");return s.waitForForwardedPort(e,t)}getSshSessionPfs(){var e,t;return null!==(t=null===(e=this.sshSession)||void 0===e?void 0:e.getService(n.PortForwardingService))&&void 0!==t?t:void 0}onSshServerAuthenticating(e){e.authenticationPromise=Promise.resolve({})}onSshSessionClosed(e){this.sshSessionClosedEmitter.fire(this)}async dispose(){this.sshSession&&await this.sshSession.close(i.SshDisconnectReason.byApplication)}}},1625:(e,t)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0})},5666:(e,t,s)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.TunnelHostBase=void 0;const i=s(2126),n=s(1607),r=s(3589);t.TunnelHostBase=class{constructor(e){this.sshSessions=[],this.remoteForwarders={},this.trace=(e,t,s,i)=>{},this.loopbackIp="127.0.0.1",this.managementClient=e;const t=i.SshAlgorithms.publicKey.ecdsaSha2Nistp384;t&&(this.hostPrivateKeyPromise=t.generateKeyPair())}async start(e){if(this.tunnel)throw new Error("Already hosting a tunnel. Use separate instances to host multiple tunnels.");if(this.hostPrivateKeyPromise){const t=await this.hostPrivateKeyPromise;this.hostPrivateKey=t;const s=await t.getPublicKeyBytes(t.keyAlgorithmName);if(!s)throw new Error("Host private key public key bytes is not initialized");{let t=[s.toString("base64")];await this.startServer(e,t)}}}async addPort(e){if(!this.tunnel)throw new Error("Tunnel must be running");let t=await this.managementClient.createTunnelPort(this.tunnel,e,void 0);const s=this.sshSessions.map((async e=>{if(!e.principal)return;let s=e.getService(n.PortForwardingService);if(!s)throw new Error("PFS must be active to add ports");await this.forwardPort(s,t)}));return await Promise.all(s),t}async removePort(e){if(!this.tunnel||!this.tunnel.ports)throw new Error("Tunnel must be running and have ports to delete");let t=await this.managementClient.deleteTunnelPort(this.tunnel,e,void 0);return this.sshSessions.forEach((t=>{t.sessionId&&Object.keys(this.remoteForwarders).forEach((t=>{if(this.remoteForwarders[t].localPort===e){let e=this.remoteForwarders[t];delete this.remoteForwarders[t],e&&e.dispose()}}))})),t}async updatePort(e){if(!this.tunnel||!this.tunnel.ports)throw new Error("Tunnel must be running and have ports to update");return await this.managementClient.updateTunnelPort(this.tunnel,e,void 0)}async forwardPort(e,t){let s=e.session.sessionId;if(!s)throw new Error("No session id");let i=await e.forwardFromRemotePort(this.loopbackIp,Number(t.portNumber),this.loopbackIp,Number(t.portNumber));if(!i)return!1;const n=new r.SessionPortKey(s,Number(i.remotePort));return this.remoteForwarders[n.toString()]=i,!0}}},7771:(e,t)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0})},9747:(e,t,s)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.TunnelRelayTunnelClient=void 0;const i=s(7775),n=s(1928),r=s(2126),o=s(9605),a=s(9725);class c extends a.TunnelClientBase{constructor(){super(),this.connectionModes=[],this.streamFactory=new o.DefaultTunnelRelayStreamFactory}async connectClient(e,t){let s,n=t.map((e=>e));if(!n||1!==n.length)throw new Error("The host is not currently accepting Tunnel relay connections.");s=n[0];let r=s.clientRelayUri;if(!r)throw new Error("The tunnel client relay endpoint URI is missing.");let o=e.accessTokens?e.accessTokens[i.TunnelAccessScopes.Connect]:void 0;await this.connectClientToRelayServer(r,o)}async connectClientToRelayServer(e,t){var s,i;if(this.trace(r.TraceLevel.Info,0,`Connecting to client tunnel relay ${e}`),this.trace(r.TraceLevel.Verbose,0,`Sec-WebSocket-Protocol: ${c.webSocketSubProtocol}`),t){const e=null!==(i=null===(s=n.TunnelAccessTokenProperties.tryParse(t))||void 0===s?void 0:s.toString())&&void 0!==i?i:"token";this.trace(r.TraceLevel.Verbose,0,`Authorization: tunnel <${e}>`)}try{let s=await this.streamFactory.createRelayStream(e,c.webSocketSubProtocol,t);try{await this.startSshSession(s)}catch(e){throw s.dispose(),new Error}}catch(e){throw new Error("Failed to connect to tunnel relay. "+e)}}}t.TunnelRelayTunnelClient=c,c.webSocketSubProtocol="tunnel-relay-client"},5726:(e,t,s)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.TunnelRelayTunnelHost=void 0;const i=s(7775),n=s(1928),r=s(2126),o=s(1607),a=s(3730),c=s(9605),h=s(7820),l=s(5666);class u extends l.TunnelHostBase{constructor(e){super(e),this.streamFactory=new c.DefaultTunnelRelayStreamFactory,this.clientSessionPromises=[],this.disposeCts=new a.CancellationTokenSource,this.hostId=h.MultiModeTunnelHost.hostId}async startServer(e,t){var s,o;let a=e.accessTokens?e.accessTokens[i.TunnelAccessScopes.Host]:void 0;a||this.trace(r.TraceLevel.Info,0,`There is no access token for ${i.TunnelAccessScopes.Host} scope on the tunnel.`);let c={hostId:this.hostId,hostPublicKeys:t,connectionMode:i.TunnelConnectionMode.TunnelRelay};c=await this.managementClient.updateTunnelEndpoint(e,c,void 0),this.tunnel=e;let h=c.hostRelayUri;if(!h)throw new Error("The tunnel host relay endpoint URI is missing.");if(this.trace(r.TraceLevel.Info,0,`Connecting to host tunnel relay ${h}`),this.trace(r.TraceLevel.Verbose,0,`Sec-WebSocket-Protocol: ${u.webSocketSubProtocol}`),a){const e=null!==(o=null===(s=n.TunnelAccessTokenProperties.tryParse(a))||void 0===s?void 0:s.toString())&&void 0!==o?o:"token";this.trace(r.TraceLevel.Verbose,0,`Authorization: tunnel ${e}`)}try{let e=await this.streamFactory.createRelayStream(h,u.webSocketSubProtocol,a,this.managementClient.httpsAgent?{tlsOptions:this.managementClient.httpsAgent.options}:void 0);this.hostSession=new r.MultiChannelStream(e);const t=this.hostSession.onChannelOpening((e=>{this.hostSession_ChannelOpening(this.hostSession,e)})),s=this.hostSession.onClosed((e=>{this.hostSession_Closed(t,s)}));try{await this.hostSession.connect()}catch(e){throw await this.hostSession.close(),new Error}}catch(e){throw new Error("Failed to connect to tunnel relay. "+e)}}hostSession_ChannelOpening(e,t){if(!t.isRemoteRequest)return;if(t.channel.channelType!==u.clientStreamChannelType)return t.failureDescription=`Unexpected channel type. Only ${u.clientStreamChannelType} is supported.`,void(t.failureReason=r.SshChannelOpenFailureReason.unknownChannelType);const s=this.acceptClientSession(e,this.disposeCts.token);this.clientSessionPromises.push(s),s.then((()=>{const e=this.clientSessionPromises.indexOf(s);this.clientSessionPromises.splice(e,1)}))}async acceptClientSession(e,t){try{let s=await e.acceptStream(u.clientStreamChannelType,t);await this.connectAndRunClientSession(s,t)}catch(e){this.trace(r.TraceLevel.Error,0,`Error running client SSH session: ${e}`)}}async connectAndRunClientSession(e,t){let s=new r.SshSessionConfiguration;s.addService(o.PortForwardingService);let i=new r.SshServerSession(s);i.trace=this.trace,i.credentials={publicKeys:[this.hostPrivateKey]};let n=new r.PromiseCompletionSource;t.onCancellationRequested((e=>{n.reject(new r.CancellationError)}));const a=i.onAuthenticating((e=>{this.onSshClientAuthenticating(e)}));i.onClientAuthenticated((()=>{this.onSshClientAuthenticated(i)}));const c=i.onChannelOpening((e=>{this.onSshChannelOpening(e,i)})),h=i.onClosed((e=>{this.session_Closed(e,t)}));try{const t=new r.NodeStream(e);await i.connect(t),this.sshSessions.push(i),await n.promise}finally{a.dispose(),c.dispose(),h.dispose()}}onSshClientAuthenticating(e){e.authenticationType===r.SshAuthenticationType.clientNone&&(e.authenticationPromise=Promise.resolve({}))}onSshClientAuthenticated(e){let t=e.activateService(o.PortForwardingService);this.tunnel&&this.tunnel.ports&&this.tunnel.ports.forEach((async e=>{try{await this.forwardPort(t,e)}catch(t){this.trace(r.TraceLevel.Error,0,`Error forwarding port ${e.portNumber}: ${t}`)}}))}onSshChannelOpening(e,t){if(!(e.request instanceof o.PortForwardChannelOpenMessage)){if("session"===e.request.channelType)return;return this.trace(r.TraceLevel.Warning,0,"Rejecting request to open non-portforwarding channel."),void(e.failureReason=r.SshChannelOpenFailureReason.administrativelyProhibited)}let s=e.request;if("direct-tcpip"===s.channelType)this.tunnel.ports.some((e=>e.portNumber===s.port))||(this.trace(r.TraceLevel.Warning,0,"Rejecting request to connect to non-forwarded port:"+s.port),e.failureReason=r.SshChannelOpenFailureReason.administrativelyProhibited);else if("forwarded-tcpip"===s.channelType)if(t instanceof r.SshServerSession){let i=t.sessionId;if(!i)return this.trace(r.TraceLevel.Warning,0,"Rejecting request as session has no Id"),void(e.failureReason=r.SshChannelOpenFailureReason.administrativelyProhibited);this.remoteForwarders[new c.SessionPortKey(i,s.port).toString()]||(this.trace(r.TraceLevel.Warning,0,"Rejecting request to connect to non-forwarded port:"+s.port),e.failureReason=r.SshChannelOpenFailureReason.administrativelyProhibited)}else this.trace(r.TraceLevel.Warning,0,"Rejecting request due to invalid sender"),e.failureReason=r.SshChannelOpenFailureReason.connectFailed;else this.trace(r.TraceLevel.Warning,0,"Nonrecognized channel type "+s.channelType),e.failureReason=r.SshChannelOpenFailureReason.unknownChannelType}session_Closed(e,t){e.reason===r.SshDisconnectReason.byApplication?this.trace(r.TraceLevel.Info,0,"Client ssh session closed."):t.isCancellationRequested?this.trace(r.TraceLevel.Info,0,"Client ssh session cancelled."):this.trace(r.TraceLevel.Error,0,`Client ssh session closed unexpectely due to ${e.reason}, "${e.message}"\n${e.error}`)}hostSession_Closed(e,t){t.dispose(),e.dispose(),this.hostSession=void 0,this.trace(r.TraceLevel.Info,0,"Connection to host tunnel relay closed.")}async dispose(){this.disposeCts.cancel();let e=this.hostSession;if(e){this.hostSession=void 0;try{await e.close()}catch(e){if(!(e instanceof r.ObjectDisposedError))throw e}}let t=Object.assign([],this.clientSessionPromises);if(this.clientSessionPromises.length=0,this.tunnel){const e=this.managementClient.deleteTunnelEndpoints(this.tunnel,this.hostId,i.TunnelConnectionMode.TunnelRelay);t.push(e)}for(const e of Object.keys(this.remoteForwarders))this.remoteForwarders[e].dispose();this.sshSessions.forEach((e=>{t.push(e.close(r.SshDisconnectReason.byApplication))})),await Promise.all(t),this.clientSessionPromises.length=0}}t.TunnelRelayTunnelHost=u,u.webSocketSubProtocol="tunnel-relay-host",u.clientStreamChannelType="client-ssh-session-stream"},3862:(e,t)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.List=void 0,t.List=class{static groupBy(e,t){const s=new Map;return e.forEach((e=>{const i=t(e),n=s.get(i);n?n.push(e):s.set(i,[e])})),s}}},9323:(e,t)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.ForwardedPort=void 0,t.ForwardedPort=class{constructor(e,t,s){if(null===e&&null===t)throw new TypeError("Local and remote ports cannot both be null.");if(!s&&null===t)throw new TypeError("The report port number must not be null for locally forwarded ports.");if(null!==e&&("number"!=typeof e||e<=0))throw new TypeError("Local port must be a positive integer.");if(null!==t&&("number"!=typeof t||t<=0))throw new TypeError("Remote port must be a positive integer.");this.localPort=e,this.remotePort=t;const i=s?"->":"<-";null===this.localPort?this.str=`${i}${this.remotePort}`:null==this.remotePort?this.str=`${this.localPort}${i}`:this.str=`${this.localPort}${i}${this.remotePort}`}toString(){return this.str}}},9291:(e,t)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.ForwardedPortChannelEventArgs=t.ForwardedPortEventArgs=void 0;class s{constructor(e){this.port=e}toString(){return this.port.toString()}}t.ForwardedPortEventArgs=s,t.ForwardedPortChannelEventArgs=class extends s{constructor(e,t){super(e),this.port=e,this.channel=t}toString(){return`${this.port} ${this.channel}`}}},2675:(e,t,s)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.ForwardedPortsCollection=void 0;const i=s(3730),n=s(9291);class r{constructor(){this.portChannelMap=new Map,this.portAddedEmitter=new i.Emitter,this.onPortAdded=this.portAddedEmitter.event,this.portRemovedEmitter=new i.Emitter,this.onPortRemoved=this.portRemovedEmitter.event,this.portChannelAddedEmitter=new i.Emitter,this.onPortChannelAdded=this.portChannelAddedEmitter.event,this.portChannelRemovedEmitter=new i.Emitter,this.onPortChannelRemoved=this.portChannelRemovedEmitter.event}get size(){return this.portChannelMap.size}has(e){return this.portChannelMap.has(e.toString())}*values(){for(let[e,t]of this.portChannelMap.values())yield e}[Symbol.iterator](){return this.values()}*entries(){for(let[e,t]of this.portChannelMap.values())yield[e,e]}keys(){return this.values()}forEach(e,t){for(let[s,i]of this.portChannelMap.values())e.apply(t,[s,s,this])}getChannels(e){const t=this.portChannelMap.get(e.toString());if(!t)throw new Error(`Port ${e} is not in the collection.`);return t[1]}find(e){for(let t of this.values())if(e(t))return t}addPort(e){if(this.has(e))throw new Error(`Port ${e} is already in the collection.`);this.portChannelMap.set(e.toString(),[e,[]]),this.portAddedEmitter.fire(new n.ForwardedPortEventArgs(e))}removePort(e){if(!this.has(e))throw new Error(`Port ${e} is not in the collection.`);this.portChannelMap.delete(e.toString()),this.portRemovedEmitter.fire(new n.ForwardedPortEventArgs(e))}addChannel(e,t){const s=this.portChannelMap.get(e.toString());if(!s)throw new Error(`Port ${e} is not in the collection.`);const i=s[1];if(i.find((e=>e.channelId===t.channelId)))throw new Error(`Channel ${t.channelId} is already in the collection for port ${e}`);i.push(t),t.onClosed((()=>this.tryRemoveChannel(e,t))),this.portChannelAddedEmitter.fire(new n.ForwardedPortChannelEventArgs(e,t))}tryRemoveChannel(e,t){const s=this.portChannelMap.get(e.toString());if(s){const i=s[1],r=i.findIndex((e=>e.channelId===t.channelId));r>=0&&(i.splice(r,1),this.portChannelRemovedEmitter.fire(new n.ForwardedPortChannelEventArgs(e,t)))}}toString(){return[...this].join(", ")}}t.ForwardedPortsCollection=r},1607:(e,t,s)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.ForwardedPortChannelEventArgs=t.ForwardedPortEventArgs=t.ForwardedPortsCollection=t.ForwardedPort=t.PortForwardChannelOpenMessage=t.PortForwardSuccessMessage=t.PortForwardRequestMessage=t.RemotePortStreamer=t.RemotePortForwarder=t.LocalPortForwarder=t.PortForwardingService=t.SshServer=t.SshClient=void 0;var i=s(6376);Object.defineProperty(t,"SshClient",{enumerable:!0,get:function(){return i.SshClient}});var n=s(58);Object.defineProperty(t,"SshServer",{enumerable:!0,get:function(){return n.SshServer}});var r=s(5777);Object.defineProperty(t,"PortForwardingService",{enumerable:!0,get:function(){return r.PortForwardingService}});var o=s(2545);Object.defineProperty(t,"LocalPortForwarder",{enumerable:!0,get:function(){return o.LocalPortForwarder}});var a=s(5346);Object.defineProperty(t,"RemotePortForwarder",{enumerable:!0,get:function(){return a.RemotePortForwarder}});var c=s(2022);Object.defineProperty(t,"RemotePortStreamer",{enumerable:!0,get:function(){return c.RemotePortStreamer}});var h=s(5788);Object.defineProperty(t,"PortForwardRequestMessage",{enumerable:!0,get:function(){return h.PortForwardRequestMessage}});var l=s(2168);Object.defineProperty(t,"PortForwardSuccessMessage",{enumerable:!0,get:function(){return l.PortForwardSuccessMessage}});var u=s(2737);Object.defineProperty(t,"PortForwardChannelOpenMessage",{enumerable:!0,get:function(){return u.PortForwardChannelOpenMessage}});var d=s(9323);Object.defineProperty(t,"ForwardedPort",{enumerable:!0,get:function(){return d.ForwardedPort}});var p=s(2675);Object.defineProperty(t,"ForwardedPortsCollection",{enumerable:!0,get:function(){return p.ForwardedPortsCollection}});var f=s(9291);Object.defineProperty(t,"ForwardedPortEventArgs",{enumerable:!0,get:function(){return f.ForwardedPortEventArgs}}),Object.defineProperty(t,"ForwardedPortChannelEventArgs",{enumerable:!0,get:function(){return f.ForwardedPortChannelEventArgs}})},556:(e,t)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.IPAddressConversions=void 0,t.IPAddressConversions=class{static fromSshAddress(e){return e?"localhost"===e?"127.0.0.1":e:"0.0.0.0"}static toSshAddress(e){return e?"0.0.0.0"===e?"":"127.0.0.1"===e?"localhost":e:null}}},2737:(e,t,s)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.PortForwardChannelOpenMessage=void 0;const i=s(2126);class n extends i.ChannelOpenMessage{constructor(){super(...arguments),this.host="",this.port=0,this.originatorIPAddress="",this.originatorPort=0}onRead(e){super.onRead(e),this.host=e.readString("ascii"),this.port=e.readUInt32(),this.originatorIPAddress=e.readString("ascii"),this.originatorPort=e.readUInt32()}onWrite(e){super.onWrite(e),e.writeString(this.validateField(this.host,"host"),"ascii"),e.writeUInt32(this.validateField(this.port,"port")),e.writeString(this.originatorIPAddress||"","ascii"),e.writeUInt32(this.originatorPort||0)}toString(){return`${super.toString()} (host=${this.host} port=${this.port})`}}t.PortForwardChannelOpenMessage=n},5788:(e,t,s)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.PortForwardRequestMessage=void 0;const i=s(2126),n=s(5777);class r extends i.SessionRequestMessage{constructor(){super(),this.addressToBind="",this.port=0,this.requestType=n.PortForwardingService.portForwardRequestType,this.wantReply=!0}onRead(e){super.onRead(e),this.addressToBind=e.readString("ascii"),this.port=e.readUInt32()}onWrite(e){super.onWrite(e),e.writeString(this.validateField(this.addressToBind,"address"),"ascii"),e.writeUInt32(this.validateField(this.port,"port"))}toString(){return`${super.toString()} (addressToBind=${this.addressToBind} port=${this.port})`}}t.PortForwardRequestMessage=r},2168:(e,t,s)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.PortForwardSuccessMessage=void 0;const i=s(2126);class n extends i.SessionRequestSuccessMessage{constructor(){super(...arguments),this.port=0}onRead(e){super.onRead(e),e.available>=4&&(this.port=e.readUInt32())}onWrite(e){super.onWrite(e),e.writeUInt32(this.validateField(this.port,"port"))}toString(){return`${super.toString()} (port=${this.port})`}}t.PortForwardSuccessMessage=n},1317:(e,t,s)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.ChannelForwarder=void 0;const i=s(2126),n=s(3730);t.ChannelForwarder=class{constructor(e,t,s){this.pfs=e,this.channel=t,this.socket=s,this.disposeCancellationSource=new n.CancellationTokenSource,s.on("data",this.onSocketDataReceived.bind(this)),s.on("error",this.onSocketError.bind(this)),s.on("close",this.onSocketClosed.bind(this)),t.onDataReceived(this.onChannelDataReceived.bind(this)),t.onClosed(this.onChannelClosed.bind(this))}get trace(){return this.channel.session.trace}onSocketDataReceived(e){this.socket.pause(),this.channel.send(e,this.disposeCancellationSource.token).then(this.socket.resume.bind(this.socket),(e=>{this.trace(i.TraceLevel.Warning,i.SshTraceEventIds.portForwardConnectionFailed,`Forwarder error sending channel data: ${e.message}`,e)}))}onSocketClosed(e){(e?this.channel.close("SIGABRT","Socket closed with error."):this.channel.close()).catch((e=>{this.trace(i.TraceLevel.Error,i.SshTraceEventIds.portForwardConnectionFailed,`Forwarder channel close failed with error: ${e.message}`,e)}))}onSocketError(e){this.trace(i.TraceLevel.Info,i.SshTraceEventIds.portForwardChannelClosed,`Forwarder socket closed with error: ${e.message}`),this.channel.close("SIGABRT",e.message).catch((e=>{this.trace(i.TraceLevel.Error,i.SshTraceEventIds.portForwardConnectionFailed,`Forwarder channel close failed with error: ${e.message}`,e)}))}onChannelDataReceived(e){this.socket.write(e,(t=>{t?this.trace(i.TraceLevel.Error,i.SshTraceEventIds.portForwardConnectionFailed,`Forwarder failed to write to socket: ${t.message}`,t):this.channel.adjustWindow(e.length)}))}onChannelClosed(e){e.errorMessage?(this.trace(i.TraceLevel.Info,i.SshTraceEventIds.portForwardConnectionClosed,`Forwarder channel ${this.channel.channelId} closed with error: ${e.errorMessage}`),this.socket.destroy()):(this.trace(i.TraceLevel.Info,i.SshTraceEventIds.portForwardConnectionClosed,`Forwarder channel ${this.channel.channelId} closed.`),this.socket.end());const t=this.pfs.channelForwarders.indexOf(this);t>=0&&this.pfs.channelForwarders.splice(t,1),this.dispose()}dispose(){this.disposeCancellationSource.dispose(),this.socket.destroy()}}},2545:(e,t,s)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.LocalPortForwarder=void 0;const i=s(2126),n=s(1317);class r extends i.SshService{constructor(e,t,s,i,n,r,o){super(t),this.pfs=e,this.channelType=s,this.localIPAddress=i,this.port=n,this.remoteHost=r,this.remotePort=null!=o?o:0!==n?n:void 0}get localPort(){return this.port}async startForwarding(e){var t,s;let n=this.localIPAddress;try{const e=0===this.port||!0===(null===(t=this.pfs.session.remoteVersion)||void 0===t?void 0:t.isVsSsh);this.tcpListener=await this.pfs.tcpListenerFactory.createTcpListener(n,this.port,e);const s=this.tcpListener.address();if(!(s.port>0))throw this.tcpListener.close(),new Error("Could not get server port.");if(this.port=s.port,"127.0.0.1"===this.localIPAddress||"0.0.0.0"===this.localIPAddress){n="::";try{this.tcpListener2=await this.pfs.tcpListenerFactory.createTcpListener(n,this.port,!1)}catch(e){if(!(e instanceof Error)||"EADDRNOTAVAIL"!==e.code)throw e;this.trace(i.TraceLevel.Warning,i.SshTraceEventIds.portForwardServerListenFailed,"PortForwardingService failed to listen on {listenAddress}:{LocalPort}: {e.message}",e)}}}catch(e){if(!(e instanceof Error))throw e;throw this.trace(i.TraceLevel.Error,i.SshTraceEventIds.portForwardServerListenFailed,`PortForwardingService failed to listen on ${n}:${this.port}: ${e.message}`,e),e}this.tcpListener.on("connection",this.acceptConnection.bind(this)),null===(s=this.tcpListener2)||void 0===s||s.on("connection",this.acceptConnection.bind(this)),this.trace(i.TraceLevel.Info,i.SshTraceEventIds.portForwardServerListening,`PortForwardingService listening on ${this.localIPAddress}:${this.port}.`),this.tcpListener2&&this.trace(i.TraceLevel.Info,i.SshTraceEventIds.portForwardServerListening,`PortForwardingService also listening on ${n}:${this.port}.`)}async acceptConnection(e){var t,s,r,o;let a;this.trace(i.TraceLevel.Info,i.SshTraceEventIds.portForwardConnectionAccepted,`PortForwardingService accepted connection from: ${e.remoteAddress} on port ${this.port}`);try{a=await this.pfs.openChannel(this.session,this.channelType,null!==(t=e.remoteAddress)&&void 0!==t?t:null,null!==(s=e.remotePort)&&void 0!==s?s:null,null!==(r=this.remoteHost)&&void 0!==r?r:this.localIPAddress,null!==(o=this.remotePort)&&void 0!==o?o:this.localPort)}catch(t){if(!(t instanceof Error))throw t;return void e.destroy()}const c=new n.ChannelForwarder(this.pfs,a,e);this.pfs.channelForwarders.push(c)}dispose(){var e,t;null===(e=this.tcpListener)||void 0===e||e.close(),null===(t=this.tcpListener2)||void 0===t||t.close(),this.trace(i.TraceLevel.Info,i.SshTraceEventIds.portForwardServerListening,`PortForwardingService stopped listening on ${this.localIPAddress}:${this.port}.`),super.dispose()}}t.LocalPortForwarder=r},5777:function(e,t,s){"use strict";var i,n=this&&this.__decorate||function(e,t,s,i){var n,r=arguments.length,o=r<3?t:null===i?i=Object.getOwnPropertyDescriptor(t,s):i;if("object"==typeof Reflect&&"function"==typeof Reflect.decorate)o=Reflect.decorate(e,t,s,i);else for(var a=e.length-1;a>=0;a--)(n=e[a])&&(o=(r<3?n(o):r>3?n(t,s,o):n(t,s))||o);return r>3&&o&&Object.defineProperty(t,s,o),o};Object.defineProperty(t,"__esModule",{value:!0}),t.PortForwardingService=void 0;const r=s(2126),o=s(9323),a=s(2675),c=s(556),h=s(2737),l=s(5788),u=s(2168),d=s(9572),p=s(2545),f=s(5346),g=s(2022);let m=i=class extends r.SshService{constructor(e){super(e),this.localForwarders=new Map,this.remoteConnectors=new Map,this.channelForwarders=[],this.acceptLocalConnectionsForForwardedPorts=!0,this.acceptRemoteConnectionsForNonForwardedPorts=!0,this.localForwardedPorts=new a.ForwardedPortsCollection,this.remoteForwardedPorts=new a.ForwardedPortsCollection,this.tcpListenerFactory=new d.DefaultTcpListenerFactory}async forwardFromRemotePort(e,t,s,i,n){let r="string"==typeof s?s:"127.0.0.1";if(void 0===i&&(i=t),!e)throw new TypeError("Remote IP address is required.");if(!Number.isInteger(t)||t<0)throw new TypeError("Remote port must be a non-negative integer.");if(!r)throw new TypeError("Local host is required.");if(!Number.isInteger(i)||i<=0)throw new TypeError("Local port must be a positive integer.");if(this.localForwardedPorts.find((e=>i==i)))throw new Error(`Local port ${i} is already forwarded.`);if(t>0&&this.localForwardedPorts.find((e=>e.remotePort===t)))throw new Error(`Remote port ${t} is already forwarded.`);const a=new f.RemotePortForwarder(this,this.session,e,t,r,i);if(!await a.request(n))return a.dispose(),null;const c=`${e}:${t=a.remotePort}`;this.remoteConnectors.set(c,a);const h=new o.ForwardedPort(i,t,!1);return this.localForwardedPorts.addPort(h),a.onDisposed((()=>{this.localForwardedPorts.removePort(h),this.remoteConnectors.delete(c)})),a}async forwardToRemotePort(e,t,s,n,r){let o="string"==typeof s?s:"127.0.0.1";if(void 0===n&&(n=t),!e)throw new TypeError("Local IP address is required.");if(!Number.isInteger(t)||t<0)throw new TypeError("Local port must be a non-negative integer.");if(!o)throw new TypeError("Remote host is required.");if(!Number.isInteger(n)||n<=0)throw new TypeError("Remote port must be a positive integer.");const a=new p.LocalPortForwarder(this,this.session,i.reversePortForwardChannelType,e,t,o,n);await a.startForwarding(r);const c=`${e}:${t}`;return this.localForwarders.set(c,a),a.onDisposed((()=>{this.localForwarders.delete(c)})),a}async streamFromRemotePort(e,t,s){if(!e)throw new TypeError("Remote IP address is required.");if(!Number.isInteger(t)||t<0)throw new TypeError("Remote port must be a non-negative integer.");const i=new g.RemotePortStreamer(this.session,e,t);if(!await i.request(s))return i.dispose(),null;const n=`${e}:${t=i.remotePort}`;this.remoteConnectors.set(n,i);const r=new o.ForwardedPort(null,t,!1);return this.localForwardedPorts.addPort(r),i.onDisposed((()=>{this.localForwardedPorts.removePort(r),this.remoteConnectors.delete(n)})),i}async streamToRemotePort(e,t,s){if(!e)throw new TypeError("Remote host is required.");if(!Number.isInteger(t)||t<=0)throw new TypeError("Remote port must be a positive integer.");const n=await this.openChannel(this.session,i.reversePortForwardChannelType,null,null,e,t,s);return new r.SshStream(n)}async connectToForwardedPort(e,t){if(!Number.isInteger(e)||e<=0)throw new TypeError("Forwarded port must be a positive integer.");const s=await this.openChannel(this.session,i.portForwardChannelType,null,null,"127.0.0.1",e,t);return new r.SshStream(s)}async waitForForwardedPort(e,t){if(this.remoteForwardedPorts.find((t=>t.remotePort===e)))return;const s=new r.PromiseCompletionSource;let i,n,o;t&&(i=t.onCancellationRequested((()=>s.reject(new r.CancellationError))));try{n=this.remoteForwardedPorts.onPortAdded((t=>{t.port.remotePort===e&&s.resolve()})),o=this.session.onClosed((()=>{s.reject(new r.ObjectDisposedError("The session was closed."))})),await s.promise}finally{null==n||n.dispose(),null==o||o.dispose(),null==i||i.dispose()}}async onSessionRequest(e,t){if(!e)throw new TypeError("Request is required.");if(e.requestType!==i.portForwardRequestType&&e.requestType!==i.cancelPortForwardRequestType)throw new Error(`Unexpected request type: ${e.requestType}`);const s=e.request.convertTo(new l.PortForwardRequestMessage),n=c.IPAddressConversions.fromSshAddress(s.addressToBind);let a=s.port;const h=new r.SshRequestEventArgs(e.requestType,s,this.session.principal);let d;if(await super.onSessionRequest(h,t),h.isAuthorized)if(e.requestType===i.portForwardRequestType){let e;try{e=await this.startForwarding(n,a,t)}catch(t){e=null}if(null!==e){const t=new u.PortForwardSuccessMessage;t.port=e,d=t}}else e.requestType===i.cancelPortForwardRequestType&&await this.cancelForwarding(n,a,t)&&(d=new r.SessionRequestSuccessMessage);if(e.responsePromise=Promise.resolve(null!=d?d:new r.SessionRequestFailureMessage),d instanceof u.PortForwardSuccessMessage){const e=new o.ForwardedPort(d.port,0===s.port?null:s.port,!0);this.remoteForwardedPorts.addPort(e)}}async startForwarding(e,t,s){if(this.acceptLocalConnectionsForForwardedPorts){const n=0===t?null:t,r=new p.LocalPortForwarder(this,this.session,i.portForwardChannelType,e,t);await r.startForwarding(s);const a=`${e}:${r.localPort}`;return this.localForwarders.set(a,r),t=r.localPort,r.onDisposed((()=>{const e=new o.ForwardedPort(t,n,!0);this.remoteForwardedPorts.removePort(e),this.localForwarders.delete(a)})),t}return t>0?t:null}async cancelForwarding(e,t,s){const i=`${e}:${t}`,n=this.localForwarders.get(i);return!!n&&(this.localForwarders.delete(i),n.dispose(),!0)}async onChannelOpening(e,t){var s;if(!e)throw new TypeError("Request is required.");const n=e.request.channelType;if(n!==i.portForwardChannelType&&n!==i.reversePortForwardChannelType)return void(e.failureReason=r.SshChannelOpenFailureReason.unknownChannelType);let a=null;const l=e.request instanceof h.PortForwardChannelOpenMessage?e.request:e.request.convertTo(new h.PortForwardChannelOpenMessage);if(e.isRemoteRequest)if(n===i.portForwardChannelType){const t=`${c.IPAddressConversions.fromSshAddress(l.host)}:${l.port}`;if(a=null!==(s=this.remoteConnectors.get(t))&&void 0!==s?s:null,!a)return this.trace(r.TraceLevel.Error,r.SshTraceEventIds.portForwardRequestInvalid,`PortForwardingService received forwarding channel for ${t} that was not requested.`),e.failureReason=r.SshChannelOpenFailureReason.connectFailed,void(e.failureDescription="Forwarding channel was not requested.")}else if(!this.acceptRemoteConnectionsForNonForwardedPorts){const t="The session has disabled connections to non-forwarded ports.";return this.session.trace(r.TraceLevel.Warning,r.SshTraceEventIds.portForwardChannelOpenFailed,t),e.failureDescription=t,void(e.failureReason=r.SshChannelOpenFailureReason.administrativelyProhibited)}const u=new r.SshChannelOpeningEventArgs(l,e.channel,e.isRemoteRequest);if(await super.onChannelOpening(u,t),e.failureReason=u.failureReason,e.failureDescription=u.failureDescription,e.failureReason===r.SshChannelOpenFailureReason.none&&e.isRemoteRequest)if(a){await a.onChannelOpening(e,t);const s=a instanceof f.RemotePortForwarder?a.localPort:null,i=new o.ForwardedPort(s,l.port,!1);this.localForwardedPorts.addChannel(i,e.channel)}else await f.RemotePortForwarder.forwardChannel(this,e,l.host,l.port,this.trace,t)}async openChannel(e,t,s,n,o,a,c){var l;let u;if(t===i.portForwardChannelType&&(u=this.remoteForwardedPorts.find((e=>e.remotePort===a||null===e.remotePort&&e.localPort===a)),!u))throw new Error(`Port ${a} is not being forwarded.`);const d=new h.PortForwardChannelOpenMessage;d.channelType=t,d.originatorIPAddress=null!=s?s:"",d.originatorPort=null!=n?n:0,d.host=o,d.port=null!==(l=null==u?void 0:u.localPort)&&void 0!==l?l:a;const p=this.session.trace;let f;try{f=await e.openChannel(d,null,c),p(r.TraceLevel.Info,r.SshTraceEventIds.portForwardChannelOpened,`PortForwardingService opened ${t} channel #${f.channelId} for ${o}:${a}.`)}catch(e){if(!(e instanceof Error))throw e;throw p(r.TraceLevel.Error,r.SshTraceEventIds.portForwardChannelOpenFailed,`PortForwardingService failed to open ${t} channel for ${o}:${a}: ${e.message}`,e),e}return t===i.portForwardChannelType&&this.remoteForwardedPorts.addChannel(u,f),f}dispose(){const e=[...this.channelForwarders,...this.localForwarders.values(),...this.remoteConnectors.values()];this.channelForwarders.splice(0,this.channelForwarders.length),this.localForwarders.clear(),this.remoteConnectors.clear();for(let t of e)t.dispose();super.dispose()}};m.portForwardRequestType="tcpip-forward",m.cancelPortForwardRequestType="cancel-tcpip-forward",m.portForwardChannelType="forwarded-tcpip",m.reversePortForwardChannelType="direct-tcpip",m=i=n([(0,r.serviceActivation)({sessionRequest:i.portForwardRequestType}),(0,r.serviceActivation)({sessionRequest:i.cancelPortForwardRequestType}),(0,r.serviceActivation)({channelType:i.portForwardChannelType}),(0,r.serviceActivation)({channelType:i.reversePortForwardChannelType})],m),t.PortForwardingService=m},4073:(e,t,s)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.RemotePortConnector=void 0;const i=s(2126),n=s(5788),r=s(2168),o=s(5777);class a extends i.SshService{constructor(e,t,s){super(e),this.forwarding=!1,this.remoteIPAddress=t,this.port=s}get remotePort(){return this.port}async request(e){if(this.forwarding)throw new Error("Already forwarding.");const t=new n.PortForwardRequestMessage;t.addressToBind=this.remoteIPAddress,t.port=this.remotePort,t.wantReply=!0;const s=await this.session.requestResponse(t,r.PortForwardSuccessMessage,i.SessionRequestFailureMessage,e);let o=!1;return s instanceof r.PortForwardSuccessMessage&&(0!==s.port&&(this.port=s.port),o=!0),this.forwarding=o,o}dispose(){if(this.forwarding){this.forwarding=!1;const e=new n.PortForwardRequestMessage;e.requestType=o.PortForwardingService.cancelPortForwardRequestType,e.addressToBind=this.remoteIPAddress,e.port=this.remotePort,e.wantReply=!1;try{this.session.request(e).catch((e=>{}))}catch(e){}}super.dispose()}}t.RemotePortConnector=a},5346:(e,t,s)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.RemotePortForwarder=void 0;const i=s(1808),n=s(2126),r=s(1317),o=s(4073);class a extends o.RemotePortConnector{constructor(e,t,s,i,n,r){super(t,s,i),this.pfs=e,this.localHost=n,this.localPort=r}async onChannelOpening(e,t){await a.forwardChannel(this.pfs,e,this.localHost,this.localPort,this.trace,t)}static async forwardChannel(e,t,s,o,a,c){const h=t.channel,l=i.createConnection({host:s,port:o}),u=new n.PromiseCompletionSource;let d=c?c.onCancellationRequested((()=>l.destroy(new Error("Cancelled.")))):null;try{l.once("connect",(()=>{u.resolve()})),l.once("error",(e=>{u.reject(e)})),await u.promise}catch(e){if(!(e instanceof Error)||(null==c?void 0:c.isCancellationRequested))throw e;a(n.TraceLevel.Error,n.SshTraceEventIds.portForwardConnectionFailed,`${h.session} PortForwardingService forwarded channel #${h.channelId} connection to ${s}:${o} failed: ${e.message}`,e),t.failureReason=n.SshChannelOpenFailureReason.connectFailed,t.failureDescription=e.message}finally{null==d||d.dispose()}const p=new r.ChannelForwarder(e,h,l);a(n.TraceLevel.Info,n.SshTraceEventIds.portForwardConnectionOpened,`${h.session} PortForwardingService forwarded channel #${h.channelId} connection to ${s}:${o}.`),e.channelForwarders.push(p)}}t.RemotePortForwarder=a},2022:(e,t,s)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.RemotePortStreamer=void 0;const i=s(3730),n=s(2126),r=s(4073);class o extends r.RemotePortConnector{constructor(e,t,s){super(e,t,s),this.streamOpenedEmitter=new i.Emitter,this.onStreamOpened=this.streamOpenedEmitter.event}async onChannelOpening(e,t){const s=new n.SshStream(e.channel);this.streamOpenedEmitter.fire(s)}}t.RemotePortStreamer=o},6376:(e,t,s)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.SshClient=void 0;const i=s(1808),n=s(2126);class r{constructor(e){if(this.config=e,this.sessions=[],this.trace=(e,t,s,i)=>{},!e)throw new TypeError("SshSessionConfiguration is required.")}async openSession(e,t,s){if(!e)throw new TypeError("Server host is reqiured.");const i=await this.openConnection(e,t,s),r=new n.SshClientSession(this.config);return r.trace=this.trace,await r.connect(i,s),this.sessions.push(r),r}async openConnection(e,t,s){let o=new i.Socket;return await new Promise(((i,a)=>{if(o.on("connect",i),o.on("error",a),s){if(s.isCancellationRequested)return void a(new n.CancellationError);s.onCancellationRequested(a)}o.connect(t||r.defaultServerPort,e)})),new n.NodeStream(o)}async reconnectSession(e,t,s,i){const n=await this.openConnection(t,s,i);await e.reconnect(n,i)}dispose(){for(;this.sessions.length>0;)this.sessions.shift().dispose()}}t.SshClient=r,r.defaultServerPort=22},58:(e,t,s)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.SshServer=void 0;const i=s(3730),n=s(2126),r=s(9572);t.SshServer=class{constructor(e){if(this.config=e,this.sessions=[],this.trace=(e,t,s,i)=>{},this.errorEmitter=new i.Emitter,this.onError=this.errorEmitter.event,this.sessionOpenedEmitter=new i.Emitter,this.onSessionOpened=this.sessionOpenedEmitter.event,this.credentials={publicKeys:[]},this.tcpListenerFactory=new r.DefaultTcpListenerFactory,!e)throw new TypeError("SshSessionConfiguration is required.");e.protocolExtensions.includes(n.SshProtocolExtensionNames.sessionReconnect)&&(this.reconnectableSessions=[])}async acceptSessions(e,t){t||(t="0.0.0.0");const s="0.0.0.0"===t?"port ":t+":";try{this.tcpListener=await this.tcpListenerFactory.createTcpListener(t,e,!1)}catch(t){if(!(t instanceof Error))throw t;throw this.trace(n.TraceLevel.Error,n.SshTraceEventIds.serverListenFailed,`SshServer failed to listen on ${s}${e}: ${t.message}`,t),t}this.tcpListener.addListener("connection",this.acceptSession.bind(this)),this.trace(n.TraceLevel.Info,n.SshTraceEventIds.serverListening,`SshServer listening on ${s}${e}.`)}async acceptConnection(e){return e.setNoDelay(!0),new n.NodeStream(e)}async acceptSession(e){this.trace(n.TraceLevel.Info,n.SshTraceEventIds.serverClientConnected,"SshServer client connected.");const t=await this.acceptConnection(e),s=new n.SshServerSession(this.config,this.reconnectableSessions);s.trace=this.trace,s.credentials=this.credentials,this.sessions.push(s),s.onClosed((e=>{const t=this.sessions.indexOf(s);t>=0&&this.sessions.splice(t,1)})),this.sessionOpenedEmitter.fire(s);try{await s.connect(t)}catch(e){if(!(e instanceof Error))throw e;e instanceof n.SshConnectionError?await s.close(e.reason||n.SshDisconnectReason.connectionLost,e.message,e):await s.close(n.SshDisconnectReason.protocolError,e.message,e),this.errorEmitter.fire(e)}}dispose(){var e;null===(e=this.tcpListener)||void 0===e||e.close()}}},9572:(e,t,s)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.DefaultTcpListenerFactory=void 0;const i=s(1808);t.DefaultTcpListenerFactory=class{async createTcpListener(e,t,s,n){if(!e)throw new TypeError("Local IP address is required.");if(!Number.isInteger(t)||t<0)throw new TypeError("Local port must be a non-negative integer.");const r=i.createServer();return await new Promise(((s,n)=>{r.listen({host:e,port:t,ipv6Only:i.isIPv6(e),exclusive:!1}),r.on("listening",s),r.on("error",n)})),r}}},6327:(e,t)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.curves=void 0,t.curves=[{shortName:"P-256",name:"nistp256",oid:"1.2.840.10045.3.1.7",keySize:256},{shortName:"P-384",name:"nistp384",oid:"1.3.132.0.34",keySize:384},{shortName:"P-521",name:"nistp521",oid:"1.3.132.0.35",keySize:521}]},7867:(e,t)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.EncryptionAlgorithm=void 0,t.EncryptionAlgorithm=class{constructor(e){this.name=e}}},3307:(e,t)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.HmacAlgorithm=void 0,t.HmacAlgorithm=class{constructor(e,t,s,i){this.name=e,this.algorithmName=t,this.keyLength=s,this.digestLength=i}}},4468:(e,t)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.KeyExchangeAlgorithm=void 0,t.KeyExchangeAlgorithm=class{constructor(e,t,s,i){this.name=e,this.keySizeInBits=t,this.hashAlgorithmName=s,this.hashDigestLength=i}}},3814:(e,t,s)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.Sec1KeyFormatter=t.Pkcs1KeyFormatter=t.parsePem=t.formatPem=void 0;const i=s(404),n=s(5875),r=s(6327);t.formatPem=function(e,t){return`-----BEGIN ${t}-----\n`+e.toString("base64").match(/.{1,64}/g).join("\n")+"\n"+`-----END ${t}-----\n`},t.parsePem=function(e){const t=e.replace(/-+[^-\n]+KEY-+/g,"").replace(/\s/g,"");return Buffer.from(t,"base64")},t.Pkcs1KeyFormatter=class{static formatRsaPublic(e){const t=new n.DerWriter(Buffer.alloc(1024));return t.writeInteger(e.modulus),t.writeInteger(e.exponent),t.toBuffer()}static formatRsaPrivate(e){if(!(e.d&&e.p&&e.q&&e.dp&&e.dq&&e.qi))throw new Error("Missing private key parameters.");const t=new n.DerWriter(Buffer.alloc(2048));return t.writeInteger(i.BigInt.fromInt32(0)),t.writeInteger(e.modulus),t.writeInteger(e.exponent),t.writeInteger(e.d),t.writeInteger(e.p),t.writeInteger(e.q),t.writeInteger(e.dp),t.writeInteger(e.dq),t.writeInteger(e.qi),t.toBuffer()}static parseRsaPublic(e){const t=new n.DerReader(e);return{modulus:t.readInteger(),exponent:t.readInteger()}}static parseRsaPrivate(e){const t=new n.DerReader(e);return t.readInteger(),{modulus:t.readInteger(),exponent:t.readInteger(),d:t.readInteger(),p:t.readInteger(),q:t.readInteger(),dp:t.readInteger(),dq:t.readInteger(),qi:t.readInteger()}}};class o{static formatECPublic(e){const t=r.curves.find((t=>t.oid===e.curve.oid)),s=Math.ceil(t.keySize/8),i=new n.DerWriter(Buffer.alloc(512)),a=new n.DerWriter(Buffer.alloc(100));a.writeObjectIdentifier(o.ecPublicKeyOid),a.writeObjectIdentifier(e.curve.oid),i.writeSequence(a);const c=e.x.toBytes({unsigned:!0,length:s}),h=e.y.toBytes({unsigned:!0,length:s}),l=Buffer.alloc(1+c.length+h.length);return l[0]=4,c.copy(l,1),h.copy(l,1+c.length),i.writeBitString(l),i.toBuffer()}static formatECPrivate(e){const t=r.curves.find((t=>t.oid===e.curve.oid)),s=Math.ceil(t.keySize/8),o=new n.DerWriter(Buffer.alloc(512));o.writeInteger(i.BigInt.fromInt32(1)),o.writeOctetString(e.d.toBytes({unsigned:!0,length:s}));const a=new n.DerWriter(Buffer.alloc(100));a.writeObjectIdentifier(e.curve.oid),o.writeTagged(0,a);const c=e.x.toBytes({unsigned:!0,length:s}),h=e.y.toBytes({unsigned:!0,length:s}),l=Buffer.alloc(1+c.length+h.length);l[0]=4,c.copy(l,1),h.copy(l,1+c.length);const u=new n.DerWriter(Buffer.alloc(512));return u.writeBitString(l),o.writeTagged(1,u),o.toBuffer()}static parseECPublic(e){var t;const s=new n.DerReader(e),a=s.readSequence(),c=a.readObjectIdentifier();if(c!==o.ecPublicKeyOid)throw new Error(`Unexpected key type OID: ${c}`);const h=a.readObjectIdentifier(),l=null===(t=r.curves.find((e=>e.oid===h)))||void 0===t?void 0:t.name,u=s.readBitString();if(u.length%2!=1)throw new Error(`Unexpected key data length: ${u.length}`);const d=i.BigInt.fromBytes(u.slice(1,1+(u.length-1)/2),{unsigned:!0}),p=i.BigInt.fromBytes(u.slice(1+(u.length-1)/2),{unsigned:!0});return{curve:{name:l,oid:h},x:d,y:p}}static parseECPrivate(e){var t;const s=new n.DerReader(e),o=s.readInteger().toInt32();if(1!==o)throw new Error(`Unsupported SEC1 format version: ${o}`);const a=i.BigInt.fromBytes(s.readOctetString(),{unsigned:!0}),c=s.tryReadTagged(0);if(!c)throw new Error("SEC1 curve info not found.");const h=c.readObjectIdentifier(),l=null===(t=r.curves.find((e=>e.oid===h)))||void 0===t?void 0:t.name,u=s.tryReadTagged(1);if(!u)throw new Error("SEC1 public key data not found.");const d=u.readBitString();if(d.length%2!=1)throw new Error(`Unexpected key data length: ${d.length}`);const p=i.BigInt.fromBytes(d.slice(1,1+(d.length-1)/2),{unsigned:!0}),f=i.BigInt.fromBytes(d.slice(1+(d.length-1)/2),{unsigned:!0});return{curve:{name:l,oid:h},x:p,y:f,d:a}}}t.Sec1KeyFormatter=o,o.ecPublicKeyOid="1.2.840.10045.2.1"},7158:(e,t,s)=>{"use strict";t.b=void 0;const i=s(6113),n=s(4300),r=s(9009),o=s(6327),a=s(404),c=s(5875),h=s(7914),l=s(3814),u=process.versions.node.split(".").map((e=>parseInt(e,10))),d=u[0]>10||10===u[0]&&u[1]>=12,p=u[0]>11||11===u[0]&&u[1]>=6;class f{constructor(e){this.comment=null,e&&(this.algorithmName=e)}get hasPublicKey(){return!!this.publicKey}get hasPrivateKey(){return!!this.privateKey}get keyAlgorithmName(){return this.algorithmName}get algorithmName(){return this.algorithm}set algorithmName(e){const t=e.split("-")[2];if(this.curve=o.curves.find((e=>e.name===t)),!this.curve)throw new Error("Invalid or unsupported ECDSA algorithm: "+e);this.algorithm=e}generate(){return d&&p?this.generateNodeKeyPairObjects():d?this.generateNodeKeyPairBuffers():this.generateExternalKeyPair()}async generateNodeKeyPairObjects(){[this.publicKey,this.privateKey]=await new Promise(((e,t)=>{const s={namedCurve:this.curve.shortName};try{i.generateKeyPair("ec",s,((s,i,n)=>{s?t(s):e([i,n])}))}catch(e){t(e)}}))}async generateNodeKeyPairBuffers(){[this.publicKey,this.privateKey]=await new Promise(((e,t)=>{const s={namedCurve:this.curve.shortName,publicKeyEncoding:{type:"spki",format:"pem"},privateKeyEncoding:{type:"sec1",format:"pem",cipher:void 0,passphrase:void 0}};try{i.generateKeyPair("ec",s,((s,i,n)=>{s?t(s):e([i,n])}))}catch(e){t(e)}}))}async generateExternalKeyPair(){throw new Error("This version of node does not support generating key pairs. Use node >= 10.12.")}async setPublicKeyBytes(e,t){if(!e)throw new TypeError("Buffer is required.");const s=new h.SshDataReader(e),n=s.readString("ascii");this.algorithmName=t||n;const r=s.readString("ascii");this.algorithmName=`ecdsa-sha2-${r}`;const o=s.readBinary(),c=a.BigInt.fromBytes(o.slice(1,1+(o.length-1)/2),{unsigned:!0}),u=a.BigInt.fromBytes(o.slice(1+(o.length-1)/2),{unsigned:!0}),d=l.Sec1KeyFormatter.formatECPublic({curve:{name:this.curve.name,oid:this.curve.oid},x:c,y:u});this.publicKey=p?i.createPublicKey({key:d,type:"spki",format:"der"}):(0,l.formatPem)(d,"PUBLIC KEY")}async getPublicKeyBytes(e){if(!this.publicKey)return null;let t;t="string"==typeof this.publicKey?(0,l.parsePem)(this.publicKey):this.publicKey.export({type:"spki",format:"der"});const s=l.Sec1KeyFormatter.parseECPublic(t);e=e||this.algorithmName||this.keyAlgorithmName;const i=new h.SshDataWriter(n.Buffer.alloc(512));i.writeString(e,"ascii"),i.writeString(this.curve.name,"ascii");const r=Math.ceil(this.curve.keySize/8),o=s.x.toBytes({unsigned:!0,length:r}),a=s.y.toBytes({unsigned:!0,length:r});return i.writeUInt32(1+o.length+a.length),i.writeByte(4),i.write(o),i.write(a),i.toBuffer()}async importParameters(e){if(!e.curve)throw new TypeError("A curve is required.");let t;if(e.curve.oid){if(t=o.curves.find((t=>t.oid===e.curve.oid)),!t)throw new Error(`Unsupported curve OID: ${e.curve.oid}`)}else{if(!e.curve.name)throw new TypeError("A curve OID or name is required.");if(t=o.curves.find((t=>t.name===e.curve.name)),!t)throw new Error(`Unsupported curve: ${e.curve.name}`)}this.algorithmName="ecdsa-sha2-"+t.name;const s=l.Sec1KeyFormatter.formatECPublic(e);if(this.publicKey=p?i.createPublicKey({key:s,type:"spki",format:"der"}):(0,l.formatPem)(s,"EC PUBLIC KEY"),e.d){const t=l.Sec1KeyFormatter.formatECPrivate(e);this.privateKey=p?i.createPrivateKey({key:t,type:"sec1",format:"der"}):(0,l.formatPem)(t,"EC PRIVATE KEY")}else this.privateKey=void 0}async exportParameters(){var e,t;if(!this.publicKey)throw new Error("Key is not present.");let s;return s="string"==typeof this.publicKey?(0,l.parsePem)(null!==(e=this.privateKey)&&void 0!==e?e:this.publicKey):(null!==(t=this.privateKey)&&void 0!==t?t:this.publicKey).export({type:this.privateKey?"sec1":"spki",format:"der"}),this.privateKey?l.Sec1KeyFormatter.parseECPrivate(s):l.Sec1KeyFormatter.parseECPublic(s)}dispose(){}}class g extends r.PublicKeyAlgorithm{constructor(e,t){super(e,e,t)}createKeyPair(){return new f(this.name)}async generateKeyPair(){const e=new f(this.name);return await e.generate(),e}createSigner(e){if(!(e instanceof f))throw new TypeError("ECDSA key pair object expected.");return new m(e,g.convertHashAlgorithmName(this.hashAlgorithmName))}createVerifier(e){if(!(e instanceof f))throw new TypeError("ECDSA key pair object expected.");return new m(e,g.convertHashAlgorithmName(this.hashAlgorithmName))}static convertHashAlgorithmName(e){return e.replace("SHA2-","SHA")}static getSignatureLength(e){return 2*(5+Math.ceil(e/8))}}t.b=g,g.ecdsaSha2Nistp256="ecdsa-sha2-nistp256",g.ecdsaSha2Nistp384="ecdsa-sha2-nistp384",g.ecdsaSha2Nistp521="ecdsa-sha2-nistp521",g.curves=o.curves,g.KeyPair=f;class m{constructor(e,t){this.keyPair=e,this.hashAlgorithmName=t}get digestLength(){const e=this.keyPair.curve;return e?g.getSignatureLength(e.keySize):0}async sign(e){if(!this.keyPair.privateKey)throw new Error("Private key not set.");const t=i.createSign(this.hashAlgorithmName);t.update(e);let s=t.sign(this.keyPair.privateKey);const r=new c.DerReader(s),o=r.readInteger(),a=r.readInteger(),l=Math.ceil(this.keyPair.curve.keySize/8),u=new h.SshDataWriter(n.Buffer.alloc(this.digestLength));return u.writeBinary(o.toBytes({unsigned:!0,length:l+1})),u.writeBinary(a.toBytes({unsigned:!0,length:l+1})),s=u.toBuffer(),s}async verify(e,t){if(!this.keyPair.publicKey)throw new Error("Public key not set.");const s=new h.SshDataReader(t),r=s.readBigInt(),o=s.readBigInt(),a=new c.DerWriter(n.Buffer.alloc(t.length));a.writeInteger(r),a.writeInteger(o),t=a.toBuffer();const l=i.createVerify(this.hashAlgorithmName);return l.update(e),l.verify(this.keyPair.publicKey,t)}dispose(){}}},637:(e,t,s)=>{"use strict";t.r=void 0;const i=s(6113),n=s(4300),r=s(7867);class o extends r.EncryptionAlgorithm{constructor(e,t,s,i){if(super(e),this.algorithmName=t,this.cipherMode=s,this.keySizeInBits=i,"AES"!==t)throw new Error(`Unsupported encryption algorithm: ${t}`);this.blockSizeInBits=o.getBlockSize(t)}get keyLength(){return this.keySizeInBits/8}get blockLength(){return this.blockSizeInBits/8}async createCipher(e,t,s){let i;if("CTR"===this.cipherMode||"CBC"===this.cipherMode)i=new a(e,this.keySizeInBits,this.blockSizeInBits,t,s,this.cipherMode);else{if("GCM"!==this.cipherMode)throw new Error(`Unsupported cipher mode: ${this.cipherMode}`);i=new c(e,this.keySizeInBits,this.blockSizeInBits,t,s)}return i}static getBlockSize(e){if("AES"===e)return 128;throw new Error(`Unsupported encryption algorithm: ${e}`)}}t.r=o;class a{constructor(e,t,s,n,r,o){this.isEncryption=e,this.keySizeInBits=t,this.blockSizeInBits=s;const a=`AES-${this.keySizeInBits}-${o}`;this.cipher=this.isEncryption?i.createCipheriv(a,n,r):i.createDecipheriv(a,n,r),this.cipher.setAutoPadding(!1)}get blockLength(){return this.blockSizeInBits/8}transform(e){const t=this.cipher.update(e);if(t.length!==e.length){const s=`Result from encrypt/decrypt has invalid length ${t.length}, expected ${e.length}.`;throw new Error(s)}return Promise.resolve(t)}dispose(){}}class c{constructor(e,t,s,i,r){this.isEncryption=e,this.keySizeInBits=t,this.blockSizeInBits=s,this.tag=null,this.algorithmName=`aes-${this.keySizeInBits}-gcm`,this.key=n.Buffer.alloc(i.length),i.copy(this.key),this.nonce=n.Buffer.alloc(12),r.copy(this.nonce,0,0,12),this.associatedData=n.Buffer.alloc(4)}get blockLength(){return this.blockSizeInBits/8}get digestLength(){return 16}get authenticatedEncryption(){return!0}transform(e){if(e.length%this.blockLength!=0){const t=`Encrypt/decrypt input has invalid length ${e.length}, not a multiple of block size ${this.blockLength}.`;throw new Error(t)}const t=this.isEncryption?i.createCipheriv(this.algorithmName,this.key,this.nonce):i.createDecipheriv(this.algorithmName,this.key,this.nonce),s=e.length;if(this.associatedData[0]=s>>>24,this.associatedData[1]=s>>>16,this.associatedData[2]=s>>>8,this.associatedData[3]=s,t.setAAD(this.associatedData),!this.isEncryption){if(!this.tag)throw new Error("AES-GCM tag was not set before decrypting.");t.setAuthTag(this.tag)}const n=t.update(e);if(n.length!==e.length){const t=`Result from encrypt/decrypt has invalid length ${n.length}, expected ${e.length}.`;throw new Error(t)}t.final(),this.isEncryption?this.tag=t.getAuthTag():this.tag=null;let r=12;for(;--r>=4&&(this.nonce[r]++,0===this.nonce[r]););return Promise.resolve(n)}async sign(e){if(!this.tag)throw new Error("AES-GCM tag was not obtained by encrypting.");return this.tag}async verify(e,t){if(t.length!==this.digestLength)throw new Error("Incorrect AES-GCM tag length.");return this.tag=t,!0}dispose(){}}},9133:(e,t,s)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.NodeHmac=void 0;const i=s(6113),n=s(4300),r=s(3307);class o extends r.HmacAlgorithm{constructor(e,t,s=!1){super(e,t,o.getHashKeyLength(t),o.getHashDigestLength(t)),this.encryptThenMac=s}async createSigner(e){return new a(o.getNodeHashAlgorithmName(this.algorithmName),this.digestLength,this.encryptThenMac,e)}async createVerifier(e){return new a(o.getNodeHashAlgorithmName(this.algorithmName),this.digestLength,this.encryptThenMac,e)}static getHashKeyLength(e){if("SHA2-512"===e)return 64;if("SHA2-384"===e)return 48;if("SHA2-256"===e)return 32;throw new Error(`Unsupported hash algorithm: ${e}`)}static getHashDigestLength(e){return this.getHashKeyLength(e)}static getNodeHashAlgorithmName(e){if("SHA2-512"===e)return"sha512";if("SHA2-384"===e)return"sha384";if("SHA2-256"===e)return"sha256";throw new Error(`Unsupported hash algorithm: ${e}`)}}t.NodeHmac=o;class a{constructor(e,t,s,r){this.algorithmName=e,this.digestLength=t,this.encryptThenMac=s,this.key=i.createSecretKey?i.createSecretKey(r):n.Buffer.from(r)}async sign(e){const t=i.createHmac(this.algorithmName,this.key);return t.update(e),t.digest()}async verify(e,t){const s=i.createHmac(this.algorithmName,this.key);return s.update(e),s.digest().equals(t)}dispose(){}}},7631:(e,t,s)=>{"use strict";t.th=t.yk=void 0;const i=s(6113),n=s(4300),r=s(4468),o=s(9133),a=s(404);class c extends r.KeyExchangeAlgorithm{constructor(e,t,s){super(e,t,s,o.NodeHmac.getHashDigestLength(s))}createKeyExchange(){return new h(this.keySizeInBits,o.NodeHmac.getNodeHashAlgorithmName(this.hashAlgorithmName),this.hashDigestLength)}}t.yk=c;class h{constructor(e,t,s){switch(this.hashAlgorithmName=t,this.digestLength=s,e){case 1024:this.dh=i.getDiffieHellman("modp2");break;case 2048:this.dh=i.getDiffieHellman("modp14");break;case 4096:this.dh=i.getDiffieHellman("modp16");break;default:throw new Error("Invalid DH bit length.")}}startKeyExchange(){const e=this.dh.generateKeys(),t=a.BigInt.fromBytes(e,{unsigned:!0}).toBytes();return Promise.resolve(t)}decryptKeyExchange(e){const t=this.dh.computeSecret(e),s=a.BigInt.fromBytes(t,{unsigned:!0}).toBytes();return Promise.resolve(s)}async sign(e){const t=i.createHash(this.hashAlgorithmName);return t.update(e),n.Buffer.from(t.digest())}dispose(){}}class l extends r.KeyExchangeAlgorithm{constructor(e,t,s){super(e,t,s,o.NodeHmac.getHashDigestLength(s))}createKeyExchange(){return new u(this.keySizeInBits,o.NodeHmac.getNodeHashAlgorithmName(this.hashAlgorithmName),this.hashDigestLength)}}t.th=l;class u{constructor(e,t,s){switch(this.hashAlgorithmName=t,this.digestLength=s,e){case 256:this.ecdh=i.createECDH("prime256v1");break;case 384:this.ecdh=i.createECDH("secp384r1");break;case 521:this.ecdh=i.createECDH("secp521r1");break;default:throw new Error("Invalid ECDH bit length.")}}startKeyExchange(){const e=this.ecdh.generateKeys();return Promise.resolve(e)}decryptKeyExchange(e){const t=this.ecdh.computeSecret(e),s=a.BigInt.fromBytes(t,{unsigned:!0}).toBytes();return Promise.resolve(s)}async sign(e){const t=i.createHash(this.hashAlgorithmName);return t.update(e),n.Buffer.from(t.digest())}dispose(){}}},2750:(e,t,s)=>{"use strict";t.e=void 0;const i=s(6113);t.e=class{getBytes(e){i.randomBytes(e.length).copy(e)}}},338:(e,t,s)=>{"use strict";t.G=void 0;const i=s(6113),n=s(4300),r=s(9009),o=s(7914),a=s(9133),c=s(3814),h=process.versions.node.split(".").map((e=>parseInt(e,10))),l=h[0]>10||10===h[0]&&h[1]>=12,u=h[0]>11||11===h[0]&&h[1]>=6;class d{constructor(){this.comment=null}get hasPublicKey(){return!!this.publicKey}get hasPrivateKey(){return!!this.privateKey}get keyAlgorithmName(){return p.keyAlgorithmName}generate(e){return e=null!=e?e:d.defaultKeySize,l&&u?this.generateNodeKeyPairObjects(e):l?this.generateNodeKeyPairBuffers(e):this.generateExternalKeyPair(e)}async generateNodeKeyPairObjects(e){[this.publicKey,this.privateKey]=await new Promise(((t,s)=>{const n={modulusLength:e};try{i.generateKeyPair("rsa",n,((e,i,n)=>{e?s(e):t([i,n])}))}catch(e){s(e)}}))}async generateNodeKeyPairBuffers(e){[this.publicKey,this.privateKey]=await new Promise(((t,s)=>{const n={modulusLength:e,publicKeyEncoding:{type:"pkcs1",format:"pem"},privateKeyEncoding:{type:"pkcs1",format:"pem",cipher:void 0,passphrase:void 0}};try{i.generateKeyPair("rsa",n,((e,i,n)=>{e?s(e):t([i,n])}))}catch(e){s(e)}}))}async generateExternalKeyPair(e){const t=new(await Promise.resolve().then((()=>s(2859))))({b:e});this.publicKey=t.exportKey("pkcs1-public-pem"),this.privateKey=t.exportKey("pkcs1-private-pem"),this.publicKey.endsWith("\n")||(this.publicKey+="\n"),this.privateKey.endsWith("\n")||(this.privateKey+="\n")}async setPublicKeyBytes(e){if(!e)throw new TypeError("Buffer is required.");const t=new o.SshDataReader(e),s=t.readString("ascii");if(s!==this.keyAlgorithmName&&s!==p.rsaWithSha256&&s!==p.rsaWithSha512)throw new Error(`Invalid RSA key algorithm: ${s}`);const n=t.readBigInt(),r=t.readBigInt();e=c.Pkcs1KeyFormatter.formatRsaPublic({modulus:r,exponent:n}),this.publicKey=u?i.createPublicKey({key:e,type:"pkcs1",format:"der"}):(0,c.formatPem)(e,"RSA PUBLIC KEY")}async getPublicKeyBytes(e){if(!this.publicKey)return null;let t;e||(e=this.keyAlgorithmName),t="string"==typeof this.publicKey?(0,c.parsePem)(this.publicKey):this.publicKey.export({type:"pkcs1",format:"der"});const s=c.Pkcs1KeyFormatter.parseRsaPublic(t),i=n.Buffer.alloc(512),r=new o.SshDataWriter(i);return r.writeString(e,"ascii"),r.writeBigInt(s.exponent),r.writeBigInt(s.modulus),t=r.toBuffer(),t}async importParameters(e){if(u)this.publicKey=i.createPublicKey({key:c.Pkcs1KeyFormatter.formatRsaPublic(e),format:"der",type:"pkcs1"}),e.d?this.privateKey=i.createPrivateKey({key:c.Pkcs1KeyFormatter.formatRsaPrivate(e),format:"der",type:"pkcs1"}):this.privateKey=void 0;else{const t=c.Pkcs1KeyFormatter.formatRsaPublic(e);if(this.publicKey=(0,c.formatPem)(t,"RSA PUBLIC KEY"),e.d){const t=c.Pkcs1KeyFormatter.formatRsaPrivate(e);this.privateKey=(0,c.formatPem)(t,"RSA PRIVATE KEY")}}}async exportParameters(){var e,t;if(!this.publicKey)throw new Error("Public key not set.");let s;return s=u?(null!==(e=this.privateKey)&&void 0!==e?e:this.publicKey).export({format:"der",type:"pkcs1"}):(0,c.parsePem)(null!==(t=this.privateKey)&&void 0!==t?t:this.publicKey),this.privateKey?c.Pkcs1KeyFormatter.parseRsaPrivate(s):c.Pkcs1KeyFormatter.parseRsaPublic(s)}dispose(){this.publicKey=void 0,this.privateKey=void 0}}d.defaultKeySize=2048;class p extends r.PublicKeyAlgorithm{constructor(e,t){super(e,p.keyAlgorithmName,t)}createKeyPair(){return new d}async generateKeyPair(e){const t=new d;return await t.generate(e),t}createSigner(e){if(!(e instanceof d))throw new TypeError("RSA key pair object expected.");return new f(e,p.convertHashAlgorithmName(this.hashAlgorithmName),a.NodeHmac.getHashDigestLength(this.hashAlgorithmName))}createVerifier(e){if(!(e instanceof d))throw new TypeError("RSA key pair object expected.");return new f(e,p.convertHashAlgorithmName(this.hashAlgorithmName),a.NodeHmac.getHashDigestLength(this.hashAlgorithmName))}static convertHashAlgorithmName(e){return e.replace("SHA2-","SHA")}}t.G=p,p.keyAlgorithmName="ssh-rsa",p.rsaWithSha256="rsa-sha2-256",p.rsaWithSha512="rsa-sha2-512",p.KeyPair=d;class f{constructor(e,t,s){this.keyPair=e,this.hashAlgorithmName=t,this.digestLength=s}async sign(e){if(!this.keyPair.privateKey)throw new Error("Private key not set.");const t=i.createSign(this.hashAlgorithmName);return t.update(e),t.sign(this.keyPair.privateKey)}async verify(e,t){if(!this.keyPair.publicKey)throw new Error("Public key not set.");const s=i.createVerify(this.hashAlgorithmName);return s.update(e),s.verify(this.keyPair.publicKey,t)}dispose(){}}},9009:(e,t,s)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.PublicKeyAlgorithm=void 0;const i=s(4300),n=s(7914);t.PublicKeyAlgorithm=class{constructor(e,t,s){this.name=e,this.keyAlgorithmName=t,this.hashAlgorithmName=s}readSignatureData(e){const t=new n.SshDataReader(e),s=t.readString("ascii");if(s!==this.name)throw new Error(`Mismatched public key algorithm: got '${s}', expected '${this.name}'.`);return t.readBinary()}createSignatureData(e){const t=new n.SshDataWriter(i.Buffer.alloc(this.name.length+e.length+20));return t.writeString(this.name,"ascii"),t.writeBinary(e),t.toBuffer()}}},1605:(e,t,s)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.algorithmNames=t.SshAlgorithms=t.Encryption=t.ECDsa=t.Rsa=t.HmacAlgorithm=t.EncryptionAlgorithm=t.PublicKeyAlgorithm=t.KeyExchangeAlgorithm=void 0;const i=s(4468);Object.defineProperty(t,"KeyExchangeAlgorithm",{enumerable:!0,get:function(){return i.KeyExchangeAlgorithm}});const n=s(9009);Object.defineProperty(t,"PublicKeyAlgorithm",{enumerable:!0,get:function(){return n.PublicKeyAlgorithm}});const r=s(7867);Object.defineProperty(t,"EncryptionAlgorithm",{enumerable:!0,get:function(){return r.EncryptionAlgorithm}});const o=s(3307);Object.defineProperty(t,"HmacAlgorithm",{enumerable:!0,get:function(){return o.HmacAlgorithm}});const a=!("object"!=typeof crypto||!crypto.subtle),c=s(6554),h=s(2001),l=s(918),u=s(4522),d=s(5914),p=s(1685),f=a?c.WebDiffieHellman:s(7631).yk,g=a?c.WebECDiffieHellman:s(7631).th,m=a?h.WebRsa:s(338).G;t.Rsa=m;const y=a?l.WebECDsa:s(7158).b;t.ECDsa=y;const v=a?u.WebEncryption:s(637).r;t.Encryption=v;const w=a?d.WebHmac:s(9133).NodeHmac,S=a?p.WebRandom:s(2750).e;class b{}t.SshAlgorithms=b,b.keyExchange={none:null,dhGroup14Sha256:new f("diffie-hellman-group14-sha256",2048,"SHA2-256"),dhGroup16Sha512:new f("diffie-hellman-group16-sha512",4096,"SHA2-512"),ecdhNistp256Sha256:new g("ecdh-sha2-nistp256",256,"SHA2-256"),ecdhNistp384Sha384:new g("ecdh-sha2-nistp384",384,"SHA2-384"),ecdhNistp521Sha512:new g("ecdh-sha2-nistp521",521,"SHA2-512")},b.publicKey={none:null,rsaWithSha256:new m("rsa-sha2-256","SHA2-256"),rsaWithSha512:new m("rsa-sha2-512","SHA2-512"),ecdsaSha2Nistp256:new y("ecdsa-sha2-nistp256","SHA2-256"),ecdsaSha2Nistp384:new y("ecdsa-sha2-nistp384","SHA2-384"),ecdsaSha2Nistp521:new y("ecdsa-sha2-nistp521","SHA2-512")},b.encryption={none:null,aes256Ctr:new v("aes256-ctr","AES","CTR",256),aes256Gcm:new v("aes256-gcm@openssh.com","AES","GCM",256)},b.hmac={none:null,hmacSha256:new w("hmac-sha2-256","SHA2-256"),hmacSha512:new w("hmac-sha2-512","SHA2-512"),hmacSha256Etm:new w("hmac-sha2-256-etm@openssh.com","SHA2-256",!0),hmacSha512Etm:new w("hmac-sha2-512-etm@openssh.com","SHA2-512",!0)},b.compression={none:null},b.random=new S,t.algorithmNames=function(e){return e.map((e=>e?e.name:"none"))}},453:(e,t,s)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.JsonWebKeyFormatter=void 0;const i=s(404),n=s(6327);class r{static formatRsa(e,t){const s=r.formatBigInt;let i;if(!1!==t&&e.d&&e.p&&e.q&&e.dp&&e.dq&&e.qi)i={kty:"RSA",n:s(e.modulus),e:s(e.exponent),d:s(e.d),p:s(e.p),q:s(e.q),dp:s(e.dp),dq:s(e.dq),qi:s(e.qi)};else{if(t)throw new Error("Missing private key parameters.");i={kty:"RSA",n:s(e.modulus),e:s(e.exponent)}}return i}static parseRsa(e,t){if("RSA"!==(null==e?void 0:e.kty)||!e.n||!e.e)throw new Error("Invalid RSA JWK.");const s=r.parseBigInt;let i;return i=!1!==t&&e.d&&e.p&&e.q&&e.dp&&e.dq&&e.qi?{modulus:s(e.n),exponent:s(e.e),d:s(e.d),p:s(e.p),q:s(e.q),dp:s(e.dp),dq:s(e.dq),qi:s(e.qi)}:{modulus:s(e.n),exponent:s(e.e)},i}static formatEC(e,t){const s=r.formatBigInt,i=n.curves.find((t=>t.oid===e.curve.oid||t.name===e.curve.name||t.shortName===e.curve.name)),o=Math.ceil(i.keySize/8),a={kty:"EC",crv:e.curve.name,x:s(e.x,o),y:s(e.y,o)};if(!1!==t&&e.d)a.d=s(e.d,o);else if(t)throw new Error("Missing private key parameters.");return a}static parseEC(e,t){if("EC"!==(null==e?void 0:e.kty)||!(e.crv&&e.x&&e.y))throw new Error("Invalid EC JWK.");const s=r.parseBigInt,i={curve:{name:e.crv},x:s(e.x),y:s(e.y)};return!1!==t&&e.d&&(i.d=s(e.d)),i}static formatBigInt(e,t){return r.base64UrlEncode(e.toBytes({unsigned:!0,length:t}))}static parseBigInt(e){return i.BigInt.fromBytes(Buffer.from(e,"base64"),{unsigned:!0})}static base64UrlEncode(e){return e.toString("base64").replace(/=+$/g,"").replace(/\+/g,"-").replace(/\//g,"_")}}t.JsonWebKeyFormatter=r},918:(e,t,s)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.WebECDsa=void 0;const i=s(4300),n=s(9009),r=s(7914),o=s(6327),a=s(404),c=s(453);class h{constructor(e){this.comment=null,e&&(this.algorithmName=e)}get hasPublicKey(){return!!this.publicKey}get hasPrivateKey(){return!!this.privateKey}get keyAlgorithmName(){return this.algorithmName}get algorithmName(){return this.algorithm}set algorithmName(e){const t=e.split("-")[2];if(this.curve=o.curves.find((e=>e.name===t)),!this.curve)throw new Error("Invalid or unsupported ECDSA algorithm: "+e);this.algorithm=e}async generate(){try{const e={name:"ECDSA",namedCurve:this.curve.shortName},t=await crypto.subtle.generateKey(e,!0,["sign","verify"]);this.publicKey=t.publicKey,this.privateKey=t.privateKey}catch(e){throw new Error("Failed to generate RSA key pair: "+e)}}async setPublicKeyBytes(e,t){if(!e)throw new TypeError("Buffer is required.");const s=new r.SshDataReader(e),i=s.readString("ascii");if(this.algorithmName=t||i,s.readString("ascii")!==this.curve.name)throw new Error("EC curve name does not match.");const n=s.readBinary(),o=Math.ceil(this.curve.keySize/8),h=a.BigInt.fromBytes(n.slice(1,1+o),{unsigned:!0}),l=a.BigInt.fromBytes(n.slice(1+o,n.length),{unsigned:!0}),u=c.JsonWebKeyFormatter.formatEC({curve:{name:this.curve.shortName,oid:this.curve.oid},x:h,y:l});try{const e={name:"ECDSA",namedCurve:this.curve.shortName};this.publicKey=await crypto.subtle.importKey("jwk",u,e,!0,["verify"])}catch(e){throw new Error("Failed to import EC public key: "+e)}}async getPublicKeyBytes(e){if(!this.publicKey)return null;let t;try{t=await crypto.subtle.exportKey("jwk",this.publicKey)}catch(e){throw new Error("Failed to export ECDSA public key: "+e)}const s=i.Buffer.from(t.x,"base64"),n=i.Buffer.from(t.y,"base64"),o=Math.ceil(this.curve.keySize/8);if(s.length!==o||n.length!==o)throw new Error("Unexpected key length.");e=e||this.algorithmName||this.keyAlgorithmName;const a=i.Buffer.alloc(e.length+s.length+n.length+10),c=new r.SshDataWriter(a);return c.writeString(e,"ascii"),c.writeString(this.curve.name,"ascii"),c.writeUInt32(1+s.length+n.length),c.writeByte(4),c.write(s),c.write(n),c.toBuffer()}async importParameters(e){if(!e.curve)throw new TypeError("A curve is required.");let t;if(e.curve.oid){if(t=o.curves.find((t=>t.oid===e.curve.oid)),!t)throw new Error(`Unsupported curve OID: ${e.curve.oid}`)}else{if(!e.curve.name)throw new TypeError("A curve OID or name is required.");if(t=o.curves.find((t=>t.name===e.curve.name)),!t)throw new Error(`Unsupported curve: ${e.curve.name}`)}this.algorithmName="ecdsa-sha2-"+t.name;const s={name:"ECDSA",namedCurve:this.curve.shortName},i=c.JsonWebKeyFormatter.formatEC(e);i.crv=this.curve.shortName;try{i.d?(this.privateKey=await crypto.subtle.importKey("jwk",i,s,!0,["sign"]),i.d=void 0):this.privateKey=void 0,this.publicKey=await crypto.subtle.importKey("jwk",i,s,!0,["verify"])}catch(e){throw new Error("Failed to import ECDSA key pair: "+e)}}async exportParameters(){var e;const t=null!==(e=this.privateKey)&&void 0!==e?e:this.publicKey;if(!t)throw new Error("Key not present.");let s;try{s=await crypto.subtle.exportKey("jwk",t)}catch(e){throw new Error("Failed to export ECDSA key pair: "+e)}const i=c.JsonWebKeyFormatter.parseEC(s);return i.curve={name:this.curve.name,oid:this.curve.oid},i}dispose(){}}class l extends n.PublicKeyAlgorithm{constructor(e,t){super(e,e,t)}createKeyPair(){return new h(this.name)}async generateKeyPair(){const e=new h(this.name);return await e.generate(),e}createSigner(e){if(!(e instanceof h))throw new TypeError("ECDSA key pair object expected.");const t=l.convertHashAlgorithmName(this.hashAlgorithmName);return new u(e,t)}createVerifier(e){if(!(e instanceof h))throw new TypeError("ECDSA key pair object expected.");const t=l.convertHashAlgorithmName(this.hashAlgorithmName);return new u(e,t)}static convertHashAlgorithmName(e){return e.replace("SHA2-","SHA-")}static getSignatureLength(e){return 2*(5+Math.ceil(e/8))}}t.WebECDsa=l,l.ecdsaSha2Nistp256="ecdsa-sha2-nistp256",l.ecdsaSha2Nistp384="ecdsa-sha2-nistp384",l.ecdsaSha2Nistp521="ecdsa-sha2-nistp521",l.curves=o.curves,l.KeyPair=h;class u{constructor(e,t){this.keyPair=e,this.hashAlgorithm=t}get digestLength(){const e=this.keyPair.curve;return e?l.getSignatureLength(e.keySize):0}async sign(e){if(!this.keyPair.privateKey)throw new Error("Private key not set.");let t=i.Buffer.from(await crypto.subtle.sign({name:"ECDSA",hash:{name:this.hashAlgorithm}},this.keyPair.privateKey,e));const s=Math.ceil(this.keyPair.curve.keySize/8);if(t.length!==2*s)throw new Error(`Unexpected signature length: ${t.length}`);const n=a.BigInt.fromBytes(t.slice(0,s),{unsigned:!0}),o=a.BigInt.fromBytes(t.slice(s,t.length),{unsigned:!0}),c=new r.SshDataWriter(i.Buffer.alloc(this.digestLength));return c.writeBinary(n.toBytes({unsigned:!0,length:s+1})),c.writeBinary(o.toBytes({unsigned:!0,length:s+1})),t=c.toBuffer(),t}async verify(e,t){if(!this.keyPair.publicKey)throw new Error("Public key not set.");const s=new r.SshDataReader(t),n=s.readBigInt(),o=s.readBigInt(),a=Math.ceil(this.keyPair.curve.keySize/8);return t=i.Buffer.alloc(2*a),n.toBytes({unsigned:!0,length:a}).copy(t,0),o.toBytes({unsigned:!0,length:a}).copy(t,a),await crypto.subtle.verify({name:"ECDSA",hash:{name:this.hashAlgorithm}},this.keyPair.publicKey,t,e)}dispose(){}}},4522:(e,t,s)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.WebEncryption=void 0;const i=s(4300),n=s(7867);class r extends n.EncryptionAlgorithm{constructor(e,t,s,i){super(e),this.algorithmName=t,this.cipherMode=s,this.keySizeInBits=i,this.blockSizeInBits=r.getBlockSize(t)}get keyLength(){return this.keySizeInBits/8}get blockLength(){return this.blockSizeInBits/8}async createCipher(e,t,s){const i=new o(e,this.algorithmName,this.cipherMode,this.keySizeInBits,this.blockSizeInBits);return await i.init(t,s),i}static getBlockSize(e){if("AES"===e)return 128;throw new Error(`Unsupported encryption algorithm: ${e}`)}}t.WebEncryption=r;class o{constructor(e,t,s,n,r){if(this.isEncryption=e,this.algorithmName=t,this.cipherMode=s,this.keySizeInBits=n,this.blockSizeInBits=r,this.tag=null,"AES"===this.algorithmName&&"CTR"===this.cipherMode)this.transform=this.aesCtr.bind(this,e);else if("AES"===this.algorithmName&&"CBC"===this.cipherMode)this.transform=this.aesCbc.bind(this,e);else{if("AES"!==this.algorithmName||"GCM"!==this.cipherMode)throw new Error(`Unsupported encryption algorithm: ${this.algorithmName}-${this.cipherMode}`);this.transform=this.aesGcm.bind(this,e),this.associatedData=i.Buffer.alloc(4),this.decryptBuffer=i.Buffer.alloc(4*this.blockLength)}}get blockLength(){return this.blockSizeInBits/8}async init(e,t){try{const t=`${this.algorithmName}-${this.cipherMode}`;this.key=await crypto.subtle.importKey("raw",e,{name:t,length:this.keySizeInBits},!1,this.isEncryption?["encrypt"]:["decrypt"])}catch(e){throw new Error("Failed to initialize AES: "+e)}"GCM"===this.cipherMode?this.iv=i.Buffer.from(t.slice(0,12)):this.iv=i.Buffer.from(t)}async aesCtr(e,t){if(t.length%this.blockLength!=0){const e=`Encrypt/decrypt input has invalid length ${t.length}, not a multiple of block size ${this.blockLength}.`;throw new Error(e)}let s;if(s=e?i.Buffer.from(await crypto.subtle.encrypt({name:"AES-CTR",counter:this.iv,length:this.blockSizeInBits},this.key,t)):i.Buffer.from(await crypto.subtle.decrypt({name:"AES-CTR",counter:this.iv,length:this.blockSizeInBits},this.key,t)),s.length!==t.length){const e=`Result from encrypt/decrypt has invalid length ${s.length}, expected ${t.length}.`;throw new Error(e)}const n=t.length/this.blockLength;for(let e=0;e<n;e++)for(let e=this.iv.length-1;e>=0&&(this.iv[e]=this.iv[e]+1,!this.iv[e]);e--);return s}async aesCbc(e,t){if(e){let e=i.Buffer.from(await crypto.subtle.encrypt({name:"AES-CBC",iv:this.iv},this.key,t));return e=e.slice(0,t.length),e}return i.Buffer.from(await crypto.subtle.decrypt({name:"AES-CBC",iv:this.iv},this.key,t))}async aesGcm(e,t){if(t.length%this.blockLength!=0){const e=`Encrypt/decrypt input has invalid length ${t.length}, not a multiple of block size ${this.blockLength}.`;throw new Error(e)}const s=t.length;let n;if(this.associatedData[0]=s>>>24,this.associatedData[1]=s>>>16,this.associatedData[2]=s>>>8,this.associatedData[3]=s,e)n=i.Buffer.from(await crypto.subtle.encrypt({name:"AES-GCM",iv:this.iv,additionalData:this.associatedData,tagLength:8*this.digestLength},this.key,t)),this.tag=n.slice(n.length-this.digestLength),n=n.slice(0,n.length-this.digestLength);else{if(!this.tag)throw new Error("AES-GCM tag was not set before decrypting.");const e=t.length+this.digestLength;if(this.decryptBuffer.length<e){let t=2*this.decryptBuffer.length;for(;t<e;)t*=2;this.decryptBuffer=i.Buffer.alloc(t)}const s=this.decryptBuffer.slice(0,e);t.copy(s,0),this.tag.copy(s,t.length),n=i.Buffer.from(await crypto.subtle.decrypt({name:"AES-GCM",iv:this.iv,additionalData:this.associatedData,tagLength:8*this.digestLength},this.key,s))}if(n.length!==t.length){const e=`Result from encrypt/decrypt has invalid length ${n.length}, expected ${t.length}.`;throw new Error(e)}let r=12;for(;--r>=4&&(this.iv[r]++,0===this.iv[r]););return n}get digestLength(){return 16}get authenticatedEncryption(){return"GCM"===this.cipherMode}async sign(e){if(!this.tag)throw new Error("AES-GCM tag was not obtained by encrypting.");return this.tag}async verify(e,t){if(t.length!==this.digestLength)throw new Error("Incorrect AES-GCM tag length.");return this.tag=t,!0}dispose(){}}},5914:(e,t,s)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.WebHmac=void 0;const i=s(4300),n=s(3307);class r extends n.HmacAlgorithm{constructor(e,t,s=!1){super(e,t,r.getHashKeyLength(t),r.getHashDigestLength(t)),this.encryptThenMac=s}async createSigner(e){const t=new o(this.algorithmName,!0,this.digestLength,this.encryptThenMac);return await t.init(e),t}async createVerifier(e){const t=new o(this.algorithmName,!1,this.digestLength,this.encryptThenMac);return await t.init(e),t}static getHashKeyLength(e){if("SHA2-512"===e)return 64;if("SHA2-384"===e)return 48;if("SHA2-256"===e)return 32;throw new Error(`Unsupported hash algorithm: ${e}`)}static getHashDigestLength(e){return this.getHashKeyLength(e)}static getWebHashAlgorithmName(e){if("SHA2-512"===e)return"SHA-512";if("SHA2-384"===e)return"SHA-384";if("SHA2-256"===e)return"SHA-256";throw new Error(`Unsupported hash algorithm: ${e}`)}}t.WebHmac=r;class o{constructor(e,t,s,i){this.algorithmName=e,this.isSigning=t,this.digestLength=s,this.encryptThenMac=i}async init(e){try{const t=this.algorithmName.replace("SHA2-","SHA-");this.key=await crypto.subtle.importKey("raw",e,{name:"HMAC",hash:{name:t}},!1,this.isSigning?["sign"]:["verify"])}catch(e){throw new Error("Failed to initialize HMAC: "+e)}}async sign(e){return i.Buffer.from(await crypto.subtle.sign({name:"HMAC",hash:{name:this.algorithmName}},this.key,e))}async verify(e,t){return await crypto.subtle.verify({name:"HMAC",hash:{name:this.algorithmName}},this.key,t,e)}dispose(){}}},6554:(e,t,s)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.WebECDiffieHellman=t.WebDiffieHellman=void 0;const i=s(4300),n=s(3848),r=s(4468),o=s(5914),a=s(404),c=s(453);class h extends r.KeyExchangeAlgorithm{constructor(e,t,s){super(e,t,s,o.WebHmac.getHashDigestLength(s))}createKeyExchange(){return new l(this.keySizeInBits,o.WebHmac.getWebHashAlgorithmName(this.hashAlgorithmName),this.hashDigestLength)}}t.WebDiffieHellman=h;class l{constructor(e,t,s){switch(this.hashAlgorithmName=t,this.digestLength=s,e){case 1024:this.dh=(0,n.getDiffieHellman)("modp2");break;case 2048:this.dh=(0,n.getDiffieHellman)("modp14");break;case 4096:this.dh=(0,n.getDiffieHellman)("modp16");break;default:throw new Error("Invalid DH bit length.")}}startKeyExchange(){const e=this.dh.generateKeys(),t=a.BigInt.fromBytes(e,{unsigned:!0}).toBytes();return Promise.resolve(t)}decryptKeyExchange(e){const t=this.dh.computeSecret(e),s=a.BigInt.fromBytes(t,{unsigned:!0}).toBytes();return Promise.resolve(s)}async sign(e){const t=await crypto.subtle.digest(this.hashAlgorithmName,e);return i.Buffer.from(t)}dispose(){}}class u extends r.KeyExchangeAlgorithm{constructor(e,t,s){super(e,t,s,o.WebHmac.getHashDigestLength(s))}createKeyExchange(){return new d(this.keySizeInBits,o.WebHmac.getWebHashAlgorithmName(this.hashAlgorithmName),this.hashDigestLength)}}t.WebECDiffieHellman=u;class d{constructor(e,t,s){this.bitLength=e,this.hashAlgorithmName=t,this.digestLength=s,this.algorithm={name:"ECDH",namedCurve:"P-"+e}}async startKeyExchange(){this.keyPair||(this.keyPair=await crypto.subtle.generateKey(this.algorithm,!0,["deriveBits"]));const e=await crypto.subtle.exportKey("jwk",this.keyPair.publicKey),t=c.JsonWebKeyFormatter.parseEC(e),s=Math.ceil(this.bitLength/8),n=i.Buffer.alloc(1+2*s);return n[0]=4,t.x.toBytes({unsigned:!0,length:s}).copy(n,1),t.y.toBytes({unsigned:!0,length:s}).copy(n,1+s),i.Buffer.from(n)}async decryptKeyExchange(e){if(!this.keyPair)throw new Error("Key exchange not started.");const t=e,s=c.JsonWebKeyFormatter.formatEC({curve:{name:this.algorithm.namedCurve},x:a.BigInt.fromBytes(t.slice(1,1+(t.length-1)/2),{unsigned:!0}),y:a.BigInt.fromBytes(t.slice(1+(t.length-1)/2),{unsigned:!0})}),n=await crypto.subtle.importKey("jwk",s,this.algorithm,!1,[]),r=i.Buffer.from(await crypto.subtle.deriveBits(Object.assign(Object.assign({},this.algorithm),{public:n}),this.keyPair.privateKey,8*Math.ceil(this.bitLength/8)));return a.BigInt.fromBytes(r,{unsigned:!0}).toBytes()}async sign(e){const t=await crypto.subtle.digest(this.hashAlgorithmName,e);return i.Buffer.from(t)}dispose(){}}},1685:(e,t)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.WebRandom=void 0,t.WebRandom=class{getBytes(e){crypto.getRandomValues(e)}}},2001:(e,t,s)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.WebRsa=void 0;const i=s(4300),n=s(9009),r=s(5914),o=s(7914),a=s(453);class c{constructor(e){this.hashAlgorithm=e,this.comment=null}get hasPublicKey(){return!!this.publicKey}get hasPrivateKey(){return!!this.privateKey}get keyAlgorithmName(){return h.keyAlgorithmName}async generate(e){e=null!=e?e:c.defaultKeySize;try{const t={name:"RSASSA-PKCS1-v1_5",modulusLength:e,publicExponent:new Uint8Array([1,0,1]),hash:{name:this.hashAlgorithm}},s=await crypto.subtle.generateKey(t,!0,["sign","verify"]);this.publicKey=s.publicKey,this.privateKey=s.privateKey}catch(e){throw new Error("Failed to generate RSA key pair: "+e)}}async setPublicKeyBytes(e){if(!e)throw new TypeError("Buffer is required.");const t=new o.SshDataReader(e),s=t.readString("ascii");if(s!==this.keyAlgorithmName&&s!==h.rsaWithSha256&&s!==h.rsaWithSha512)throw new Error(`Invalid RSA key algorithm: ${s}`);const i=t.readBigInt(),n=t.readBigInt(),r=a.JsonWebKeyFormatter.formatRsa({modulus:n,exponent:i},!1);r.alg="RS"+this.hashAlgorithm.replace("SHA-",""),r.key_ops=["verify"];try{const e={name:"RSASSA-PKCS1-v1_5",hash:{name:this.hashAlgorithm}};this.publicKey=await crypto.subtle.importKey("jwk",r,e,!0,["verify"])}catch(e){throw new Error("Failed to import RSA public key: "+e)}}async getPublicKeyBytes(e){if(!this.publicKey)return null;let t;e||(e=this.keyAlgorithmName);try{t=await crypto.subtle.exportKey("jwk",this.publicKey)}catch(e){throw new Error("Failed to export RSA public key: "+e)}const{modulus:s,exponent:n}=a.JsonWebKeyFormatter.parseRsa(t,!1),r=i.Buffer.alloc(512),c=new o.SshDataWriter(r);return c.writeString(e,"ascii"),c.writeBigInt(n),c.writeBigInt(s),c.toBuffer()}async importParameters(e){const t=e.d?a.JsonWebKeyFormatter.formatRsa(e,!0):null,s=a.JsonWebKeyFormatter.formatRsa(e,!1),i={name:"RSASSA-PKCS1-v1_5",hash:{name:this.hashAlgorithm}};try{this.publicKey=await crypto.subtle.importKey("jwk",s,i,!0,["verify"]),this.privateKey=t?await crypto.subtle.importKey("jwk",t,i,!0,["sign"]):void 0}catch(e){if(!(e instanceof Error))throw e;throw new Error("Failed to import RSA key pair: "+e.message)}}async exportParameters(){var e;if(!this.publicKey)throw new Error("Public key not set.");let t;try{t=await crypto.subtle.exportKey("jwk",null!==(e=this.privateKey)&&void 0!==e?e:this.publicKey)}catch(e){if(!(e instanceof Error))throw e;throw new Error("Failed to export RSA public key: "+e.message)}return a.JsonWebKeyFormatter.parseRsa(t,!!this.privateKey)}dispose(){}}c.defaultKeySize=2048;class h extends n.PublicKeyAlgorithm{constructor(e,t){super(e,h.keyAlgorithmName,t)}createKeyPair(){const e=h.convertHashAlgorithmName(this.hashAlgorithmName);return new c(e)}async generateKeyPair(e){const t=h.convertHashAlgorithmName(this.hashAlgorithmName),s=new c(t);return await s.generate(e),s}createSigner(e){if(!(e instanceof c))throw new TypeError("RSA key pair object expected.");const t=h.convertHashAlgorithmName(this.hashAlgorithmName);return new l(e,t,r.WebHmac.getHashDigestLength(this.hashAlgorithmName))}createVerifier(e){if(!(e instanceof c))throw new TypeError("RSA key pair object expected.");const t=h.convertHashAlgorithmName(this.hashAlgorithmName);return new l(e,t,r.WebHmac.getHashDigestLength(this.hashAlgorithmName))}static convertHashAlgorithmName(e){return e.replace("SHA2-","SHA-")}}t.WebRsa=h,h.keyAlgorithmName="ssh-rsa",h.rsaWithSha256="rsa-sha2-256",h.rsaWithSha512="rsa-sha2-512",h.KeyPair=c;class l{constructor(e,t,s){this.keyPair=e,this.hashAlgorithm=t,this.digestLength=s}async sign(e){if(!this.keyPair.privateKey)throw new Error("Private key not set.");return await this.convertKeyHashAlgorithm(),i.Buffer.from(await crypto.subtle.sign("RSASSA-PKCS1-v1_5",this.keyPair.privateKey,e))}async verify(e,t){if(!this.keyPair.publicKey)throw new Error("Public key not set.");return await this.convertKeyHashAlgorithm(),await crypto.subtle.verify("RSASSA-PKCS1-v1_5",this.keyPair.publicKey,t,e)}async convertKeyHashAlgorithm(){if(this.keyPair.hashAlgorithm!==this.hashAlgorithm){const e=await this.keyPair.exportParameters();this.keyPair=new c(this.hashAlgorithm),await this.keyPair.importParameters(e)}}dispose(){}}},2917:(e,t)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.ObjectDisposedError=t.SshChannelError=t.SshReconnectError=t.SshConnectionError=void 0;class s extends Error{constructor(e,t){super(e),this.reason=t}}t.SshConnectionError=s;class i extends Error{constructor(e,t){super(e),this.reason=t}}t.SshReconnectError=i;class n extends Error{constructor(e,t){super(e),this.reason=t}}t.SshChannelError=n;class r extends Error{constructor(e){var t,s;let i;i="string"==typeof e?e:"function"==typeof e?e.name+" disposed.":(null!==(s=null===(t=null==e?void 0:e.constructor)||void 0===t?void 0:t.name)&&void 0!==s?s:"Object ")+" disposed.",super(i)}}t.ObjectDisposedError=r},8047:(e,t,s)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.SshAuthenticatingEventArgs=t.SshAuthenticationType=void 0;const i=s(3730);var n;!function(e){e[e.clientNone=0]="clientNone",e[e.clientHostBased=1]="clientHostBased",e[e.clientPassword=2]="clientPassword",e[e.clientPublicKeyQuery=3]="clientPublicKeyQuery",e[e.clientPublicKey=4]="clientPublicKey",e[e.serverPublicKey=10]="serverPublicKey"}(n=t.SshAuthenticationType||(t.SshAuthenticationType={})),t.SshAuthenticatingEventArgs=class{constructor(e,{username:t,password:s,publicKey:r,clientHostname:o,clientUsername:a},c){this.authenticationType=e;const h=({usernameRequired:e,passwordRequired:i,publicKeyRequired:n,clientHostnameRequired:c,clientUsernameRequired:h})=>"string"==typeof t==!!e&&"string"==typeof s==!!i&&!!r==!!n&&"string"==typeof o==!!c&&"string"==typeof a==!!h;let l;switch(e){case n.clientNone:l=h({usernameRequired:!0});break;case n.clientHostBased:l=h({usernameRequired:!0,publicKeyRequired:!0,clientHostnameRequired:!0,clientUsernameRequired:!0});break;case n.clientPassword:l=h({usernameRequired:!0,passwordRequired:!0});break;case n.clientPublicKeyQuery:case n.clientPublicKey:l=h({usernameRequired:!0,publicKeyRequired:!0});break;case n.serverPublicKey:l=h({publicKeyRequired:!0});break;default:throw new Error(`Invalid authentication type: ${e}`)}if(!l)throw new Error(`Invalid arguments for authentication type: ${e}`);this.username=null!=t?t:null,this.password=null!=s?s:null,this.publicKey=null!=r?r:null,this.clientHostname=null!=o?o:null,this.clientUsername=null!=a?a:null,this.cancellationValue=null!=c?c:i.CancellationToken.None}get cancellation(){return this.cancellationValue}set cancellation(e){this.cancellationValue=e}toString(){return this.password?(this.username?'"'+this.username+'" ':"")+"[password]":this.publicKey?`${this.username?'"'+this.username+'" ':""}[${this.publicKey.keyAlgorithmName}]`:`"${this.username}"`}}},3229:(e,t)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.SshChannelClosedEventArgs=void 0,t.SshChannelClosedEventArgs=class{constructor(e,t){"number"==typeof e?this.exitStatus=e:"string"==typeof e?(this.exitSignal=e,this.errorMessage=t):e instanceof Error&&(this.error=e)}}},6442:(e,t,s)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.SshChannelOpeningEventArgs=void 0;const i=s(5757),n=s(3730);t.SshChannelOpeningEventArgs=class{constructor(e,t,s,r){if(this.request=e,this.channel=t,this.isRemoteRequest=s,this.failureReason=i.SshChannelOpenFailureReason.none,this.failureDescription=null,!e)throw new TypeError("A channel open message is required.");if(!t)throw new TypeError("A channel is required.");this.cancellationValue=null!=r?r:n.CancellationToken.None}get cancellation(){return this.cancellationValue}set cancellation(e){this.cancellationValue=e}toString(){return`${this.channel.toString()}${this.failureReason?" "+i.SshChannelOpenFailureReason[this.failureReason]:""}`}}},6002:(e,t,s)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.SshRequestEventArgs=void 0;const i=s(3730);t.SshRequestEventArgs=class{constructor(e,t,s,n){this.requestType=e,this.request=t,this.principal=s,this.cancellationValue=null!=n?n:i.CancellationToken.None}get cancellation(){return this.cancellationValue}set cancellation(e){this.cancellationValue=e}toString(){return`RequestType: ${this.requestType}`+this.request?` Request: ${this.request}`:""}}},3068:(e,t,s)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.SshSessionClosedEventArgs=void 0;const i=s(818);t.SshSessionClosedEventArgs=class{constructor(e,t,s){if(this.reason=e,this.message=t,this.error=s,!t)throw new TypeError("A disconnect message is required.")}toString(){return`${i.SshDisconnectReason[this.reason]}: ${this.message}`}}},2126:(e,t,s)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.ObjectDisposedError=t.SshReconnectError=t.SshConnectionError=t.SshChannelError=t.BigInt=t.DerWriter=t.DerReader=t.formatBuffer=t.SshDataWriter=t.SshDataReader=t.ECDsa=t.Rsa=t.Encryption=t.HmacAlgorithm=t.EncryptionAlgorithm=t.PublicKeyAlgorithm=t.KeyExchangeAlgorithm=t.SshAlgorithms=t.CommandRequestMessage=t.ChannelRequestType=t.ChannelRequestMessage=t.ChannelOpenMessage=t.SshChannelOpenFailureReason=t.SshReconnectFailureReason=t.SshDisconnectReason=t.SessionRequestFailureMessage=t.SessionRequestSuccessMessage=t.DebugMessage=t.SessionRequestMessage=t.SshMessage=t.SshChannelClosedEventArgs=t.SshSessionClosedEventArgs=t.SshChannelOpeningEventArgs=t.SshRequestEventArgs=t.SshAuthenticatingEventArgs=t.SshAuthenticationType=t.serviceActivation=t.SshService=t.SshRpcMessageStream=t.WebSocketStream=t.NodeStream=t.BaseStream=t.SshStream=t.SshChannel=t.SshServerSession=t.SshClientSession=t.SshSession=t.SshVersionInfo=t.SshProtocolExtensionNames=t.SshSessionConfiguration=void 0,t.SshTraceEventIds=t.TraceLevel=t.MultiChannelStream=t.SessionContour=t.ChannelMetrics=t.SessionMetrics=t.Queue=t.Semaphore=t.PromiseCompletionSource=t.CancellationError=t.CancellationTokenSource=t.CancellationToken=void 0;var i=s(7183);Object.defineProperty(t,"SshSessionConfiguration",{enumerable:!0,get:function(){return i.SshSessionConfiguration}}),Object.defineProperty(t,"SshProtocolExtensionNames",{enumerable:!0,get:function(){return i.SshProtocolExtensionNames}});var n=s(7505);Object.defineProperty(t,"SshVersionInfo",{enumerable:!0,get:function(){return n.SshVersionInfo}});var r=s(7395);Object.defineProperty(t,"SshSession",{enumerable:!0,get:function(){return r.SshSession}});var o=s(1485);Object.defineProperty(t,"SshClientSession",{enumerable:!0,get:function(){return o.SshClientSession}});var a=s(1410);Object.defineProperty(t,"SshServerSession",{enumerable:!0,get:function(){return a.SshServerSession}});var c=s(4756);Object.defineProperty(t,"SshChannel",{enumerable:!0,get:function(){return c.SshChannel}});var h=s(2656);Object.defineProperty(t,"SshStream",{enumerable:!0,get:function(){return h.SshStream}});var l=s(569);Object.defineProperty(t,"BaseStream",{enumerable:!0,get:function(){return l.BaseStream}}),Object.defineProperty(t,"NodeStream",{enumerable:!0,get:function(){return l.NodeStream}}),Object.defineProperty(t,"WebSocketStream",{enumerable:!0,get:function(){return l.WebSocketStream}});var u=s(6521);Object.defineProperty(t,"SshRpcMessageStream",{enumerable:!0,get:function(){return u.SshRpcMessageStream}});var d=s(447);Object.defineProperty(t,"SshService",{enumerable:!0,get:function(){return d.SshService}});var p=s(4670);Object.defineProperty(t,"serviceActivation",{enumerable:!0,get:function(){return p.serviceActivation}});var f=s(8047);Object.defineProperty(t,"SshAuthenticationType",{enumerable:!0,get:function(){return f.SshAuthenticationType}}),Object.defineProperty(t,"SshAuthenticatingEventArgs",{enumerable:!0,get:function(){return f.SshAuthenticatingEventArgs}});var g=s(6002);Object.defineProperty(t,"SshRequestEventArgs",{enumerable:!0,get:function(){return g.SshRequestEventArgs}});var m=s(6442);Object.defineProperty(t,"SshChannelOpeningEventArgs",{enumerable:!0,get:function(){return m.SshChannelOpeningEventArgs}});var y=s(3068);Object.defineProperty(t,"SshSessionClosedEventArgs",{enumerable:!0,get:function(){return y.SshSessionClosedEventArgs}});var v=s(3229);Object.defineProperty(t,"SshChannelClosedEventArgs",{enumerable:!0,get:function(){return v.SshChannelClosedEventArgs}});var w=s(285);Object.defineProperty(t,"SshMessage",{enumerable:!0,get:function(){return w.SshMessage}});var S=s(818);Object.defineProperty(t,"SessionRequestMessage",{enumerable:!0,get:function(){return S.SessionRequestMessage}}),Object.defineProperty(t,"DebugMessage",{enumerable:!0,get:function(){return S.DebugMessage}}),Object.defineProperty(t,"SessionRequestSuccessMessage",{enumerable:!0,get:function(){return S.SessionRequestSuccessMessage}}),Object.defineProperty(t,"SessionRequestFailureMessage",{enumerable:!0,get:function(){return S.SessionRequestFailureMessage}}),Object.defineProperty(t,"SshDisconnectReason",{enumerable:!0,get:function(){return S.SshDisconnectReason}}),Object.defineProperty(t,"SshReconnectFailureReason",{enumerable:!0,get:function(){return S.SshReconnectFailureReason}});var b=s(5757);Object.defineProperty(t,"SshChannelOpenFailureReason",{enumerable:!0,get:function(){return b.SshChannelOpenFailureReason}}),Object.defineProperty(t,"ChannelOpenMessage",{enumerable:!0,get:function(){return b.ChannelOpenMessage}}),Object.defineProperty(t,"ChannelRequestMessage",{enumerable:!0,get:function(){return b.ChannelRequestMessage}}),Object.defineProperty(t,"ChannelRequestType",{enumerable:!0,get:function(){return b.ChannelRequestType}}),Object.defineProperty(t,"CommandRequestMessage",{enumerable:!0,get:function(){return b.CommandRequestMessage}});var E=s(1605);Object.defineProperty(t,"SshAlgorithms",{enumerable:!0,get:function(){return E.SshAlgorithms}}),Object.defineProperty(t,"KeyExchangeAlgorithm",{enumerable:!0,get:function(){return E.KeyExchangeAlgorithm}}),Object.defineProperty(t,"PublicKeyAlgorithm",{enumerable:!0,get:function(){return E.PublicKeyAlgorithm}}),Object.defineProperty(t,"EncryptionAlgorithm",{enumerable:!0,get:function(){return E.EncryptionAlgorithm}}),Object.defineProperty(t,"HmacAlgorithm",{enumerable:!0,get:function(){return E.HmacAlgorithm}}),Object.defineProperty(t,"Encryption",{enumerable:!0,get:function(){return E.Encryption}}),Object.defineProperty(t,"Rsa",{enumerable:!0,get:function(){return E.Rsa}}),Object.defineProperty(t,"ECDsa",{enumerable:!0,get:function(){return E.ECDsa}});var C=s(7914);Object.defineProperty(t,"SshDataReader",{enumerable:!0,get:function(){return C.SshDataReader}}),Object.defineProperty(t,"SshDataWriter",{enumerable:!0,get:function(){return C.SshDataWriter}}),Object.defineProperty(t,"formatBuffer",{enumerable:!0,get:function(){return C.formatBuffer}});var R=s(5875);Object.defineProperty(t,"DerReader",{enumerable:!0,get:function(){return R.DerReader}}),Object.defineProperty(t,"DerWriter",{enumerable:!0,get:function(){return R.DerWriter}});var P=s(404);Object.defineProperty(t,"BigInt",{enumerable:!0,get:function(){return P.BigInt}});var T=s(2917);Object.defineProperty(t,"SshChannelError",{enumerable:!0,get:function(){return T.SshChannelError}}),Object.defineProperty(t,"SshConnectionError",{enumerable:!0,get:function(){return T.SshConnectionError}}),Object.defineProperty(t,"SshReconnectError",{enumerable:!0,get:function(){return T.SshReconnectError}}),Object.defineProperty(t,"ObjectDisposedError",{enumerable:!0,get:function(){return T.ObjectDisposedError}});var k=s(7437);Object.defineProperty(t,"CancellationToken",{enumerable:!0,get:function(){return k.CancellationToken}}),Object.defineProperty(t,"CancellationTokenSource",{enumerable:!0,get:function(){return k.CancellationTokenSource}}),Object.defineProperty(t,"CancellationError",{enumerable:!0,get:function(){return k.CancellationError}});var x=s(3708);Object.defineProperty(t,"PromiseCompletionSource",{enumerable:!0,get:function(){return x.PromiseCompletionSource}});var A=s(4564);Object.defineProperty(t,"Semaphore",{enumerable:!0,get:function(){return A.Semaphore}});var M=s(8776);Object.defineProperty(t,"Queue",{enumerable:!0,get:function(){return M.Queue}});var B=s(3965);Object.defineProperty(t,"SessionMetrics",{enumerable:!0,get:function(){return B.SessionMetrics}});var I=s(5321);Object.defineProperty(t,"ChannelMetrics",{enumerable:!0,get:function(){return I.ChannelMetrics}});var _=s(419);Object.defineProperty(t,"SessionContour",{enumerable:!0,get:function(){return _.SessionContour}});var O=s(9802);Object.defineProperty(t,"MultiChannelStream",{enumerable:!0,get:function(){return O.MultiChannelStream}});var q=s(3776);Object.defineProperty(t,"TraceLevel",{enumerable:!0,get:function(){return q.TraceLevel}}),Object.defineProperty(t,"SshTraceEventIds",{enumerable:!0,get:function(){return q.SshTraceEventIds}})},404:(e,t,s)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.BigInt=void 0;const i=s(4300),n=s(7914);class r{constructor(e){if(this.buffer=e,0===e.length)throw new Error("BigInt buffer length must be greater than zero.")}get sign(){const e=this.buffer[0];return 0===e?this.buffer.length>1?1:0:0==(128&e)?1:-1}static fromInt32(e){if(0===e)return r.zero;let t=!1;e<0&&(t=!0,e=-e);const s=[];for(let t=24;t>=0;t-=8)(e>=1<<t||s.length>0)&&(s.push(e>>t),e&=~((1<<t)-1));return t&&(0==(128&s[0])?s[0]|=128:s.splice(0,0,128)),new r(i.Buffer.from(new Uint8Array(s)))}toInt32(){if(this.buffer.length>4)throw new TypeError("BigInt value cannot be converted to a 32-bit signed integer.");let e=this.buffer[0];this.sign<0&&(e&=127);for(let t=1;t<this.buffer.length;t++)e=(e<<8)+this.buffer[t];return this.sign<0&&(e=-e),e}static fromBytes(e,t){if(!i.Buffer.isBuffer(e))throw new TypeError("Buffer expected.");if(0===e.length)throw new Error("BigInt buffer length must be greater than zero.");t=null!=t?t:{};const s=0!=(128&e[0]),n=t.unsigned&&s?1:0;let o=0;for(let t=0;t<e.length-1&&0===e[t];t++)0==(128&e[t+1])&&o++;const a=i.Buffer.alloc(e.length+n-o);return e.copy(a,n,o,e.length),new r(a)}toBytes(e){e=null!=e?e:{};let t=this.buffer;if(e.unsigned){if(this.sign<0)throw new TypeError("Cannot format a negative BigInt as unsigned.");if(0===t[0]&&t.length>1&&(t=t.slice(1,t.length)),void 0!==e.length){if(t.length>e.length)throw new Error(`BigInt (${t.length} bytes) is too large for length ${e.length}.`);if(t.length<e.length){const s=i.Buffer.alloc(e.length);return t.copy(s,e.length-t.length),s}}}const s=i.Buffer.alloc(t.length);return t.copy(s,0,0,t.length),s}copyTo(e,t=0){this.buffer.copy(e,t,0,this.buffer.length)}equals(e){return e instanceof r&&this.buffer.equals(e.buffer)}toString(e){return(0,n.formatBuffer)(this.buffer,null!=e?e:"BigInt")}}t.BigInt=r,r.zero=new r(i.Buffer.alloc(1))},5875:(e,t,s)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.DerWriter=t.DerReader=void 0;const i=s(4300),n=s(404);class r{constructor(e,t=48){this.buffer=e,this.position=0,this.readType(t);const s=this.readLength();if(s>this.buffer.length-this.position)throw new Error("Read out of bounds.");this.buffer=this.buffer.slice(0,this.position+s)}get available(){return this.buffer.length-this.position}readNull(){if(this.readType(5),0!==this.readByte())throw new Error("Expected a 0 after Null type.")}readInteger(){this.readType(2);const e=this.readLength(),t=this.readBytes(e);return new n.BigInt(t)}readOctetString(){this.readType(4);const e=this.readLength();return this.readBytes(e)}readBitString(){this.readType(3);const e=this.readLength();if(0!==this.readByte())throw new Error("Padded bit strings are not supported.");return this.readBytes(e-1)}readObjectIdentifier(e){this.readType(6);const t=this.readLength(),s=this.position+t,i=[],n=this.readByte();i.push(Math.trunc(n/40)),i.push(n%40);let r=0;for(;this.position<s;){const e=this.readByte();0!=(128&e)?r=128*r+(127&e):(r=128*r+e,i.push(r),r=0)}if(0!==r)throw new Error("Invalid OID format.");const o=i.join(".");if(e&&o!==e)throw new Error(`Expected OID ${e}, found: ${o}`);return o}readSequence(){const e=this.position;this.readType(48);const t=this.readLength();return this.position+=t,new r(this.buffer.slice(e,this.position))}tryReadTagged(e){if(this.position>=this.buffer.length)return null;const t=this.buffer[this.position];if(0==(160&t)||(-161&t)!==e)return null;const s=this.position;this.position++;const i=this.readLength();return this.position+=i,new r(this.buffer.slice(s,this.position),t)}peek(){if(this.position>=this.buffer.length)throw new Error("Read out of bounds.");return this.buffer[this.position]}readLength(){let e=this.readByte();if(128===e)throw new Error("Indefinite-length encoding is not supported.");if(e>127){const t=127&e;if(t>4)throw new Error(`DER length size is ${t} and cannot be more than 4 bytes.`);e=0;for(let s=0;s<t;s++)e=(e<<8)+this.readByte();if(e<0)throw new Error("Corrupted data - negative length found")}return e}readByte(){if(this.position>=this.buffer.length)throw new Error("Read out of bounds.");return this.buffer[this.position++]}readBytes(e){if(this.position+e>this.buffer.length)throw new Error("Read out of bounds.");const t=this.buffer.slice(this.position,this.position+e);return this.position+=e,t}readType(e){const t=this.readByte();if(t!==e)throw new Error(`Expected ${e} data type, found : ${t}`)}}t.DerReader=r;class o{constructor(e,t=48){this.buffer=e,this.dataType=t,this.position=0,this.buffer=e}toBuffer(){const e=this.position,t=o.getLength(e);this.ensureCapacity(1+t.length+e);const s=this.buffer.slice(0,1+t.length+e);return this.buffer.copy(s,1+t.length),s[0]=this.dataType,t.copy(s,1,0),this.buffer=this.buffer.slice(1+t.length,s.length),this.position=e,s}writeSequence(e){this.writeBytes(e.toBuffer())}writeTagged(e,t){if(e>15)throw new Error("Invalid DER tag.");this.writeByte(160|e);const s=o.getLength(t.position);this.writeBytes(s),this.writeBytes(t.buffer.slice(0,t.position))}writeNull(){this.writeByte(5),this.writeByte(0)}writeInteger(e){this.writeByte(2);const t=e.toBytes(),s=o.getLength(t.length);this.writeBytes(s),this.writeBytes(t)}writeOctetString(e){this.writeByte(4);const t=o.getLength(e.length);this.writeBytes(t),this.writeBytes(e)}writeBitString(e){this.writeByte(3);const t=o.getLength(1+e.length);this.writeBytes(t),this.writeByte(0),this.writeBytes(e)}writeObjectIdentifier(e){if(!e)throw new TypeError("OID value is null or empty.");const t=e.split(".").map(Number);if(t.length<2||t[0]>3||t[1]>=40)throw new Error(`Invalid OID: ${e}`);this.writeByte(6);let s=t.length-1;for(let e=2;e<t.length;e++){let i=t[e];for(;i>128;)s++,i/=128}const i=o.getLength(s);this.writeBytes(i),this.writeByte(40*t[0]+t[1]);for(let e=2;e<t.length;e++){let s=t[e];if(s>=128){let e=[];for(e.push(127&s);s>=128;)s/=128,e.push(128|127&s);for(;e.length>0;)this.writeByte(e.pop())}else this.writeByte(s)}}static getLength(e){if(e>127){let t=1;for(let s=e>>8;0!==s;s>>=8)t++;const s=o.lengthBuffer.slice(0,t+1);s[0]=128|t;for(let i=8*(t-1),n=1;i>=0;i-=8,n++)s[n]=e>>i;return s}{const t=o.lengthBuffer.slice(0,1);return t[0]=e,t}}writeByte(e){this.ensureCapacity(this.position+1),this.buffer[this.position++]=e}writeBytes(e){this.ensureCapacity(this.position+e.length),e.copy(this.buffer,this.position),this.position+=e.length}ensureCapacity(e){if(this.buffer.length<e){let t=Math.max(512,2*this.buffer.length);for(;t<e;)t*=2;const s=i.Buffer.alloc(t);this.buffer.copy(s,0,0,this.position),this.buffer=s}}}t.DerWriter=o,o.lengthBuffer=i.Buffer.alloc(10)},7914:(e,t,s)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.formatBuffer=t.SshDataWriter=t.SshDataReader=void 0;const i=s(4300),n=s(1605),r=s(404);class o{constructor(e){this.buffer=e,this.position=0}get available(){return this.buffer.length-this.position}read(e){if(this.available<e)throw new Error("Attempted to read past end of buffer.");const t=this.buffer.slice(this.position,this.position+e);return this.position+=e,t}readByte(){if(0===this.available)throw new Error("Attempted to read past end of buffer.");const e=this.buffer[this.position];return this.position++,e}readBinary(){const e=this.readUInt32();if(this.available<e)throw new Error("Attempted to read past end of buffer.");const t=this.buffer.slice(this.position,this.position+e);return this.position+=e,t}readString(e){return this.readBinary().toString()}readList(e){const t=this.readString(e);return 0===t.length?[]:t.split(",")}readBoolean(){return 0!==this.readByte()}readUInt32(){if(this.available<4)throw new Error("Attempted to read past end of buffer.");const e=this.buffer[this.position+0],t=this.buffer[this.position+1],s=this.buffer[this.position+2],i=this.buffer[this.position+3];return this.position+=4,(e<<24|t<<16|s<<8|i)>>>0}readUInt64(){if(this.available<8)throw new Error("Attempted to read past end of buffer.");const e=this.buffer[this.position+0],t=this.buffer[this.position+1],s=this.buffer[this.position+2],i=this.buffer[this.position+3],n=this.buffer[this.position+4],r=this.buffer[this.position+5],o=this.buffer[this.position+6],a=this.buffer[this.position+7];return this.position+=8,4294967296*((e<<24|t<<16|s<<8|i)>>>0)+((n<<24|r<<16|o<<8|a)>>>0)}readBigInt(){const e=this.readBinary();return 0===e.length?r.BigInt.zero:r.BigInt.fromBytes(e)}}let a;t.SshDataReader=o,o.mpintZero=i.Buffer.alloc(1),t.SshDataWriter=class{constructor(e){this.buffer=e,this.position=0}write(e){this.ensureCapacity(this.position+e.length),e.copy(this.buffer,this.position),this.position+=e.length}writeByte(e){this.ensureCapacity(this.position+1),this.buffer[this.position]=e,this.position++}writeBinary(e){this.ensureCapacity(this.position+4+e.length),this.writeUInt32(e.length),e.copy(this.buffer,this.position),this.position+=e.length}writeString(e,t){this.writeBinary(i.Buffer.from(e))}writeList(e,t){this.writeString(e?e.join(","):"",t)}writeBoolean(e){this.writeByte(e?1:0)}writeUInt32(e){this.ensureCapacity(this.position+4),this.buffer[this.position+0]=e>>>24,this.buffer[this.position+1]=e>>>16,this.buffer[this.position+2]=e>>>8,this.buffer[this.position+3]=e>>>0,this.position+=4}static writeUInt32(e,t,s){e[t+0]=s>>>24,e[t+1]=s>>>16,e[t+2]=s>>>8,e[t+3]=s>>>0}writeUInt64(e){this.ensureCapacity(this.position+8);const t=4294967295&e,s=(e-t)/4294967296;this.buffer[this.position+0]=s>>>24,this.buffer[this.position+1]=s>>>16,this.buffer[this.position+2]=s>>>8,this.buffer[this.position+3]=s>>>0,this.buffer[this.position+4]=t>>>24,this.buffer[this.position+5]=t>>>16,this.buffer[this.position+6]=t>>>8,this.buffer[this.position+7]=t>>>0,this.position+=8}writeBigInt(e){const t=e.toBytes();1===t.length&&0===t[0]?this.writeUInt32(0):this.writeBinary(t)}writeRandom(e){this.ensureCapacity(this.position+e);const t=this.buffer.slice(this.position,this.position+e);n.SshAlgorithms.random.getBytes(t),this.position+=e}skip(e){this.ensureCapacity(this.position+e),this.position+=e}ensureCapacity(e){if(this.buffer.length<e){let t=Math.max(512,2*this.buffer.length);for(;t<e;)t*=2;const s=i.Buffer.alloc(t);this.buffer.copy(s,0,0,this.position),this.buffer=s}}toBuffer(){return this.buffer.slice(0,this.position)}},t.formatBuffer=function(e,t,s){let i=`${void 0===t?"Buffer":t}[${e.length}] (${function(e){a||(a=function(){let e;const t=[];for(let s=0;s<256;s++){e=s;for(let t=0;t<8;t++)e=1&e?3988292384^e>>>1:e>>>1;t[s]=e}return t}());let t=-1;for(let s=0;s<e.length;s++)t=t>>>8^a[255&(t^e[s])];return(4294967296+((-1^t)>>>0)).toString(16).substr(-8).toUpperCase()}(e)})\n`;if(!1===s)return i;const n=Math.min(2048,e.length);for(let t=0;t<n;t+=16){t<1e3&&(i+="0"),t<100&&(i+="0"),t<10&&(i+="0"),i+=t+":";for(let s=t;s<t+16;s++)i+=s<n?" "+e.slice(s,s+1).toString("hex"):"   ";i+="  ";for(let s=t;s<t+16;s++)if(s<n){const t=e[s];i+=t>32&&t<=127?e.slice(s,s+1).toString():"."}else i+=" ";i+="\n"}return n<e.length&&(i+="...\n"),i}},7585:(e,t,s)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.SshProtocol=void 0;const i=s(4300),n=s(8776),r=s(4564),o=s(285),a=s(7914),c=s(818),h=s(856),l=s(5757),u=s(2917),d=s(3776);class p{constructor(e,t){this.sequence=e,this.message=t}}class f{constructor(e,t,s,o){this.config=t,this.metrics=s,this.trace=o,this.sessionSemaphore=new r.Semaphore(1),this.inboundPacketSequence=0,this.outboundPacketSequence=0,this.inboundFlow=0,this.outboundFlow=0,this.recentSentMessages=new n.Queue,this.sendWriter=new a.SshDataWriter(i.Buffer.alloc(1024)),this.receiveWriter=new a.SshDataWriter(i.Buffer.alloc(1024)),this.traceChannelData=!1,this.extensions=null,this.kexService=null,this.algorithms=null,this.outgoingMessagesHaveLatencyInfo=!1,this.incomingMessagesHaveLatencyInfo=!1,this.outgoingMessagesHaveReconnectInfo=!1,this.incomingMessagesHaveReconnectInfo=!1,this.stream=e}get lastIncomingSequence(){return this.inboundPacketSequence-1}getSentMessages(e){if(e===this.outboundPacketSequence+1)return[];if(this.recentSentMessages.size>0&&e<this.recentSentMessages.peek().sequence)return null;const t=new Array;for(let s of this.recentSentMessages)if(s.sequence>=e){const e=s.message;e instanceof h.KeyExchangeMessage||e instanceof c.DisconnectMessage||t.push(e)}return t}async writeProtocolVersion(e,t){const s=this.stream;if(!s)throw new Error("SSH session disconnected.");const n=i.Buffer.from(e+"\r\n");return await s.write(n,t),this.metrics.addMessageSent(n.length),Promise.resolve()}async readProtocolVersion(e){const t=this.stream;if(!t)throw new Error("SSH session disconnected.");const s=i.Buffer.alloc(255);let n=0;for(let i=0;i<s.length;i++){const r=await t.read(1,e);if(!r)break;s[i]=r[0];const o=13,a=10;if(i>0&&s[i-1]===o&&s[i]===a){const e=s.toString("utf8",0,i-1);if(e.startsWith("SSH-"))return this.metrics.addMessageReceived(i+1),e;if(n>20)break;n++,i=-1}}throw new u.SshConnectionError("Failed to read the protocol version",c.SshDisconnectReason.protocolError)}async handleNewKeys(e){try{await this.sessionSemaphore.wait(e),this.inboundFlow=0,this.outboundFlow=0,this.algorithms=this.kexService.finishKeyExchange()}finally{this.sessionSemaphore.release()}}async read(e,t){const s=this.stream;if(!s)return!1;let i=0;do{let n;try{n=await s.read(e.length-i,t)}catch(e){if(!(e instanceof Error))throw e;if(s.isDisposed)return!1;throw s.dispose(),this.stream=null,this.trace(d.TraceLevel.Error,d.SshTraceEventIds.streamReadError,`Error reading from stream: ${e.message}`,e),new u.SshConnectionError("Error reading from stream: "+e.message,c.SshDisconnectReason.connectionLost)}if(!n)return!1;n.copy(e,i),i+=n.length}while(i<e.length);return!0}async write(e,t){const s=this.stream;if(!s)return!1;try{await s.write(e,t)}catch(e){if(!(e instanceof Error))throw e;if(s.isDisposed)return!1;throw s.dispose(),this.stream=null,this.trace(d.TraceLevel.Error,d.SshTraceEventIds.streamWriteError,`Error writing to stream: ${e.message}`,e),new u.SshConnectionError("Error writing to stream: "+e.message,c.SshDisconnectReason.connectionLost)}return!0}async considerReExchange(e,t){const s=this.kexService;if(!s)return;let i=null,n=null;!s.exchanging&&(e||this.inboundFlow+this.outboundFlow>this.config.keyRotationThreshold)&&([i,n]=await s.startKeyExchange(e)),i&&(await this.sendMessage(i,t),n&&await this.sendMessage(n,t))}async computeHmac(e,t,s){const n=new a.SshDataWriter(i.Buffer.alloc(4+t.length));return n.writeUInt32(s),n.write(t),await e.sign(n.toBuffer())}async verifyHmac(e,t,s,n){const r=new a.SshDataWriter(i.Buffer.alloc(4+t.length));return r.writeUInt32(s),r.write(t),await e.verify(r.toBuffer(),n)}async readAndVerifyHmac(e,t,s,i){if(!await this.read(s,i))return!1;if(!await this.verifyHmac(e,t,this.inboundPacketSequence,s))throw new u.SshConnectionError("Invalid MAC",c.SshDisconnectReason.macError);return!0}async sendMessage(e,t){var s;const n=this.algorithms,r=null==n?void 0:n.compressor,o=null==n?void 0:n.cipher,a=null==n?void 0:n.messageSigner;let c;await this.sessionSemaphore.wait(t);try{const n=o?Math.max(8,o.blockLength):8,h=f.packetLengthSize+f.paddingLengthSize;if(this.sendWriter.position=h,e.write(this.sendWriter),this.outgoingMessagesHaveReconnectInfo&&(this.sendWriter.writeUInt64(this.lastIncomingSequence),this.outgoingMessagesHaveLatencyInfo)){const e=Math.min(4294967295,Math.round(1e3*(this.metrics.time-this.lastIncomingTimestamp)));this.sendWriter.writeUInt32(e)}let u=this.sendWriter.toBuffer().slice(h);null!=r&&(u=r.compress(u));let g=n-(((null==a?void 0:a.encryptThenMac)||(null==a?void 0:a.authenticatedEncryption)?0:f.packetLengthSize)+f.paddingLengthSize+u.length)%n;g<4&&(g+=n);const m=f.paddingLengthSize+u.length+g;this.sendWriter.position=0,this.sendWriter.writeUInt32(m),this.sendWriter.writeByte(g),null!=r?this.sendWriter.write(u):this.sendWriter.position+=u.length,this.sendWriter.writeRandom(g),u=this.sendWriter.toBuffer();let y=null;if((null==a?void 0:a.encryptThenMac)&&o){const e=u.slice(f.packetLengthSize,u.length);(await o.transform(e)).copy(e),y=await this.computeHmac(a,u,this.outboundPacketSequence)}else if(null==a?void 0:a.authenticatedEncryption){let e=u.slice(f.packetLengthSize,u.length);(await o.transform(e)).copy(e),y=await a.sign(e)}else a&&(y=await this.computeHmac(a,u,this.outboundPacketSequence)),o&&(u=await o.transform(u));if(e instanceof l.ChannelDataMessage?this.traceChannelData&&this.trace(d.TraceLevel.Verbose,d.SshTraceEventIds.sendingChannelData,`Sending #${this.outboundPacketSequence} ${e}`):this.trace(d.TraceLevel.Verbose,d.SshTraceEventIds.sendingMessage,`Sending #${this.outboundPacketSequence} ${e}`),this.incomingMessagesHaveReconnectInfo){const t=new p(this.outboundPacketSequence,e);t.sentTime=this.metrics.time,this.recentSentMessages.enqueue(t)}if(this.outboundPacketSequence++,this.outboundFlow+=m,y){const e=i.Buffer.concat([u,y],u.length+y.length);c=await this.write(e,t)}else c=await this.write(u,t);this.metrics.addMessageSent(f.packetLengthSize+m+(null!==(s=null==a?void 0:a.digestLength)&&void 0!==s?s:0))}finally{this.sessionSemaphore.release()}return await this.considerReExchange(!1,t),c}async receiveMessage(e){var t;const s=this.algorithms,i=null==s?void 0:s.decipher,n=null==s?void 0:s.messageVerifier,r=null==s?void 0:s.decompressor,h=!((null==n?void 0:n.encryptThenMac)||(null==n?void 0:n.authenticatedEncryption)),p=h?i?Math.max(8,i.blockLength):8:f.packetLengthSize;this.receiveWriter.position=p;let g=this.receiveWriter.toBuffer();if(!await this.read(g,e))return null;this.lastIncomingTimestamp=this.metrics.time,i&&h&&(g=await i.transform(g),this.receiveWriter.position=0,this.receiveWriter.write(g));const m=new a.SshDataReader(g).readUInt32();if(m>f.maxPacketLength)throw new u.SshConnectionError("Invalid packet length.",c.SshDisconnectReason.protocolError);const y=f.packetLengthSize+m;y>p&&this.receiveWriter.skip(y-p),n&&this.receiveWriter.skip(n.digestLength);const v=this.receiveWriter.toBuffer(),w=v.slice(0,y),S=v.slice(y);let b=w.slice(p,y);if(b.length>0){if(!await this.read(b,e))return null;if((null==n?void 0:n.encryptThenMac)&&!await this.readAndVerifyHmac(n,w,S,e))return null;if(i){if(null==n?void 0:n.authenticatedEncryption){if(!await this.read(S,e))return null;await n.verify(b,S)}try{b=await i.transform(b)}catch(e){throw(null==n?void 0:n.authenticatedEncryption)?new u.SshConnectionError("Invalid MAC",c.SshDisconnectReason.macError):e}this.receiveWriter.position=p,this.receiveWriter.write(b)}}if(n&&!n.encryptThenMac&&!n.authenticatedEncryption&&!await this.readAndVerifyHmac(n,w,S,e))return null;const E=w[f.packetLengthSize];let C=w.slice(f.packetLengthSize+f.paddingLengthSize,f.packetLengthSize+(m-E));if(r&&(C=r.decompress(C)),this.incomingMessagesHaveReconnectInfo){let e,t;if(this.incomingMessagesHaveLatencyInfo){const s=new a.SshDataReader(C.slice(C.length-12,C.length));e=s.readUInt64(),t=s.readUInt32()/1e3,C=C.slice(0,C.length-12)}else e=new a.SshDataReader(C.slice(C.length-8,C.length)).readUInt64(),t=0,C=C.slice(0,C.length-8);for(;this.recentSentMessages.size>0;){const s=this.recentSentMessages.peek();if(s.sequence>e)break;if(this.stream&&this.incomingMessagesHaveLatencyInfo&&s.sequence===e){const e=this.lastIncomingTimestamp-s.sentTime-t;this.metrics.updateLatency(e)}this.recentSentMessages.dequeue()}}const R=C[0];let P=o.SshMessage.create(this.config,R,C);if(!P){const e=new c.UnimplementedMessage;e.sequenceNumber=this.inboundPacketSequence,e.unimplementedMessageType=R,P=e}return P instanceof l.ChannelDataMessage?this.traceChannelData&&this.trace(d.TraceLevel.Verbose,d.SshTraceEventIds.receivingChannelData,`Receiving #${this.inboundPacketSequence} ${P}`):this.trace(d.TraceLevel.Verbose,d.SshTraceEventIds.receivingMessage,`Receiving #${this.inboundPacketSequence} ${P}`),await this.sessionSemaphore.wait(e),this.inboundPacketSequence++,this.inboundFlow+=m,this.sessionSemaphore.release(),this.metrics.addMessageReceived(f.packetLengthSize+m+(null!==(t=null==n?void 0:n.digestLength)&&void 0!==t?t:0)),await this.considerReExchange(!1,e),P}dispose(){try{this.stream&&this.stream.close().catch((e=>{this.trace(d.TraceLevel.Error,d.SshTraceEventIds.streamCloseError,`Error closing stream: ${e.message}`,e)}))}catch(e){if(!(e instanceof Error))throw e;this.trace(d.TraceLevel.Error,d.SshTraceEventIds.streamCloseError,`Error closing stream: ${e.message}`,e)}this.stream=null,this.metrics.updateLatency(0),this.algorithms&&this.algorithms.dispose()}}t.SshProtocol=f,f.maxPacketLength=1048576,f.packetLengthSize=4,f.paddingLengthSize=1},450:(e,t,s)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.AuthenticationSuccessMessage=t.AuthenticationFailureMessage=t.PasswordRequestMessage=t.PublicKeyOKMessage=t.PublicKeyRequestMessage=t.AuthenticationRequestMessage=t.AuthenticationMessage=void 0;const i=s(285);class n extends i.SshMessage{}t.AuthenticationMessage=n;class r extends n{get messageType(){return 50}onRead(e){this.username=e.readString("utf8"),this.serviceName=e.readString("ascii"),this.methodName=e.readString("ascii")}onWrite(e){e.writeString(this.username||"","utf8"),e.writeString(this.serviceName||"","ascii"),e.writeString(this.validateField(this.methodName,"method name"),"ascii")}}t.AuthenticationRequestMessage=r,t.PublicKeyRequestMessage=class extends r{constructor(){super(),this.methodName="publickey"}get hasSignature(){return!!(this.signature&&this.signature.length>0)}onRead(e){super.onRead(e);const t=e.readBoolean();this.keyAlgorithmName=e.readString("ascii"),this.publicKey=e.readBinary(),t?(this.signature=e.readBinary(),this.payloadWithoutSignature=this.rawBytes.slice(0,this.rawBytes.length-this.signature.length-4)):this.signature=void 0}onWrite(e){var t,s;if(super.onWrite(e),!this.keyAlgorithmName)throw new Error("Key algorithm name not set.");if("hostbased"===this.methodName){if(e.writeString(this.keyAlgorithmName,"ascii"),e.writeBinary(this.publicKey||Buffer.alloc(0)),e.writeString(null!==(t=this.clientHostname)&&void 0!==t?t:"","ascii"),e.writeString(null!==(s=this.clientUsername)&&void 0!==s?s:"","ascii"),!this.hasSignature)throw new Error("A signature is required for a host-based authentcation request.");e.writeBinary(this.signature)}else e.writeBoolean(this.hasSignature),e.writeString(this.keyAlgorithmName,"ascii"),e.writeBinary(this.publicKey||Buffer.alloc(0)),this.hasSignature&&e.writeBinary(this.signature)}},t.PublicKeyOKMessage=class extends n{get messageType(){return 60}onRead(e){this.keyAlgorithmName=e.readString("ascii"),this.publicKey=e.readBinary()}onWrite(e){if(!this.keyAlgorithmName)throw new Error("Key algorithm name not set.");if(!this.publicKey)throw new Error("Public key not set.");e.writeString(this.keyAlgorithmName,"ascii"),e.writeBinary(this.publicKey)}},t.PasswordRequestMessage=class extends r{constructor(){super(),this.methodName="password"}onRead(e){super.onRead(e),e.readBoolean(),this.password=e.readString("utf8")}onWrite(e){super.onWrite(e),e.writeBoolean(!1),e.writeString(this.password||"","utf8")}};class o extends n{constructor(){super(...arguments),this.partialSuccess=!1}get messageType(){return 51}onRead(e){this.methodNames=e.readList("ascii"),this.partialSuccess=e.readBoolean()}onWrite(e){e.writeList(this.methodNames||[],"ascii"),e.writeBoolean(this.partialSuccess)}}t.AuthenticationFailureMessage=o;class a extends n{get messageType(){return 52}onRead(e){}onWrite(e){}}t.AuthenticationSuccessMessage=a,i.SshMessage.index.set(50,r),i.SshMessage.index.set(51,o),i.SshMessage.index.set(52,a)},5757:(e,t,s)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.ChannelFailureMessage=t.ChannelSuccessMessage=t.ChannelSignalMessage=t.CommandRequestMessage=t.ChannelRequestMessage=t.ChannelRequestType=t.ChannelCloseMessage=t.ChannelEofMessage=t.ChannelDataMessage=t.ChannelWindowAdjustMessage=t.ChannelOpenFailureMessage=t.SshChannelOpenFailureReason=t.ChannelOpenConfirmationMessage=t.ChannelOpenMessage=t.ChannelMessage=t.ConnectionMessage=void 0;const i=s(285),n=s(7914);class r extends i.SshMessage{}t.ConnectionMessage=r;class o extends r{get recipientChannel(){return this.recipientChannelValue}set recipientChannel(e){e!==this.recipientChannelValue&&(this.recipientChannelValue=e,this.rawBytes&&n.SshDataWriter.writeUInt32(this.rawBytes,1,null!=e?e:0))}onRead(e){this.recipientChannel=e.readUInt32()}onWrite(e){e.writeUInt32(this.validateField(this.recipientChannel,"recipient channel"))}toString(){return`${super.toString()} (recipientChannel=${this.recipientChannel})`}}t.ChannelMessage=o;class a extends r{get messageType(){return 90}get senderChannel(){return this.senderChannelValue}set senderChannel(e){e!==this.senderChannelValue&&(this.senderChannelValue=e,this.rawBytes&&this.channelType&&n.SshDataWriter.writeUInt32(this.rawBytes,5+this.channelType.length,null!=e?e:0))}onRead(e){this.channelType=e.readString("ascii"),this.senderChannel=e.readUInt32(),this.initialWindowSize=e.readUInt32(),this.maximumPacketSize=e.readUInt32()}onWrite(e){e.writeString(this.validateField(this.channelType,"channel type"),"ascii"),e.writeUInt32(this.validateField(this.senderChannel,"sender channel")),e.writeUInt32(this.initialWindowSize||a.defaultInitialWindowSize),e.writeUInt32(this.maximumPacketSize||a.defaultMaximumPacketSize)}}t.ChannelOpenMessage=a,a.defaultInitialWindowSize=1048576,a.defaultMaximumPacketSize=16384;class c extends o{get messageType(){return 91}onRead(e){super.onRead(e),this.senderChannel=e.readUInt32(),this.initialWindowSize=e.readUInt32(),this.maximumPacketSize=e.readUInt32()}onWrite(e){super.onWrite(e),e.writeUInt32(this.validateField(this.senderChannel,"sender channel")),e.writeUInt32(this.validateField(this.initialWindowSize,"initial window size")),e.writeUInt32(this.validateField(this.maximumPacketSize,"max packet size"))}toString(){return`${super.toString()}(senderChannel=${this.senderChannel})`}}var h,l;t.ChannelOpenConfirmationMessage=c,function(e){e[e.none=0]="none",e[e.administrativelyProhibited=1]="administrativelyProhibited",e[e.connectFailed=2]="connectFailed",e[e.unknownChannelType=3]="unknownChannelType",e[e.resourceShortage=4]="resourceShortage"}(h=t.SshChannelOpenFailureReason||(t.SshChannelOpenFailureReason={}));class u extends o{get messageType(){return 92}onRead(e){super.onRead(e),this.reasonCode=e.readUInt32(),this.description=e.readString("utf8"),this.language=e.readString("ascii")}onWrite(e){super.onWrite(e),e.writeUInt32(this.validateField(this.reasonCode,"reason code")),e.writeString(this.description||"","utf8"),e.writeString(this.language||"en","ascii")}toString(){return`${super.toString()} (${h[this.reasonCode||0]}: ${this.description})`}}t.ChannelOpenFailureMessage=u;class d extends o{get messageType(){return 93}onRead(e){super.onRead(e),this.bytesToAdd=e.readUInt32()}onWrite(e){super.onWrite(e),e.writeUInt32(this.validateField(this.bytesToAdd,"bytes to add"))}toString(){return`${super.toString} (bytesToAdd=${this.bytesToAdd})`}}t.ChannelWindowAdjustMessage=d;class p extends o{get messageType(){return 94}onRead(e){super.onRead(e),this.data=e.readBinary()}onWrite(e){super.onWrite(e),e.writeBinary(this.validateField(this.data,"data"))}toString(){return this.data?(0,n.formatBuffer)(this.data,""):"[0]"}}t.ChannelDataMessage=p;class f extends o{get messageType(){return 96}}t.ChannelEofMessage=f;class g extends o{get messageType(){return 97}}t.ChannelCloseMessage=g,function(e){e.command="exec",e.shell="shell",e.terminal="pty-req",e.signal="signal",e.exitSignal="exit-signal",e.exitStatus="exit-status"}(l=t.ChannelRequestType||(t.ChannelRequestType={}));class m extends o{constructor(e,t){super(),this.requestType=e,this.wantReply=null!=t&&t}get messageType(){return 98}onRead(e){super.onRead(e),this.requestType=e.readString("ascii"),this.wantReply=e.readBoolean()}onWrite(e){void 0===this.recipientChannel&&(this.recipientChannel=0),super.onWrite(e),e.writeString(this.validateField(this.requestType,"request type"),"ascii"),e.writeBoolean(this.wantReply)}}t.ChannelRequestMessage=m,t.CommandRequestMessage=class extends m{constructor(){super(),this.requestType=l.command}onRead(e){super.onRead(e),this.command=e.readString("utf8")}onWrite(e){super.onWrite(e),e.writeString(this.validateField(this.command,"command"),"utf8")}toString(){return`${super.toString()} (requestType=${this.requestType})`}},t.ChannelSignalMessage=class extends m{constructor(){super()}get signal(){return this.signalValue}set signal(e){this.requestType=l.signal,this.signalValue=e}get exitSignal(){return this.signalValue}set exitSignal(e){this.requestType=l.exitSignal,this.signalValue=e}get errorMessage(){return this.errorMessageValue}set errorMessage(e){if(this.requestType!==l.exitSignal)throw new Error(`Error message property is only valid for ${l.exitSignal} messages.`);this.errorMessageValue=e}get exitStatus(){return this.statusValue}set exitStatus(e){this.requestType=l.exitStatus,this.statusValue=e}onRead(e){switch(super.onRead(e),this.requestType){case l.exitStatus:this.exitStatus=e.readUInt32();break;case l.signal:this.signal=e.readString("ascii");break;case l.exitSignal:this.exitSignal=e.readString("ascii"),e.readBoolean(),this.errorMessage=e.readString("utf8"),e.readString("ascii")}}onWrite(e){if(!this.requestType)throw new Error("Signal message request type not set.");switch(this.wantReply=!1,super.onWrite(e),this.requestType){case l.exitStatus:e.writeUInt32(this.validateField(this.exitStatus,"exit status"));break;case l.signal:e.writeString(this.validateField(this.signal,"signal"),"ascii");break;case l.exitSignal:e.writeString(this.validateField(this.exitSignal,"exit signal"),"ascii"),e.writeBoolean(!1),e.writeString(this.errorMessage||"","utf8"),e.writeString("","ascii");break;default:throw new Error(`Unknown signal message request type: ${this.requestType}`)}}};class y extends o{get messageType(){return 99}}t.ChannelSuccessMessage=y;class v extends o{get messageType(){return 100}}t.ChannelFailureMessage=v,i.SshMessage.index.set(90,a),i.SshMessage.index.set(91,c),i.SshMessage.index.set(92,u),i.SshMessage.index.set(93,d),i.SshMessage.index.set(94,p),i.SshMessage.index.set(96,f),i.SshMessage.index.set(97,g),i.SshMessage.index.set(98,m),i.SshMessage.index.set(99,y),i.SshMessage.index.set(100,v)},856:(e,t,s)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.NewKeysMessage=t.KeyExchangeDhReplyMessage=t.KeyExchangeDhInitMessage=t.KeyExchangeInitMessage=t.KeyExchangeMessage=void 0;const i=s(4300),n=s(285),r=s(1605);class o extends n.SshMessage{}t.KeyExchangeMessage=o;class a extends o{get messageType(){return 20}onRead(e){this.cookie=e.read(16),this.keyExchangeAlgorithms=e.readList("ascii"),this.serverHostKeyAlgorithms=e.readList("ascii"),this.encryptionAlgorithmsClientToServer=e.readList("ascii"),this.encryptionAlgorithmsServerToClient=e.readList("ascii"),this.macAlgorithmsClientToServer=e.readList("ascii"),this.macAlgorithmsServerToClient=e.readList("ascii"),this.compressionAlgorithmsClientToServer=e.readList("ascii"),this.compressionAlgorithmsServerToClient=e.readList("ascii"),this.languagesClientToServer=e.readList("ascii"),this.languagesServerToClient=e.readList("ascii"),this.firstKexPacketFollows=e.readBoolean(),this.reserved=e.readUInt32()}onWrite(e){this.cookie||(this.cookie=i.Buffer.alloc(16),r.SshAlgorithms.random.getBytes(this.cookie)),e.write(this.cookie),e.writeList(this.keyExchangeAlgorithms||[],"ascii"),e.writeList(this.serverHostKeyAlgorithms||[],"ascii"),e.writeList(this.encryptionAlgorithmsClientToServer||[],"ascii"),e.writeList(this.encryptionAlgorithmsServerToClient||[],"ascii"),e.writeList(this.macAlgorithmsClientToServer||[],"ascii"),e.writeList(this.macAlgorithmsServerToClient||[],"ascii"),e.writeList(this.compressionAlgorithmsClientToServer||[],"ascii"),e.writeList(this.compressionAlgorithmsServerToClient||[],"ascii"),e.writeList(this.languagesClientToServer||[],"ascii"),e.writeList(this.languagesServerToClient||[],"ascii"),e.writeBoolean(this.validateField(this.firstKexPacketFollows,"first KEX package follows")),e.writeUInt32(this.reserved||0)}}t.KeyExchangeInitMessage=a;class c extends o{get messageType(){return 30}onRead(e){this.e=e.readBinary()}onWrite(e){e.writeBinary(this.validateField(this.e,"E"))}}t.KeyExchangeDhInitMessage=c;class h extends o{get messageType(){return 31}onRead(e){this.hostKey=e.readBinary(),this.f=e.readBinary(),this.signature=e.readBinary()}onWrite(e){e.writeBinary(this.validateField(this.hostKey,"host key")),e.writeBinary(this.validateField(this.f,"F")),e.writeBinary(this.validateField(this.signature,"signature"))}}t.KeyExchangeDhReplyMessage=h;class l extends o{get messageType(){return 21}onRead(e){}onWrite(e){}}t.NewKeysMessage=l,n.SshMessage.index.set(20,a),n.SshMessage.index.set(30,c),n.SshMessage.index.set(31,h),n.SshMessage.index.set(21,l)},285:(e,t,s)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.SshMessage=void 0;const i=s(4300),n=s(7914);class r{get messageType(){return 0}toBuffer(){const e=new n.SshDataWriter(i.Buffer.alloc(16));return this.write(e),e.toBuffer()}read(e){this.rawBytes=e.buffer;const t=e.readByte();if(t!==this.messageType)throw new Error(`Message type ${t} is not valid.`);this.onRead(e)}write(e){this.rawBytes?e.write(this.rawBytes):(e.writeByte(this.messageType),this.onWrite(e))}onRead(e){throw new Error("Not supported.")}onWrite(e){throw new Error("Not supported.")}validateField(e,t){if(void 0===e)throw new Error(`${this.constructor.name} ${t} is required.`);return e}toString(){return this.constructor.name}static create(e,t,s){const i=e.messages.get(t);if(i){const e=new i;return e.read(new n.SshDataReader(s)),e}return null}convertTo(e,t=!1){const s=new n.SshDataReader(t?i.Buffer.from(this.rawBytes):this.rawBytes);return e.read(s),e}}t.SshMessage=r,r.index=new Map},818:(e,t,s)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.SessionReconnectFailureMessage=t.SshReconnectFailureReason=t.SessionReconnectResponseMessage=t.SessionReconnectRequestMessage=t.SessionChannelRequestMessage=t.ExtensionInfoMessage=t.SessionRequestFailureMessage=t.SessionRequestSuccessMessage=t.SessionRequestMessage=t.ServiceAcceptMessage=t.ServiceRequestMessage=t.DebugMessage=t.UnimplementedMessage=t.IgnoreMessage=t.DisconnectMessage=t.SshDisconnectReason=void 0;const i=s(285),n=s(5757);var r,o;(o=t.SshDisconnectReason||(t.SshDisconnectReason={}))[o.none=0]="none",o[o.hostNotAllowedToConnect=1]="hostNotAllowedToConnect",o[o.protocolError=2]="protocolError",o[o.keyExchangeFailed=3]="keyExchangeFailed",o[o.reserved=4]="reserved",o[o.macError=5]="macError",o[o.compressionError=6]="compressionError",o[o.serviceNotAvailable=7]="serviceNotAvailable",o[o.protocolVersionNotSupported=8]="protocolVersionNotSupported",o[o.hostKeyNotVerifiable=9]="hostKeyNotVerifiable",o[o.connectionLost=10]="connectionLost",o[o.byApplication=11]="byApplication",o[o.tooManyConnections=12]="tooManyConnections",o[o.authCancelledByUser=13]="authCancelledByUser",o[o.noMoreAuthMethodsAvailable=14]="noMoreAuthMethodsAvailable",o[o.illegalUserName=15]="illegalUserName";class a extends i.SshMessage{get messageType(){return 1}onRead(e){this.reasonCode=e.readUInt32(),this.description=e.readString("utf8"),e.available>=4?this.language=e.readString("ascii"):this.language=null}onWrite(e){e.writeUInt32(this.validateField(this.reasonCode,"reason code")),e.writeString(this.description||"","utf8"),this.language&&e.writeString(this.language,"ascii")}}t.DisconnectMessage=a;class c extends i.SshMessage{get messageType(){return 2}onRead(e){}onWrite(e){}}t.IgnoreMessage=c;class h extends i.SshMessage{get messageType(){return 3}onRead(e){this.sequenceNumber=e.readUInt32()}onWrite(e){e.writeUInt32(this.validateField(this.sequenceNumber,"sequence number"))}toString(){return this.unimplementedMessageType?`${super.toString()} (messageType=${this.unimplementedMessageType})`:`${super.toString()} (sequenceNumber=${this.sequenceNumber})`}}t.UnimplementedMessage=h;class l extends i.SshMessage{constructor(e){super(),this.alwaysDisplay=!1,this.message=e}get messageType(){return 4}onRead(e){this.alwaysDisplay=e.readBoolean(),this.message=e.readString("utf8"),this.language=e.readString("ascii")}onWrite(e){var t,s;e.writeBoolean(this.alwaysDisplay),e.writeString(null!==(t=this.message)&&void 0!==t?t:"","utf8"),e.writeString(null!==(s=this.language)&&void 0!==s?s:"","ascii")}toString(){return`${super.toString()}: ${this.message}`}}t.DebugMessage=l;class u extends i.SshMessage{get messageType(){return 5}onRead(e){this.serviceName=e.readString("ascii")}onWrite(e){e.writeString(this.validateField(this.serviceName,"service name"),"ascii")}}t.ServiceRequestMessage=u;class d extends i.SshMessage{get messageType(){return 6}onRead(e){this.serviceName=e.readString("ascii")}onWrite(e){e.writeString(this.validateField(this.serviceName,"service name"),"ascii")}}t.ServiceAcceptMessage=d;class p extends i.SshMessage{constructor(e,t){super(),this.requestType=e,this.wantReply=null!=t&&t}get messageType(){return 80}onRead(e){this.requestType=e.readString("ascii"),this.wantReply=e.readBoolean()}onWrite(e){e.writeString(this.validateField(this.requestType,"request type"),"ascii"),e.writeBoolean(this.wantReply)}toString(){return`${super.toString()} (requestType=${this.requestType})`}}t.SessionRequestMessage=p;class f extends i.SshMessage{get messageType(){return 81}onRead(e){}onWrite(e){}}t.SessionRequestSuccessMessage=f;class g extends i.SshMessage{get messageType(){return 82}onRead(e){}onWrite(e){}}t.SessionRequestFailureMessage=g;class m extends i.SshMessage{constructor(){super(...arguments),this.extensionInfo={}}get messageType(){return 7}onRead(e){const t=e.readUInt32();this.extensionInfo={};for(let s=0;s<t;s++){const t=e.readString("ascii"),s=e.readString("utf8");this.extensionInfo[t]=s}}onWrite(e){const t=Object.keys(this.extensionInfo);e.writeUInt32(t.length);for(let s of t)e.writeString(s,"ascii"),e.writeString(this.extensionInfo[s]||"","utf8")}toString(){let e="";for(const[t,s]of Object.entries(this.extensionInfo))e&&(e+="; "),e+=t,s&&(e+="="+s);return`${super.toString()} (${e})`}}t.ExtensionInfoMessage=m,m.serverIndicator="ext-info-c",m.clientIndicator="ext-info-c",t.SessionChannelRequestMessage=class extends p{onRead(e){super.onRead(e),this.senderChannel=e.readUInt32();const t=new n.ChannelRequestMessage;t.read(e),this.request=t}onWrite(e){super.onWrite(e),e.writeUInt32(this.validateField(this.senderChannel,"sender channel")),this.validateField(this.request,"request message").write(e)}},t.SessionReconnectRequestMessage=class extends p{onRead(e){super.onRead(e),this.clientReconnectToken=e.readBinary(),this.lastReceivedSequenceNumber=e.readUInt64()}onWrite(e){super.onWrite(e),e.writeBinary(this.validateField(this.clientReconnectToken,"clientReconnectToken")),e.writeUInt64(this.validateField(this.lastReceivedSequenceNumber,"lastReceivedSequenceNumber"))}},t.SessionReconnectResponseMessage=class extends f{onRead(e){super.onRead(e),this.serverReconnectToken=e.readBinary(),this.lastReceivedSequenceNumber=e.readUInt64()}onWrite(e){super.onWrite(e),e.writeBinary(this.validateField(this.serverReconnectToken,"serverReconnectToken")),e.writeUInt64(this.validateField(this.lastReceivedSequenceNumber,"lastReceivedSequenceNumber"))}},function(e){e[e.none=0]="none",e[e.unknownServerFailure=1]="unknownServerFailure",e[e.sessionNotFound=2]="sessionNotFound",e[e.invalidClientReconnectToken=3]="invalidClientReconnectToken",e[e.serverDroppedMessages=4]="serverDroppedMessages",e[e.unknownClientFailure=101]="unknownClientFailure",e[e.differentServerHostKey=102]="differentServerHostKey",e[e.invalidServerReconnectToken=103]="invalidServerReconnectToken",e[e.clientDroppedMessages=104]="clientDroppedMessages"}(r=t.SshReconnectFailureReason||(t.SshReconnectFailureReason={})),t.SessionReconnectFailureMessage=class extends g{onRead(e){e.available>0&&(this.reasonCode=e.readUInt32(),this.description=e.readString("utf8"),this.language=e.readString("ascii"))}onWrite(e){e.writeUInt32(this.validateField(this.reasonCode,"reason code")),e.writeString(this.description||"","utf8"),e.writeString(this.language||"en","ascii")}toString(){return`${super.toString()} (${r[this.reasonCode||0]}: ${this.description})`}},i.SshMessage.index.set(1,a),i.SshMessage.index.set(2,c),i.SshMessage.index.set(3,h),i.SshMessage.index.set(5,u),i.SshMessage.index.set(6,d),i.SshMessage.index.set(7,m),i.SshMessage.index.set(80,p),i.SshMessage.index.set(81,f),i.SshMessage.index.set(82,g)},5321:(e,t)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.ChannelMetrics=void 0,t.ChannelMetrics=class{constructor(){this.bytesSentSum=0,this.bytesReceivedSum=0}get bytesSent(){return this.bytesSentSum}get bytesReceived(){return this.bytesReceivedSum}addBytesSent(e){this.bytesSentSum+=e}addBytesReceived(e){this.bytesReceivedSum+=e}toString(){return`Bytes S/R: ${this.bytesSent} / ${this.bytesReceived}; `}}},419:(e,t,s)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.SessionContour=void 0;const i=s(2917),n=s(8776),r=s(4564);class o{constructor(e=256){if(this.intervalMs=o.initialInterval,this.count=0,this.updateQueue=new n.Queue,this.updateSemaphore=new r.Semaphore(0),this.disposed=!1,e<2||0!=(e&e-1))throw new Error("Contour intervals must be a power of two.");this.maxIntervals=e,this.intervalBytesSent=new Array(e),this.intervalBytesReceived=new Array(e),this.intervalLatencyMin=new Array(e),this.intervalLatencyMax=new Array(e),this.intervalLatencySum=new Array(e),this.intervalLatencyCount=new Array(e),this.intervalLatencyAvg=new Array(e),this.intervalBytesSent.fill(0),this.intervalBytesReceived.fill(0),this.intervalLatencyMin.fill(0),this.intervalLatencyMax.fill(0),this.intervalLatencySum.fill(0),this.intervalLatencyCount.fill(0),this.intervalLatencyAvg.fill(0)}get intervalCount(){return this.count}get interval(){return this.intervalMs}get bytesSent(){return this.intervalBytesSent.slice(0,this.count)}get bytesReceived(){return this.intervalBytesReceived.slice(0,this.count)}get latencyMinMs(){return this.intervalLatencyMin.slice(0,this.count)}get latencyMaxMs(){return this.intervalLatencyMax.slice(0,this.count)}get latencyAverageMs(){return this.intervalLatencyAvg.slice(0,this.count)}onMessageSent(e){this.updateQueue.enqueue({time:e.time,bytesSent:e.size}),this.updateSemaphore.tryRelease()}onMessageReceived(e){this.updateQueue.enqueue({time:e.time,bytesReceived:e.size}),this.updateSemaphore.tryRelease()}onLatencyUpdated(e){this.updateQueue.enqueue(e),this.updateSemaphore.tryRelease()}onSessionClosed(){this.updateSemaphore.tryRelease()}async collectMetrics(e,t){if(!e)throw new TypeError("A session metrics object is required.");if(this.disposed)throw new i.ObjectDisposedError(this);const s=[];s.push(e.onMessageSent(this.onMessageSent.bind(this))),s.push(e.onMessageReceived(this.onMessageReceived.bind(this))),s.push(e.onLatencyUpdated(this.onLatencyUpdated.bind(this))),s.push(e.onSessionClosed(this.onSessionClosed.bind(this)));try{for(;!(null==t?void 0:t.isCancellationRequested);){try{await this.updateSemaphore.wait(t)}catch(e){break}const e=this.updateQueue.dequeue();if(!e)break;const s=this.updateInterval(e.time);e.bytesSent&&(this.intervalBytesSent[s]+=e.bytesSent),e.bytesReceived&&(this.intervalBytesReceived[s]+=e.bytesReceived);const i=e.latency;i&&((!this.intervalLatencyMin[s]||i<this.intervalLatencyMin[s])&&(this.intervalLatencyMin[s]=i),(!this.intervalLatencyMax[s]||i>this.intervalLatencyMax[s])&&(this.intervalLatencyMax[s]=i),this.intervalLatencySum[s]+=i,this.intervalLatencyCount[s]++,this.intervalLatencyAvg[s]=this.intervalLatencySum[s]/this.intervalLatencyCount[s])}this.disposed&&this.updateSemaphore.dispose()}finally{for(let e of s)e.dispose()}}updateInterval(e){let t=Math.floor(e/this.intervalMs);if(t>=this.intervalCount){for(;t>=this.maxIntervals;)this.expandIntervals(),t=Math.floor(e/this.intervalMs);this.count=t+1}return t}expandIntervals(){const e=(e,t,s)=>0===e?t:0===t?e:s(e,t),t=this.maxIntervals/2;for(let s=0;s<t;s++){const t=2*s,i=2*s+1;this.intervalBytesSent[s]=this.intervalBytesSent[t]+this.intervalBytesSent[i],this.intervalBytesReceived[s]=this.intervalBytesReceived[t]+this.intervalBytesReceived[i],this.intervalLatencyMin[s]=e(this.intervalLatencyMin[t],this.intervalLatencyMin[i],Math.min),this.intervalLatencyMax[s]=e(this.intervalLatencyMax[t],this.intervalLatencyMax[i],Math.max),this.intervalLatencySum[s]=this.intervalLatencySum[t]+this.intervalLatencySum[i];const n=this.intervalLatencyCount[t]+this.intervalLatencyCount[i];this.intervalLatencyCount[s]=n,this.intervalLatencyAvg[s]=0===n?0:this.intervalLatencySum[s]/this.intervalLatencyCount[s]}this.intervalBytesSent.fill(0,t,this.maxIntervals),this.intervalBytesReceived.fill(0,t,this.maxIntervals),this.intervalLatencyMin.fill(0,t,this.maxIntervals),this.intervalLatencyMax.fill(0,t,this.maxIntervals),this.intervalLatencySum.fill(0,t,this.maxIntervals),this.intervalLatencyCount.fill(0,t,this.maxIntervals),this.intervalLatencyAvg.fill(0,t,this.maxIntervals),this.intervalMs*=2}dispose(){this.disposed=!0,this.updateSemaphore.tryRelease()}export(){const e=e=>Math.max(0,Math.ceil(Math.log2(Math.max(...e)/255))),t=(e,t)=>Math.round(e/Math.pow(2,t)),s=Buffer.alloc(3+5*(2+this.intervalCount)),i=Math.log2(this.interval/o.initialInterval);s[0]=1,s[1]=5,s[2]=i,s[3]=e(this.latencyMinMs),s[4]=e(this.latencyMaxMs),s[5]=e(this.latencyAverageMs),s[6]=e(this.bytesSent),s[7]=e(this.bytesReceived),s[8]=a.latencyMin,s[9]=a.latencyMax,s[10]=a.latencyAverage,s[11]=a.bytesSent,s[12]=a.bytesReceived;for(let e=0;e<this.intervalCount;e++){const i=13+5*e;s[i+0]=t(this.intervalLatencyMin[e],s[3]),s[i+1]=t(this.intervalLatencyMax[e],s[4]),s[i+2]=t(this.intervalLatencyAvg[e],s[5]),s[i+3]=t(this.intervalBytesSent[e],s[6]),s[i+4]=t(this.intervalBytesReceived[e],s[7])}return s.toString("base64")}static import(e){const t=Buffer.from(e,"base64");if(t.length<3)throw new Error("Invalid session contour string.");const s=t[0],i=t[1],n=t[2];if(1!==s)throw new Error(`Unsupported session contour version: ${s}`);const r=(t.length-3)/i-2;if(r<1||t.length!==3+i*(r+2))throw new Error("Incomplete session contour string.");const c=Math.pow(2,Math.ceil(Math.log2(r))),h=new o(c);h.intervalMs=Math.pow(2,n)*o.initialInterval,h.count=r;const l=new Array(i);for(let e=0;e<i;e++)l[e]=Math.pow(2,t[3+e]);const u=new Array(i);for(let e=0;e<i;e++)u[e]=t[3+i+e];for(let e=0;e<r;e++){const s=3+(2+e)*i;for(let n=0;n<i;n++)switch(u[n]){case a.latencyMin:h.intervalLatencyMin[e]=t[s+n]*l[n];break;case a.latencyMax:h.intervalLatencyMax[e]=t[s+n]*l[n];break;case a.latencyAverage:h.intervalLatencyAvg[e]=h.intervalLatencySum[e]=t[s+n]*l[n],h.intervalLatencyCount[e]=0===t[s+n]?0:1;break;case a.bytesSent:h.intervalBytesSent[e]=t[s+n]*l[n];break;case a.bytesReceived:h.intervalBytesReceived[e]=t[s+n]*l[n]}}return h}}var a;t.SessionContour=o,o.initialInterval=1e3,function(e){e[e.none=0]="none",e[e.latencyMin=1]="latencyMin",e[e.latencyMax=2]="latencyMax",e[e.latencyAverage=3]="latencyAverage",e[e.bytesSent=11]="bytesSent",e[e.bytesReceived=12]="bytesReceived"}(a||(a={}))},3965:(e,t,s)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.SessionMetrics=void 0;const i=s(3730);t.SessionMetrics=class{constructor(){this.startTime=0,this.messagesSentCount=0,this.messagesReceivedCount=0,this.bytesSentSum=0,this.bytesReceivedSum=0,this.reconnectionsCount=0,this.currentLatency=0,this.minLatency=0,this.maxLatency=0,this.latencySum=0,this.latencyCount=0,this.messageSentEmitter=new i.Emitter,this.onMessageSent=this.messageSentEmitter.event,this.messageReceivedEmitter=new i.Emitter,this.onMessageReceived=this.messageReceivedEmitter.event,this.latencyUpdatedEmitter=new i.Emitter,this.onLatencyUpdated=this.latencyUpdatedEmitter.event,this.sessionClosedEmitter=new i.Emitter,this.onSessionClosed=this.sessionClosedEmitter.event,"object"==typeof performance&&performance.now?Object.defineProperty(this,"time",{get:this.browserTime}):"object"==typeof process&&process.hrtime&&Object.defineProperty(this,"time",{get:this.nodejsTime}),this.startTime=this.time}get time(){return Date.now()-this.startTime}browserTime(){return performance.now()-this.startTime}nodejsTime(){const[e,t]=process.hrtime();return 1e3*e+t/1e6-this.startTime}get messagesSent(){return this.messagesSentCount}get messagesReceived(){return this.messagesReceivedCount}get bytesSent(){return this.bytesSentSum}get bytesReceived(){return this.bytesReceivedSum}get reconnections(){return this.reconnectionsCount}get latencyAverageMs(){return 0===this.latencyCount?0:this.latencySum/this.latencyCount}get latencyMinMs(){return this.minLatency}get latencyMaxMs(){return this.maxLatency}get latencyCurrentMs(){return this.currentLatency}addMessageSent(e){this.messagesSentCount++,this.bytesSentSum+=e,this.messageSentEmitter.fire({time:this.time,size:e})}addMessageReceived(e){this.messagesReceivedCount++,this.bytesReceivedSum+=e,this.messageReceivedEmitter.fire({time:this.time,size:e})}addReconnection(){this.reconnectionsCount++}updateLatency(e){if(e<0)throw new Error("Measured latency cannot be negative.");this.currentLatency=e,0!==e&&((0===this.minLatency||e<this.minLatency)&&(this.minLatency=e),(0===this.maxLatency||e>this.maxLatency)&&(this.maxLatency=e),this.latencySum+=e,this.latencyCount++,this.latencyUpdatedEmitter.fire({time:this.time,latency:e}))}close(){this.currentLatency=0,this.sessionClosedEmitter.fire()}toString(){let e=`Messages S/R: ${this.messagesSent} / ${this.messagesReceived}; Bytes S/R: ${this.bytesSent} / ${this.bytesReceived}; Reconnections: ${this.reconnections}; `;const t=this.minLatency>=10?1:this.minLatency>=1?10:100;return this.maxLatency>0&&(e+=`Latency Min-Avg-Max: ${Math.round(this.minLatency*t)/t} - ${Math.round(this.latencySum/this.latencyCount*t)/t} - ${Math.round(this.maxLatency*t)/t} ms; `),this.currentLatency>0&&(e+=`Current Latency: ${Math.round(this.currentLatency*t)/t} ms; `),e}}},9802:(e,t,s)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.MultiChannelStream=void 0;const i=s(3730),n=s(2656),r=s(7395),o=s(7183),a=s(818),c=s(7165),h=s(3776);t.MultiChannelStream=class{constructor(e){if(this.transportStream=e,this.disposed=!1,this.disposables=[],this.closedEmitter=new i.Emitter,this.onClosed=this.closedEmitter.event,this.channelOpeningEmitter=new i.Emitter,!e)throw new TypeError("transportStream is required.");const t=new o.SshSessionConfiguration(!1);this.session=new r.SshSession(t),this.session.onClosed(this.onSessionClosed,this,this.disposables),this.session.onChannelOpening(this.onSessionChannelOpening,this,this.disposables)}get trace(){return this.session.trace}set trace(e){this.session.trace=e}get isClosed(){return this.disposed||this.session.isClosed}get onChannelOpening(){return this.isClosed||this.session.activateService(c.ConnectionService),this.channelOpeningEmitter.event}async connect(e){await this.session.connect(this.transportStream,e)}async acceptChannel(e,t){return await this.session.connect(this.transportStream,t),await this.session.acceptChannel(e,t)}async acceptStream(e,t){return new n.SshStream(await this.acceptChannel(e,t))}async openChannel(e,t){return await this.session.connect(this.transportStream,t),await this.session.openChannel(null!=e?e:null,t)}async openStream(e,t){return new n.SshStream(await this.openChannel(e,t))}async connectAndRunUntilClosed(e){const t=[],s=new Promise(((s,i)=>{null==e||e.onCancellationRequested(i,null,t),this.session.onClosed(s,null,t)}));try{await this.connect(e),await s}finally{t.forEach((e=>e.dispose())),await this.close()}}dispose(){if(!this.disposed){this.disposed=!0,this.session.dispose(),this.unsubscribe();try{this.transportStream&&this.transportStream.close().catch((e=>{this.trace(h.TraceLevel.Error,h.SshTraceEventIds.streamCloseError,`Error closing transport stream: ${e.message}`,e)}))}catch(e){if(!(e instanceof Error))throw e;this.trace(h.TraceLevel.Error,h.SshTraceEventIds.streamCloseError,`Error closing transport stream: ${e.message}`,e)}}}async close(){this.disposed||(this.disposed=!0,await this.session.close(a.SshDisconnectReason.none,"SshSession disposed"),this.session.dispose(),this.unsubscribe(),await this.transportStream.close())}onSessionClosed(e){this.unsubscribe(),this.closedEmitter.fire(e)}onSessionChannelOpening(e){this.channelOpeningEmitter.fire(e)}unsubscribe(){this.disposables.forEach((e=>e.dispose())),this.disposables=[]}}},6356:(e,t,s)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.PipeExtensions=void 0;const i=s(3730),n=s(818),r=s(5757),o=s(3708),a=s(2917);class c{static async pipeSession(e,t){if(!e)throw new TypeError("Session is required.");if(!t)throw new TypeError("Target session is required");const s=new o.PromiseCompletionSource;e.onRequest((e=>{e.responsePromise=c.forwardSessionRequest(e,t,e.cancellation)})),t.onRequest((t=>{t.responsePromise=c.forwardSessionRequest(t,e,t.cancellation)})),e.onChannelOpening((e=>{e.isRemoteRequest&&(e.openingPromise=c.forwardChannel(e,t,e.cancellation))})),t.onChannelOpening((t=>{t.isRemoteRequest&&(t.openingPromise=c.forwardChannel(t,e,t.cancellation))})),e.onClosed((e=>{s.resolve(c.forwardSessionClose(t,e))})),t.onClosed((t=>{s.resolve(c.forwardSessionClose(e,t))}));const i=await s.promise;await i}static async pipeChannel(e,t){if(!e)throw new TypeError("Channel is required.");if(!t)throw new TypeError("Target channel is required");const s=new o.PromiseCompletionSource;let i=!1;e.onRequest((e=>{e.responsePromise=c.forwardChannelRequest(e,t,e.cancellation)})),t.onRequest((t=>{t.responsePromise=c.forwardChannelRequest(t,e,t.cancellation)})),e.onDataReceived((s=>{c.forwardData(e,t,s)})),t.onDataReceived((s=>{c.forwardData(t,e,s)})),e.onClosed((e=>{i||(i=!0,s.resolve(c.forwardChannelClose(t,e)))})),t.onClosed((t=>{i||(i=!0,s.resolve(c.forwardChannelClose(e,t)))}));const n=await s.promise;await n}static async forwardSessionRequest(e,t,s){return await t.requestResponse(e.request,n.SessionRequestSuccessMessage,n.SessionRequestFailureMessage,s)}static async forwardChannel(e,t,s){var i;try{const i=await t.openChannel(e.request,null,s);c.pipeChannel(e.channel,i)}catch(t){if(!(t instanceof Error))throw t;t instanceof a.SshChannelError?e.failureReason=null!==(i=t.reason)&&void 0!==i?i:r.SshChannelOpenFailureReason.connectFailed:e.failureReason=r.SshChannelOpenFailureReason.connectFailed,e.failureDescription=t.message}}static async forwardChannelRequest(e,t,s){return e.request.recipientChannel=t.remoteChannelId,await t.request(e.request,s)?new r.ChannelSuccessMessage:new r.ChannelFailureMessage}static async forwardSessionClose(e,t){var s;return e.close(t.reason,t.message,null!==(s=t.error)&&void 0!==s?s:void 0)}static async forwardData(e,t,s){await t.send(s,i.CancellationToken.None),e.adjustWindow(s.length)}static async forwardChannelClose(e,t){return t.error?(e.close(t.error),Promise.resolve()):t.exitSignal?e.close(t.exitSignal,t.errorMessage):"number"==typeof t.exitStatus?e.close(t.exitStatus):e.close()}}t.PipeExtensions=c},6502:function(e,t,s){"use strict";var i,n=this&&this.__decorate||function(e,t,s,i){var n,r=arguments.length,o=r<3?t:null===i?i=Object.getOwnPropertyDescriptor(t,s):i;if("object"==typeof Reflect&&"function"==typeof Reflect.decorate)o=Reflect.decorate(e,t,s,i);else for(var a=e.length-1;a>=0;a--)(n=e[a])&&(o=(r<3?n(o):r>3?n(t,s,o):n(t,s))||o);return r>3&&o&&Object.defineProperty(t,s,o),o};Object.defineProperty(t,"__esModule",{value:!0}),t.AuthenticationService=void 0;const r=s(447),o=s(450),a=s(3730),c=s(7914),h=s(818),l=s(8047),u=s(7165),d=s(4670),p=s(8776),f=s(3776);let g=i=class extends r.SshService{constructor(e){var t;super(e),this.authenticationFailureCount=0,this.disposeCancellationSource=new a.CancellationTokenSource;const s=null===(t=e.algorithms)||void 0===t?void 0:t.publicKeyAlgorithmName;if(!s)throw new Error("Algorithms not initialized.");this.publicKeyAlgorithmName=s}handleMessage(e,t){if(e instanceof o.AuthenticationSuccessMessage)return this.handleSuccessMessage(e);if(e instanceof o.AuthenticationFailureMessage)return this.handleFailureMessage(e);if(e instanceof o.AuthenticationRequestMessage)return this.handleAuthenticationRequestMessage(e,t);throw new Error(`Message not implemented: ${e}`)}async handleAuthenticationRequestMessage(e,t){if(this.trace(f.TraceLevel.Info,f.SshTraceEventIds.sessionAuthenticating,`Authentication request: ${e.methodName}`),"publickey"===e.methodName||"hostbased"===e.methodName)return this.handlePublicKeyRequestMessage(e.convertTo(new o.PublicKeyRequestMessage),t);if("password"===e.methodName)return this.handlePasswordRequestMessage(e.convertTo(new o.PasswordRequestMessage),t);if("none"===e.methodName)return this.handleAuthenticating(e,new l.SshAuthenticatingEventArgs(l.SshAuthenticationType.clientNone,{username:e.username},t));{const e=new o.AuthenticationFailureMessage;e.methodNames=["publickey","password","hostbased"],await this.session.sendMessage(e,t)}}async handlePublicKeyRequestMessage(e,t){var s,i,n;const r=this.session.config.getPublicKeyAlgorithm(e.keyAlgorithmName);if(!r){const e=new o.AuthenticationFailureMessage;return e.methodNames=["publickey","password"],void await this.session.sendMessage(e,t)}const a=r.createKeyPair();let h;if(await a.setPublicKeyBytes(e.publicKey),"hostbased"===e.methodName)h=new l.SshAuthenticatingEventArgs(l.SshAuthenticationType.clientHostBased,{username:null!==(s=e.username)&&void 0!==s?s:"",publicKey:a,clientHostname:e.clientHostname,clientUsername:e.clientUsername});else if(e.hasSignature){const s=r.readSignatureData(e.signature),i=this.session.sessionId;if(null==i)throw new Error("Session ID not initialized.");const o=new c.SshDataWriter(Buffer.alloc(i.length+e.payloadWithoutSignature.length+20));o.writeBinary(i),o.write(e.payloadWithoutSignature);const u=o.toBuffer(),d=r.createVerifier(a);await d.verify(u,s)||await this.handleAuthenticationFailure("Public key authentication failed: invalid signature.",t),h=new l.SshAuthenticatingEventArgs(l.SshAuthenticationType.clientPublicKey,{username:null!==(n=e.username)&&void 0!==n?n:"",publicKey:a})}else h=new l.SshAuthenticatingEventArgs(l.SshAuthenticationType.clientPublicKeyQuery,{username:null!==(i=e.username)&&void 0!==i?i:"",publicKey:a});await this.handleAuthenticating(e,h,t)}async handlePasswordRequestMessage(e,t){var s,i;const n=new l.SshAuthenticatingEventArgs(l.SshAuthenticationType.clientPassword,{username:null!==(s=e.username)&&void 0!==s?s:"",password:null!==(i=e.password)&&void 0!==i?i:""});await this.handleAuthenticating(e,n,t)}async handleAuthenticating(e,t,s){var i;let n=null;try{n=await this.session.raiseAuthenticatingEvent(t)}catch(e){if(!(e instanceof Error))throw e;this.trace(f.TraceLevel.Error,f.SshTraceEventIds.authenticationError,`Error while authenticating client: ${e.message}`,e),n=null}if(n)if(t.authenticationType===l.SshAuthenticationType.clientPublicKeyQuery){const t=e,i=new o.PublicKeyOKMessage;i.keyAlgorithmName=t.keyAlgorithmName,i.publicKey=t.publicKey,await this.session.sendMessage(i,s)}else this.session.principal=n,e.serviceName&&this.session.activateService(e.serviceName),this.trace(f.TraceLevel.Info,f.SshTraceEventIds.sessionAuthenticated,`${l.SshAuthenticationType[t.authenticationType]} authentication succeeded.`),await this.session.sendMessage(new o.AuthenticationSuccessMessage,s),null===(i=this.session)||void 0===i||i.handleClientAuthenticated();else await this.handleAuthenticationFailure(`${l.SshAuthenticationType[t.authenticationType]} authentication failed.`)}async handleAuthenticationFailure(e,t){this.authenticationFailureCount++,this.trace(f.TraceLevel.Warning,f.SshTraceEventIds.clientAuthenticationFailed,e);const s=new o.AuthenticationFailureMessage;s.methodNames=["publickey","password","hostbased"],await this.session.sendMessage(s,t),this.authenticationFailureCount>=this.session.config.maxClientAuthenticationAttempts&&await this.session.close(h.SshDisconnectReason.noMoreAuthMethodsAvailable,"Authentication failed.")}async authenticateClient(e,t){var s,i,n,r;this.clientAuthenticationMethods=new p.Queue;for(let t of null!==(s=e.publicKeys)&&void 0!==s?s:[]){if(!t)continue;const s=null!==(i=e.username)&&void 0!==i?i:"";let n=t;const r=e.privateKeyProvider;this.clientAuthenticationMethods.enqueue((async e=>{if(!n.hasPrivateKey){if(null==r)throw new Error("A private key provider is required.");n=await r(t,null!=e?e:a.CancellationToken.None)}n?await this.requestPublicKeyAuthentication(s,n,e):await this.session.close(h.SshDisconnectReason.authCancelledByUser)}))}const o=e.passwordProvider;if(o)this.clientAuthenticationMethods.enqueue((async e=>{var t;const s=o(null!=e?e:a.CancellationToken.None),i=s?await s:null;i?await this.requestPasswordAuthentication(null!==(t=i[0])&&void 0!==t?t:"",i[1],e):await this.session.close(h.SshDisconnectReason.authCancelledByUser)}));else if(e.password){const t=null!==(n=e.username)&&void 0!==n?n:"",s=e.password;this.clientAuthenticationMethods.enqueue((async e=>{await this.requestPasswordAuthentication(t,s,e)}))}if(0===this.clientAuthenticationMethods.size){const t=null!==(r=e.username)&&void 0!==r?r:"";this.clientAuthenticationMethods.enqueue((async e=>{await this.requestUsernameAuthentication(t,e)}))}const c=this.clientAuthenticationMethods.dequeue();await c(t)}async requestUsernameAuthentication(e,t){const s=new o.AuthenticationRequestMessage;s.serviceName=u.ConnectionService.serviceName,s.methodName="none",s.username=e,await this.session.sendMessage(s,t),this.session.activateService(u.ConnectionService)}async requestPublicKeyAuthentication(e,t,s){const i=this.session.config.publicKeyAlgorithms.find((e=>(null==e?void 0:e.keyAlgorithmName)===t.keyAlgorithmName));if(!i)throw new Error(`Public key algorithm '${t.keyAlgorithmName}' is not in session config.`);const n=new o.PublicKeyRequestMessage;n.serviceName=u.ConnectionService.serviceName,n.username=e,n.keyAlgorithmName=i.name,n.publicKey=await t.getPublicKeyBytes(i.name),n.signature=await this.createAuthenticationSignature(n,i,t),await this.session.sendMessage(n,s),0===this.clientAuthenticationMethods.size&&this.session.activateService(u.ConnectionService)}async requestPasswordAuthentication(e,t,s){const i=new o.PasswordRequestMessage;i.serviceName=u.ConnectionService.serviceName,i.username=e,i.password=t,await this.session.sendMessage(i,s),this.session.activateService(u.ConnectionService)}handleFailureMessage(e){this.session.onAuthenticationComplete(!1)}handleSuccessMessage(e){this.session.activateService(u.ConnectionService),this.session.onAuthenticationComplete(!0)}async createAuthenticationSignature(e,t,s){const i=this.session.sessionId;if(null==i)throw new Error("Session ID not initialized.");const n=new c.SshDataWriter(Buffer.alloc(e.publicKey.length+(e.username||"").length+400));n.writeBinary(i),n.writeByte(e.messageType),n.writeString(e.username||"","utf8"),n.writeString(e.serviceName||"","ascii"),n.writeString("publickey","ascii"),n.writeBoolean(!0),n.writeString(e.keyAlgorithmName,"ascii"),n.writeBinary(e.publicKey);const r=t.createSigner(s),o=await r.sign(n.toBuffer());return t.createSignatureData(o)}};g.serviceName="ssh-userauth",g=i=n([(0,d.serviceActivation)({serviceRequest:i.serviceName})],g),t.AuthenticationService=g},7165:function(e,t,s){"use strict";var i,n=this&&this.__decorate||function(e,t,s,i){var n,r=arguments.length,o=r<3?t:null===i?i=Object.getOwnPropertyDescriptor(t,s):i;if("object"==typeof Reflect&&"function"==typeof Reflect.decorate)o=Reflect.decorate(e,t,s,i);else for(var a=e.length-1;a>=0;a--)(n=e[a])&&(o=(r<3?n(o):r>3?n(t,s,o):n(t,s))||o);return r>3&&o&&Object.defineProperty(t,s,o),o};Object.defineProperty(t,"__esModule",{value:!0}),t.ConnectionService=void 0;const r=s(447),o=s(5757),a=s(3708),c=s(4756),h=s(7437),l=s(2917),u=s(6442),d=s(4670),p=s(3776);let f=i=class extends r.SshService{constructor(e){super(e),this.channelCounter=0,this.channelMap=new Map,this.nonAcceptedChannels=new Map,this.pendingChannels=new Map,this.pendingAcceptChannels=new Map}get channels(){return Array.from(this.channelMap.values())}close(e){for(let t of this.channelMap.values())t.close(e)}dispose(){const e=[...this.channelMap.values()];let t=[...this.pendingChannels.values()].map((e=>e.completionSource));this.pendingAcceptChannels.size>0&&(t=t.concat([...this.pendingAcceptChannels.values()].reduce(((e,t)=>e.concat(t)))));for(let t of e)t.dispose();for(let e of t)e.reject(new l.SshConnectionError("Session closed."));super.dispose()}async acceptChannel(e,t){const s=new a.PromiseCompletionSource;let i;if(t){if(t.isCancellationRequested)throw new h.CancellationError;i=t.onCancellationRequested((()=>{const t=this.pendingAcceptChannels.get(e);if(t){const e=t.findIndex((e=>Object.is(e,s)));e>=0&&t.splice(e,1)}s.reject(new h.CancellationError)}))}let n=null;if(n=Array.from(this.nonAcceptedChannels.values()).find((t=>t.channelType===e))||null,n)this.nonAcceptedChannels.delete(n.channelId);else{let t=this.pendingAcceptChannels.get(e);t||(t=[],this.pendingAcceptChannels.set(e,t)),t.push(s)}try{return n||await s.promise}finally{i&&i.dispose()}}async openChannel(e,t,s){const i=++this.channelCounter;e.senderChannel=i;let n=null;if(s){if(s.isCancellationRequested)throw new h.CancellationError;n=s.onCancellationRequested((()=>{this.pendingChannels.delete(i)&&t.reject(new h.CancellationError)}))}return this.pendingChannels.set(i,{openMessage:e,completionSource:t,cancellationRegistration:n}),await this.session.sendMessage(e),i}handleMessage(e,t){if(e instanceof o.ChannelDataMessage)return this.handleDataMessage(e);if(e instanceof o.ChannelWindowAdjustMessage)return this.handleAdjustWindowMessage(e);if(e instanceof o.ChannelEofMessage)return this.handleEofMessage(e);if(e instanceof o.ChannelOpenMessage)return this.handleOpenMessage(e,t);if(e instanceof o.ChannelCloseMessage)return this.handleCloseMessage(e);if(e instanceof o.ChannelOpenConfirmationMessage)return this.handleOpenConfirmationMessage(e,t);if(e instanceof o.ChannelOpenFailureMessage)return this.handleOpenFailureMessage(e);if(e instanceof o.ChannelRequestMessage)return this.handleRequestMessage(e,t);if(e instanceof o.ChannelSuccessMessage)return this.handleSuccessMessage(e);if(e instanceof o.ChannelFailureMessage)return this.handleFailureMessage(e);throw new Error(`Message not implemented: ${e}`)}async handleOpenMessage(e,t){const s=e.senderChannel;if(!this.session.canAcceptRequests){this.trace(p.TraceLevel.Warning,p.SshTraceEventIds.channelOpenFailed,"Channel open request blocked because the session is not yet authenticated.");const e=new o.ChannelOpenFailureMessage;return e.recipientChannel=s,e.reasonCode=o.SshChannelOpenFailureReason.administrativelyProhibited,e.description="Authenticate before opening channels.",void await this.session.sendMessage(e,t)}if(!e.channelType){const e=new o.ChannelOpenFailureMessage;return e.recipientChannel=s,e.reasonCode=o.SshChannelOpenFailureReason.unknownChannelType,e.description="Channel type not specified.",void await this.session.sendMessage(e,t)}const i=new c.SshChannel(this,e.channelType,s,e.initialWindowSize,e.maximumPacketSize,++this.channelCounter),n=new u.SshChannelOpeningEventArgs(e,i,!0);try{await this.session.handleChannelOpening(n,t)}catch(e){throw i.dispose(),e}if(n.failureReason!==o.SshChannelOpenFailureReason.none){const e=new o.ChannelOpenFailureMessage;e.recipientChannel=s,e.reasonCode=n.failureReason,e.description=n.failureDescription||void 0;try{await this.session.sendMessage(e,t)}finally{i.dispose()}return}if(this.session.isClosed)return void i.dispose();this.channelMap.set(i.channelId,i);const r=new o.ChannelOpenConfirmationMessage;r.recipientChannel=i.remoteChannelId,r.senderChannel=i.channelId,r.initialWindowSize=e.initialWindowSize,r.maximumPacketSize=e.maximumPacketSize,await this.session.sendMessage(r,t);let a=!1;const h=this.pendingAcceptChannels.get(i.channelType);for(;h&&h.length>0;){h.shift().resolve(i),a=!0;break}a||this.nonAcceptedChannels.set(i.channelId,i),this.onChannelOpenCompleted(i.channelId,i),i.enableSending()}handleCloseMessage(e){const t=this.findChannelById(e.recipientChannel);t&&t.handleClose()}async handleOpenConfirmationMessage(e,t){var s;let i,n=null;const r=this.pendingChannels.get(e.recipientChannel);if(!r)throw this.channelMap.has(e.recipientChannel)?new Error("Duplicate channel ID."):new Error("Channel confirmation was not requested.");i=r.openMessage,n=r.completionSource,r.cancellationRegistration&&r.cancellationRegistration.dispose(),this.pendingChannels.delete(e.recipientChannel);const a=new c.SshChannel(this,i.channelType||c.SshChannel.sessionChannelType,e.senderChannel,e.initialWindowSize,e.maximumPacketSize,e.recipientChannel);this.channelMap.set(a.channelId,a);const h=new u.SshChannelOpeningEventArgs(i,a,!1);if(await this.session.handleChannelOpening(h,t),n){if(h.failureReason!==o.SshChannelOpenFailureReason.none)return void n.reject(new l.SshChannelError(null!==(s=h.failureDescription)&&void 0!==s?s:"Channel open failure.",h.failureReason));n.resolve(a)}else this.onChannelOpenCompleted(a.channelId,a);a.enableSending()}handleOpenFailureMessage(e){let t=null;const s=this.pendingChannels.get(e.recipientChannel);s&&(t=s.completionSource,s.cancellationRegistration&&s.cancellationRegistration.dispose(),this.pendingChannels.delete(e.recipientChannel)),null!=t?t.reject(new l.SshChannelError(e.description||"Channel open rejected.",e.reasonCode)):this.onChannelOpenCompleted(e.recipientChannel,null)}async handleRequestMessage(e,t){const s=this.findChannelById(e.recipientChannel);s?await s.handleRequest(e,t):this.trace(p.TraceLevel.Warning,p.SshTraceEventIds.channelRequestFailed,`Invalid channel ID ${e.recipientChannel} in channel request message.`)}handleSuccessMessage(e){const t=this.findChannelById(e.recipientChannel);t?t.handleResponse(!0):this.trace(p.TraceLevel.Warning,p.SshTraceEventIds.channelRequestFailed,`Invalid channel ID ${e.recipientChannel} in channel success message.`)}handleFailureMessage(e){const t=this.findChannelById(e.recipientChannel);t?t.handleResponse(!1):this.trace(p.TraceLevel.Warning,p.SshTraceEventIds.channelRequestFailed,`Invalid channel ID ${e.recipientChannel} in channel failure message.`)}handleDataMessage(e){const t=this.findChannelById(e.recipientChannel);if(t)return t.handleDataReceived(e.data)}handleAdjustWindowMessage(e){const t=this.findChannelById(e.recipientChannel);t&&t.adjustRemoteWindow(e.bytesToAdd)}handleEofMessage(e){const t=this.findChannelById(e.recipientChannel);t&&t.handleEof()}onChannelOpenCompleted(e,t){t?this.trace(p.TraceLevel.Info,p.SshTraceEventIds.channelOpened,`${this.session} ChannelOpenCompleted(${t})`):this.trace(p.TraceLevel.Warning,p.SshTraceEventIds.channelOpenFailed,`${this.session} ChannelOpenCompleted(${e} failed)`)}findChannelById(e){var t;return null!==(t=this.channelMap.get(e))&&void 0!==t?t:null}_removeChannel(e){this.channelMap.delete(e.channelId),this.pendingChannels.delete(e.channelId)}};f.serviceName="ssh-connection",f=i=n([(0,d.serviceActivation)({serviceRequest:i.serviceName})],f),t.ConnectionService=f},3210:function(e,t,s){"use strict";var i,n=this&&this.__decorate||function(e,t,s,i){var n,r=arguments.length,o=r<3?t:null===i?i=Object.getOwnPropertyDescriptor(t,s):i;if("object"==typeof Reflect&&"function"==typeof Reflect.decorate)o=Reflect.decorate(e,t,s,i);else for(var a=e.length-1;a>=0;a--)(n=e[a])&&(o=(r<3?n(o):r>3?n(t,s,o):n(t,s))||o);return r>3&&o&&Object.defineProperty(t,s,o),o};Object.defineProperty(t,"__esModule",{value:!0}),t.KeyExchangeService=void 0;const r=s(4300),o=s(7395),a=s(447),c=s(404),h=s(856),l=s(1605),u=s(7914),d=s(2917),p=s(818),f=s(7462),g=s(3730),m=s(4670),y=s(3776);class v{}const w="ext-info-s",S="ext-info-c";let b=i=class extends a.SshService{constructor(e,t){super(e),this.isClientSession=t,this.isInitialExchange=!1,this.exchangeContext=null}get exchanging(){return!!this.exchangeContext}async startKeyExchange(e){this.isInitialExchange=e,this.exchangeContext=new v;const t=this.createKeyExchangeInitMessage();let s=null;return this.isClientSession?(e&&this.session.config.enableKeyExchangeGuess&&(s=await this.createKeyExchangeGuessMessage(),t.firstKexPacketFollows=!!s),this.exchangeContext.clientKexInitPayload=t.toBuffer()):this.exchangeContext.serverKexInitPayload=t.toBuffer(),[t,s]}finishKeyExchange(){const e=this.exchangeContext.newAlgorithms;return this.exchangeContext=null,e}abortKeyExchange(){this.exchangeContext=null}createKeyExchangeInitMessage(){const e=this.isClientSession?S:w,t=this.session.config,s=new h.KeyExchangeInitMessage;return s.keyExchangeAlgorithms=(0,l.algorithmNames)(t.keyExchangeAlgorithms).concat(e),s.serverHostKeyAlgorithms=this.getPublicKeyAlgorithms(),s.encryptionAlgorithmsClientToServer=s.encryptionAlgorithmsServerToClient=(0,l.algorithmNames)(t.encryptionAlgorithms),s.macAlgorithmsClientToServer=s.macAlgorithmsServerToClient=(0,l.algorithmNames)(t.hmacAlgorithms),s.compressionAlgorithmsClientToServer=s.compressionAlgorithmsServerToClient=(0,l.algorithmNames)(t.compressionAlgorithms),s.languagesClientToServer=[""],s.languagesServerToClient=[""],s.firstKexPacketFollows=!1,s.reserved=0,s}getPublicKeyAlgorithms(){var e,t;let s=[...this.session.config.publicKeyAlgorithms];if(s.length>1&&!this.isClientSession){const i=null===(t=null===(e=this.session.credentials)||void 0===e?void 0:e.publicKeys)||void 0===t?void 0:t.map((e=>e.keyAlgorithmName));i&&(s=s.filter((e=>e&&i.includes(e.keyAlgorithmName))))}return(0,l.algorithmNames)(s)}async createKeyExchangeGuessMessage(){if(!this.exchangeContext)throw new Error("Key exchange was not started.");const e=this.session.config.keyExchangeAlgorithms[0];if(!e)return null;this.exchangeContext.keyExchange=e.name,this.exchangeContext.exchange=e.createKeyExchange(),this.exchangeContext.exchangeValue=await this.exchangeContext.exchange.startKeyExchange();const t=new h.KeyExchangeDhInitMessage;return t.e=this.exchangeContext.exchangeValue,t}handleMessage(e,t){if(e instanceof h.KeyExchangeInitMessage)return this.handleInitMessage(e,t);if(e instanceof h.KeyExchangeDhInitMessage)return this.handleDhInitMessage(e,t);if(e instanceof h.KeyExchangeDhReplyMessage)return this.handleDhReplyMessage(e,t);throw new Error(`Message not implemented: ${e}`)}async handleInitMessage(e,t){var s,i,n,r,o;if(!this.exchangeContext)throw new Error("Key exchange was not started.");const a=this.session.config;if(this.exchangeContext.keyExchange=this.chooseAlgorithm("KeyExchange",(0,l.algorithmNames)(a.keyExchangeAlgorithms),e.keyExchangeAlgorithms),"none"===this.exchangeContext.keyExchange)return this.trace(y.TraceLevel.Info,y.SshTraceEventIds.algorithmNegotiation,"Client and server negotiated no security. Cancelling key-exchange."),this.exchangeContext.newAlgorithms=new f.SshSessionAlgorithms,void await this.session.handleNewKeysMessage(new h.NewKeysMessage,t);let c;if(this.exchangeContext.publicKey=this.chooseAlgorithm("PublicKey",this.getPublicKeyAlgorithms(),e.serverHostKeyAlgorithms),this.exchangeContext.clientEncryption=this.chooseAlgorithm("ClientEncryption",(0,l.algorithmNames)(a.encryptionAlgorithms),e.encryptionAlgorithmsClientToServer),this.exchangeContext.serverEncryption=this.chooseAlgorithm("ServerEncryption",(0,l.algorithmNames)(a.encryptionAlgorithms),e.encryptionAlgorithmsServerToClient),this.exchangeContext.clientHmac=this.chooseAlgorithm("ClientHmac",(0,l.algorithmNames)(a.hmacAlgorithms),e.macAlgorithmsClientToServer),this.exchangeContext.serverHmac=this.chooseAlgorithm("ServerHmac",(0,l.algorithmNames)(a.hmacAlgorithms),e.macAlgorithmsServerToClient),this.exchangeContext.clientCompression=this.chooseAlgorithm("ClientCompression",(0,l.algorithmNames)(a.compressionAlgorithms),e.compressionAlgorithmsClientToServer),this.exchangeContext.serverCompression=this.chooseAlgorithm("ServerCompression",(0,l.algorithmNames)(a.compressionAlgorithms),e.compressionAlgorithmsServerToClient),this.isClientSession){this.exchangeContext.serverKexInitPayload=e.toBuffer();const i=!!this.exchangeContext.exchangeValue,n=this.exchangeContext.keyExchange===(null===(s=a.keyExchangeAlgorithms[0])||void 0===s?void 0:s.name);if(!i||!n){const e=a.getKeyExchangeAlgorithm(this.exchangeContext.keyExchange);this.exchangeContext.exchange=e.createKeyExchange(),this.exchangeContext.exchangeValue=await this.exchangeContext.exchange.startKeyExchange();const s=new h.KeyExchangeDhInitMessage;s.e=this.exchangeContext.exchangeValue,await this.session.sendMessage(s,t)}c=w}else{if(e.firstKexPacketFollows){const t=this.exchangeContext.keyExchange===(null===(i=e.keyExchangeAlgorithms)||void 0===i?void 0:i[0]),s=t?"correct":"incorrect";this.trace(y.TraceLevel.Verbose,y.SshTraceEventIds.algorithmNegotiation,`Client's KeyExchange guess was ${s}.`),this.exchangeContext.discardGuessedInit=!t,t&&this.session.remoteVersion.isVsSsh&&(null===(n=this.session.remoteVersion.version)||void 0===n?void 0:n.startsWith("2."))&&((null===(r=e.keyExchangeAlgorithms)||void 0===r?void 0:r[0])===(null===(o=a.keyExchangeAlgorithms[0])||void 0===o?void 0:o.name)||(this.trace(y.TraceLevel.Verbose,y.SshTraceEventIds.algorithmNegotiation,"Ignoring correct guess for compatibility with older client."),this.exchangeContext.discardGuessedInit=!0))}this.exchangeContext.clientKexInitPayload=e.toBuffer(),c=S}this.isInitialExchange&&e.keyExchangeAlgorithms.includes(c)&&await this.session.sendExtensionInfo(t)}async handleDhInitMessage(e,t){var s,i,n,o,a,c,l;if(this.isClientSession)return;const u=this.session;if(!this.exchangeContext||!this.exchangeContext.keyExchange||!this.exchangeContext.publicKey)throw new d.SshConnectionError("Key exchange not started.",p.SshDisconnectReason.protocolError);if(this.exchangeContext.discardGuessedInit)return void(this.exchangeContext.discardGuessedInit=!1);const m=this.session.config.getKeyExchangeAlgorithm(this.exchangeContext.keyExchange);if(!m)throw new d.SshConnectionError("Key exchange not supported for algorithm: "+this.exchangeContext.keyExchange,p.SshDisconnectReason.keyExchangeFailed);const y=this.session.config.getPublicKeyAlgorithm(this.exchangeContext.publicKey);if(!y)throw new d.SshConnectionError("Public key algorithm not supported: "+this.exchangeContext.publicKey,p.SshDisconnectReason.keyExchangeFailed);let v=null;if(null===(s=u.credentials)||void 0===s?void 0:s.publicKeys){const e=u.credentials.publicKeys.find((e=>e.keyAlgorithmName===y.keyAlgorithmName));if(v=null!=e?e:null,!1===(null==v?void 0:v.hasPrivateKey)){if(!u.credentials.privateKeyProvider)throw new Error("A private key provider is required.");v=await u.credentials.privateKeyProvider(e,null!=t?t:g.CancellationToken.None)}}if(null==v)throw new d.SshConnectionError("Private key not found for algorithm: "+this.exchangeContext.publicKey,p.SshDisconnectReason.keyExchangeFailed);const w=this.session.config.getEncryptionAlgorithm(this.exchangeContext.clientEncryption),S=this.session.config.getEncryptionAlgorithm(this.exchangeContext.serverEncryption),b=this.session.config.getHmacAlgorithm(this.exchangeContext.serverHmac),E=this.session.config.getHmacAlgorithm(this.exchangeContext.clientHmac),C=m.createKeyExchange(),R=e.e||r.Buffer.alloc(0),P=await C.startKeyExchange(),T=await C.decryptKeyExchange(R),k=await v.getPublicKeyBytes(y.name);if(!k)throw new d.SshConnectionError("Public key not set.",p.SshDisconnectReason.keyExchangeFailed);const x=await this.computeExchangeHash(C,k,R,P,T);this.session.sessionId||(this.session.sessionId=x);const[A,M,B,I,_,O]=await this.computeKeys(C,T,x,w,S,E,b),q=null!==(i=await(null==S?void 0:S.createCipher(!0,I,M)))&&void 0!==i?i:null,L=null!==(n=await(null==w?void 0:w.createCipher(!1,B,A)))&&void 0!==n?n:null,F=null!==(o=await(null==b?void 0:b.createSigner(O)))&&void 0!==o?o:null,N=null!==(a=await(null==E?void 0:E.createVerifier(_)))&&void 0!==a?a:null,D=new f.SshSessionAlgorithms;D.publicKeyAlgorithmName=this.exchangeContext.publicKey,D.cipher=q,D.decipher=L,D.signer=F,D.verifier=N,D.messageSigner=(null===(c=q)||void 0===c?void 0:c.authenticatedEncryption)?q:F,D.messageVerifier=(null===(l=L)||void 0===l?void 0:l.authenticatedEncryption)?L:N,D.compressor=this.session.config.getCompressionAlgorithm(this.exchangeContext.serverCompression),D.decompressor=this.session.config.getCompressionAlgorithm(this.exchangeContext.clientCompression),this.exchangeContext.newAlgorithms=D,A&&A.fill(0),B&&B.fill(0),_&&_.fill(0),M&&M.fill(0),I&&I.fill(0),O&&O.fill(0);const K=y.createSigner(v);let j=await K.sign(x);j=y.createSignatureData(j);const $=new h.KeyExchangeDhReplyMessage;$.hostKey=k,$.f=P,$.signature=j,await this.session.sendMessage($,t),await this.session.sendMessage(new h.NewKeysMessage,t)}async handleDhReplyMessage(e,t){var s,i,n,r,o,a;if(!this.isClientSession)return;if(!this.exchangeContext)throw new d.SshConnectionError("Key exchange was not started.",p.SshDisconnectReason.protocolError);const c=this.session.config,l=this.exchangeContext.exchange,u=this.exchangeContext.publicKey,g=c.getPublicKeyAlgorithm(u),m=c.getEncryptionAlgorithm(this.exchangeContext.clientEncryption),v=c.getEncryptionAlgorithm(this.exchangeContext.serverEncryption),w=c.getHmacAlgorithm(this.exchangeContext.serverHmac),S=c.getHmacAlgorithm(this.exchangeContext.clientHmac),b=this.exchangeContext.exchangeValue,E=e.f;if(!l||!b)throw new d.SshConnectionError("Failed to initialize crypto after key exchange.",p.SshDisconnectReason.keyExchangeFailed);this.hostKey=g.createKeyPair(),await this.hostKey.setPublicKeyBytes(e.hostKey);const C=await l.decryptKeyExchange(E),R=e.hostKey,P=await this.computeExchangeHash(l,R,b,E,C),T=g.readSignatureData(e.signature),k=g.createVerifier(this.hostKey);let x;try{x=await k.verify(P,T)}catch(e){if(!(e instanceof Error))throw e;throw this.trace(y.TraceLevel.Error,y.SshTraceEventIds.serverAuthenticationFailed,`Server public key verification error: ${e.message}`,e),new d.SshConnectionError(`Server public key verification failed: ${e.message}`,p.SshDisconnectReason.hostKeyNotVerifiable)}if(!x)throw this.trace(y.TraceLevel.Warning,y.SshTraceEventIds.serverAuthenticationFailed,"Server public key verification failed."),new d.SshConnectionError("Server public key verification failed.",p.SshDisconnectReason.hostKeyNotVerifiable);this.trace(y.TraceLevel.Verbose,y.SshTraceEventIds.sessionAuthenticated,"Server public key verification succeeded."),null==this.session.sessionId&&(this.session.sessionId=P);const[A,M,B,I,_,O]=await this.computeKeys(l,C,P,m,v,S,w),q=null!==(s=await(null==m?void 0:m.createCipher(!0,B,A)))&&void 0!==s?s:null,L=null!==(i=await(null==v?void 0:v.createCipher(!1,I,M)))&&void 0!==i?i:null,F=null!==(n=await(null==S?void 0:S.createSigner(_)))&&void 0!==n?n:null,N=null!==(r=await(null==w?void 0:w.createVerifier(O)))&&void 0!==r?r:null,D=new f.SshSessionAlgorithms;D.publicKeyAlgorithmName=u,D.cipher=q,D.decipher=L,D.signer=F,D.verifier=N,D.messageSigner=(null===(o=q)||void 0===o?void 0:o.authenticatedEncryption)?q:F,D.messageVerifier=(null===(a=L)||void 0===a?void 0:a.authenticatedEncryption)?L:N,D.compressor=c.getCompressionAlgorithm(this.exchangeContext.clientCompression),D.decompressor=c.getCompressionAlgorithm(this.exchangeContext.serverCompression),this.exchangeContext.newAlgorithms=D,A&&A.fill(0),B&&B.fill(0),_&&_.fill(0),M&&M.fill(0),I&&I.fill(0),O&&O.fill(0),await this.session.sendMessage(new h.NewKeysMessage,t)}chooseAlgorithm(e,t,s){var i;let n,r;this.isClientSession?(n=s||[],r=t):(n=t,r=s||[]);const o=`${e} negotiation: Server (${n.join(", ")}) Client (${r.join(", ")})`;if(this.session.remoteVersion.isVsSsh&&(null===(i=this.session.remoteVersion.version)||void 0===i?void 0:i.startsWith("2."))){const e=n;n=r,r=e}for(let e of r)for(let t of n)if(t===e){const e=t;return this.trace(y.TraceLevel.Info,y.SshTraceEventIds.algorithmNegotiation,`${o} => ${e}`),e}throw new Error(`Failed ${o}`)}async computeExchangeHash(e,t,s,i,n){if(!this.session.remoteVersion)throw new Error("Key exchange not completed.");const a=new u.SshDataWriter(r.Buffer.alloc(2048));return this.isClientSession?(a.writeString(o.SshSession.localVersion.toString(),"ascii"),a.writeString(this.session.remoteVersion.toString(),"ascii")):(a.writeString(this.session.remoteVersion.toString(),"ascii"),a.writeString(o.SshSession.localVersion.toString(),"ascii")),a.writeBinary(this.exchangeContext.clientKexInitPayload),a.writeBinary(this.exchangeContext.serverKexInitPayload),a.writeBinary(t),a.writeBigInt(c.BigInt.fromBytes(s,{unsigned:!0})),a.writeBigInt(c.BigInt.fromBytes(i,{unsigned:!0})),a.writeBigInt(c.BigInt.fromBytes(n,{unsigned:!0})),await e.sign(a.toBuffer())}async computeKeys(e,t,s,i,n,o,a){var c,h;const l=new u.SshDataWriter(r.Buffer.alloc(4+t.length+s.length+Math.max(1+(null!==(h=null===(c=this.session.sessionId)||void 0===c?void 0:c.length)&&void 0!==h?h:0),e.digestLength)));l.writeBinary(t),l.write(s);const d=l.position;return[i&&await this.computeKey(e,l,d,i.blockLength,"A"),n&&await this.computeKey(e,l,d,n.blockLength,"B"),i&&await this.computeKey(e,l,d,i.keyLength,"C"),n&&await this.computeKey(e,l,d,n.keyLength,"D"),o&&await this.computeKey(e,l,d,o.keyLength,"E"),a&&await this.computeKey(e,l,d,a.keyLength,"F")]}async computeKey(e,t,s,i,n){const o=r.Buffer.alloc(i);let a=0,c=0,h=null;if(!this.session.sessionId)throw new Error("Session ID not set.");for(;a<i;)t.position=s,h?t.write(h):(t.writeByte(n.charCodeAt(0)),t.write(this.session.sessionId)),h=await e.sign(t.toBuffer()),c=Math.min(h.length,i-a),h.copy(o,a),a+=c;return h&&h.fill(0),o}};b.serviceName="ssh-keyexchange",b=i=n([(0,m.serviceActivation)({serviceRequest:i.serviceName})],b),t.KeyExchangeService=b},4670:(e,t)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.findService=t.serviceActivation=void 0,t.serviceActivation=function(e){return t=>{t.activations||(t.activations=[]),t.activations.push(e)}},t.findService=function(e,t){for(let s of e.keys()){const e=s.activations;let i=!1;for(let n of e)if(i=!0,t(n))return s;if(!i)throw new Error(`SSH service type '${s.name}' must have one or more 'serviceActivation' decorators.`)}return null}},447:(e,t,s)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.SshService=void 0;const i=s(3730),n=s(7395);t.SshService=class{constructor(e){if(this.session=e,this.disposed=!1,this.disposedEmitter=new i.Emitter,this.onDisposed=this.disposedEmitter.event,!(e instanceof n.SshSession))throw new TypeError("Session is not an instance of SshSession. (This may be due to a version mismatch between SSH packages.)")}get trace(){return this.session.trace}dispose(){this.disposed||(this.disposed=!0,this.disposedEmitter.fire())}async onSessionRequest(e,t){this.session.raiseSessionRequest(e)}async onChannelOpening(e,t){if(!e)throw new TypeError("Request is required.");return this.session.handleChannelOpening(e,t,!1)}async onChannelRequest(e,t,s){}async sendMessage(e,t){await this.session.sendMessage(e,t)}}},4756:(e,t,s)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.SshChannel=void 0;const i=s(3730),n=s(4670),r=s(5757),o=s(818),a=s(5321),c=s(3708),h=s(2917),l=s(6002),u=s(3229),d=s(7437),p=s(4564),f=s(3776),g=s(6356);class m{constructor(e,t,s,n,r,o){this.connectionService=e,this.channelType=t,this.remoteChannelId=s,this.remoteWindowSize=n,this.remoteMaxPacketSize=r,this.channelId=o,this.remoteClosed=!1,this.localClosed=!1,this.sentEof=!1,this.disposed=!1,this.openSendingWindowCompletionSource=null,this.requestCompletionSource=null,this.sendSemaphore=new p.Semaphore(0),this.metrics=new a.ChannelMetrics,this.dataReceivedEmitter=new i.Emitter,this.onDataReceived=this.dataReceivedEmitter.event,this.eofEmitter=new i.Emitter,this.onEof=this.eofEmitter.event,this.closedEmitter=new i.Emitter,this.onClosed=this.closedEmitter.event,this.requestEmitter=new i.Emitter,this.onRequest=this.requestEmitter.event,this.windowSize=m.initialWindowSize,this.maxPacketSize=m.dataPacketSize}get session(){return this.connectionService.session}get isClosed(){return this.localClosed||this.remoteClosed}async request(e,t){if(!e)throw new TypeError("Request is required.");if(this.disposed)throw new h.ObjectDisposedError(this);if(e.recipientChannel=this.remoteChannelId,!e.wantReply)return await this.session.sendMessage(e,t),!0;if(null!=this.requestCompletionSource)throw new Error("Another request is already pending.");const s=new c.PromiseCompletionSource;if(this.requestCompletionSource=s,t){if(t.isCancellationRequested)throw new d.CancellationError;t.onCancellationRequested((()=>{s.reject(new d.CancellationError)}))}return await this.session.sendMessage(e,t),await s.promise}async send(e,t){if(this.disposed)throw new h.ObjectDisposedError(this);if(0!==e.length){if(this.sentEof)throw new Error("Cannot send more data after EOF.");await this.sendSemaphore.wait(t);try{let s=0,i=e.length;for(;i>0;){let n=Math.min(Math.min(this.remoteWindowSize,this.remoteMaxPacketSize),i);for(;0===n;)this.openSendingWindowCompletionSource||(this.openSendingWindowCompletionSource=new c.PromiseCompletionSource),this.session.trace(f.TraceLevel.Warning,f.SshTraceEventIds.channelWaitForWindowAdjust,`${this} send window is full. Waiting for window adjustment before sending.`),await(0,d.withCancellation)(this.openSendingWindowCompletionSource.promise,t),this.openSendingWindowCompletionSource=null,n=Math.min(Math.min(this.remoteWindowSize,this.remoteMaxPacketSize),i);const o=new r.ChannelDataMessage;o.recipientChannel=this.remoteChannelId,o.data=Buffer.from(e.slice(s,s+n)),await this.session.sendMessage(o,t),this.remoteWindowSize-=n,i-=n,s+=n,this.metrics.addBytesSent(n)}}finally{this.sendSemaphore.tryRelease()}}else await this.sendEof()}enableSending(){this.sendSemaphore.tryRelease()}async sendEof(e){if(!this.sentEof){await this.sendSemaphore.wait(e);try{this.sentEof=!0;const t=new r.ChannelEofMessage;t.recipientChannel=this.remoteChannelId,await this.session.sendMessage(t,e)}finally{this.sendSemaphore.tryRelease()}}}async handleRequest(e,t){if(!e.requestType)throw new h.SshConnectionError("Channel request type not specified.",o.SshDisconnectReason.protocolError);if(e.requestType===r.ChannelRequestType.exitStatus){const t=new r.ChannelSignalMessage;return e.convertTo(t),this.exitStatus=t.exitStatus,!0}if(e.requestType===r.ChannelRequestType.exitSignal){const t=new r.ChannelSignalMessage;return e.convertTo(t),this.exitSignal=t.exitSignal,this.exitErrorMessage=t.errorMessage,!0}if(e.requestType===r.ChannelRequestType.signal){const t=new r.ChannelSignalMessage;e.convertTo(t)}const s=new l.SshRequestEventArgs(e.requestType,e,this.session.principal,t),i=(0,n.findService)(this.session.config.services,(t=>(!t.channelType||t.channelType===this.channelType)&&t.channelRequest===e.requestType));await this.sendSemaphore.wait(t);try{let n=null;if(i){const e=this.session.activateService(i);await e.onChannelRequest(this,s,t)}else this.requestEmitter.fire(s);s.responsePromise&&(n=await s.responsePromise,s.isAuthorized=n instanceof r.ChannelSuccessMessage),e.wantReply&&(s.isAuthorized?(n=null!=n?n:new r.ChannelSuccessMessage,n.recipientChannel=this.remoteChannelId):(n=null!=n?n:new r.ChannelFailureMessage,n.recipientChannel=this.remoteChannelId),await this.session.sendMessage(n,t))}finally{this.sendSemaphore.tryRelease()}return s.isAuthorized||!1}handleResponse(e){this.requestCompletionSource&&(this.requestCompletionSource.resolve(e),this.requestCompletionSource=null)}handleDataReceived(e){this.metrics.addBytesReceived(e.length),this.dataReceivedEmitter.fire(e)}adjustWindow(e){if(!this.disposed&&(this.windowSize-=e,this.windowSize<=this.maxPacketSize)){const e=new r.ChannelWindowAdjustMessage;e.recipientChannel=this.remoteChannelId,e.bytesToAdd=m.initialWindowSize-this.windowSize,this.windowSize=m.initialWindowSize,this.session.sendMessage(e).catch((e=>{this.session.trace(f.TraceLevel.Error,f.SshTraceEventIds.channelWindowAdjustFailed,`Error sending window adjust message: ${e.message}`,e)}))}}adjustRemoteWindow(e){this.remoteWindowSize+=e,this.openSendingWindowCompletionSource&&this.openSendingWindowCompletionSource.resolve(void 0)}handleEof(){this.session.trace(f.TraceLevel.Info,f.SshTraceEventIds.channelEofReceived,`${this} EOF received.`),this.eofEmitter.fire()}close(e,t,s){if(e instanceof Error){const t=e;return this.localClosed||(this.localClosed=!0,this.session.trace(f.TraceLevel.Info,f.SshTraceEventIds.channelClosed,`${this} Closed: ${t.message}`),this.closedEmitter.fire(new u.SshChannelClosedEventArgs(t))),void this.disposeInternal()}return"number"==typeof e?this.closeWithStatus(e,t):"string"==typeof e?this.closeWithSignal(e,t,s):this.closeDefault(e)}async closeDefault(e){var t;if(!this.remoteClosed&&!this.localClosed){this.remoteClosed=!0,await this.sendSemaphore.wait(e);try{const e=new r.ChannelCloseMessage;e.recipientChannel=this.remoteChannelId,await this.session.sendMessage(e)}catch(e){}finally{this.sendSemaphore.tryRelease()}}if(!this.localClosed){this.localClosed=!0;const e=this.raiseClosedEvent();null===(t=this.requestCompletionSource)||void 0===t||t.reject(new h.SshChannelError(e))}this.disposeInternal()}async closeWithStatus(e,t){if(!this.remoteClosed&&!this.localClosed){this.exitStatus=e;const t=new r.ChannelSignalMessage;t.recipientChannel=this.remoteChannelId,t.exitStatus=e,await this.session.sendMessage(t)}await this.closeDefault(t)}async closeWithSignal(e,t,s){if(!this.remoteClosed&&!this.localClosed){this.exitSignal=e,this.exitErrorMessage=t;const s=new r.ChannelSignalMessage;s.recipientChannel=this.remoteChannelId,s.exitSignal=e,s.errorMessage=t,await this.session.sendMessage(s)}await this.closeDefault(s)}handleClose(){var e;if(!this.localClosed){this.localClosed=!0;const t=this.raiseClosedEvent(!0);null===(e=this.requestCompletionSource)||void 0===e||e.reject(new h.SshChannelError(t))}this.disposeInternal()}raiseClosedEvent(e=!1){const t=` (S: ${this.metrics.bytesSent}, R: ${this.metrics.bytesReceived})`,s=e?"remotely":"locally";let i,n;return void 0!==this.exitStatus?(n=new u.SshChannelClosedEventArgs(this.exitStatus),i=`${this} closed ${s}: status=${this.exitStatus}`):void 0!==this.exitSignal?(n=new u.SshChannelClosedEventArgs(this.exitSignal,this.exitErrorMessage),i=`${this} closed ${s}: signal=${this.exitSignal} ${this.exitErrorMessage}`):(n=new u.SshChannelClosedEventArgs,i=`${this} closed ${s}.`),this.session.trace(f.TraceLevel.Info,f.SshTraceEventIds.channelClosed,i+t),this.closedEmitter.fire(n),i}dispose(){var e;if(!this.disposed&&!this.localClosed){if(!this.remoteClosed){this.remoteClosed=!0;const e=new r.ChannelCloseMessage;e.recipientChannel=this.remoteChannelId,this.session.sendMessage(e).catch((e=>{}))}const t=this.session.isClosed?`${this.session} closed.`:`${this} disposed.`;this.session.trace(f.TraceLevel.Info,f.SshTraceEventIds.channelClosed,t);const s=new u.SshChannelClosedEventArgs("SIGABRT",t);this.localClosed=!0,this.closedEmitter.fire(s),null===(e=this.requestCompletionSource)||void 0===e||e.reject(new h.SshChannelError(t))}this.disposeInternal()}disposeInternal(){var e;this.disposed||(this.disposed=!0,null===(e=this.requestCompletionSource)||void 0===e||e.reject(new h.ObjectDisposedError(this)),this.connectionService._removeChannel(this),this.sendSemaphore.dispose())}pipe(e){return g.PipeExtensions.pipeChannel(this,e)}toString(){return`SshChannel(Type: ${this.channelType}, Id: ${this.channelId}, RemoteId: ${this.remoteChannelId})`}}t.SshChannel=m,m.sessionChannelType="session",m.dataPacketSize=32768,m.initialWindowSize=32*m.dataPacketSize},1485:(e,t,s)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.SshClientSession=void 0;const i=s(7395),n=s(818),r=s(8047),o=s(3708),a=s(7437),c=s(7183),h=s(6502),l=s(7165),u=s(2917),d=s(3776);class p extends i.SshSession{constructor(e){super(e,!0),this.serviceRequests=new Map,this.clientAuthCompletion=null}async authenticate(e,t){return!!await this.authenticateServer(t)&&!!await this.authenticateClient(e,t)}async authenticateServer(e){if(!this.kexService||!this.kexService.hostKey)throw new Error("Encrypt the session before authenticating.");try{this.principal=await this.raiseAuthenticatingEvent(new r.SshAuthenticatingEventArgs(r.SshAuthenticationType.serverPublicKey,{publicKey:this.kexService.hostKey},e))}catch(e){if(!(e instanceof Error))throw e;throw this.trace(d.TraceLevel.Error,d.SshTraceEventIds.authenticationError,`Error while authenticating server: ${e.message}`,e),e}return this.principal?(this.trace(d.TraceLevel.Info,d.SshTraceEventIds.sessionAuthenticated,`${this} server authenticated.`),!0):(await this.close(n.SshDisconnectReason.hostKeyNotVerifiable,"Server authentication failed."),this.trace(d.TraceLevel.Warning,d.SshTraceEventIds.serverAuthenticationFailed,`${this} server authentication failed.`),!1)}authenticateClient(e,t,s){if(!e)throw new TypeError("A credentials object is required.");return"function"==typeof t?this.authenticateClientWithCompletion(e,t,s):new Promise((async(s,i)=>{await this.authenticateClientWithCompletion(e,((e,t)=>{e?i(e):s(t)}),t)}))}async authenticateClientWithCompletion(e,t,s){if(this.clientAuthCompletion=new o.PromiseCompletionSource,this.clientAuthCompletion.promise.then((e=>t(void 0,e)),(e=>t(e))),s){if(s.isCancellationRequested)throw new a.CancellationError;s.onCancellationRequested((e=>{this.clientAuthCompletion&&this.clientAuthCompletion.reject(new a.CancellationError)}))}let i=this.getService(h.AuthenticationService);if(!i){const e=new n.ServiceRequestMessage;e.serviceName=h.AuthenticationService.serviceName,await this.sendMessage(e,s),i=this.activateService(h.AuthenticationService)}await i.authenticateClient(e,s)}onAuthenticationComplete(e){e?this.trace(d.TraceLevel.Info,d.SshTraceEventIds.sessionAuthenticated,`${this} client authenticated.`):this.trace(d.TraceLevel.Warning,d.SshTraceEventIds.clientAuthenticationFailed,`${this} client authentication failed.`),this.clientAuthCompletion&&(this.clientAuthCompletion.resolve(e),this.clientAuthCompletion=null)}async requestService(e,t){let s=!1,i=this.serviceRequests.get(e);if(i||(i=new o.PromiseCompletionSource,this.serviceRequests.set(e,i),s=!0),s){const s=new n.ServiceRequestMessage;s.serviceName=e,await this.sendMessage(s,t)}await i.promise}async handleServiceAcceptMessage(e,t){const s=this.serviceRequests.get(e.serviceName);null==s||s.resolve(!0)}async openChannel(e,t,s){if(!this.connectionService){const e=new n.ServiceRequestMessage;e.serviceName=l.ConnectionService.serviceName,await this.sendMessage(e,s)}return await super.openChannel(e,t,s)}handleDisconnected(){return this.reconnecting?(this.reconnecting=!1,!1):super.handleDisconnected()}async reconnect(e,t){if(this.trace(d.TraceLevel.Verbose,d.SshTraceEventIds.clientSessionReconnecting,"Attempting to reconnect..."),this.isClosed)throw new u.ObjectDisposedError(this);if(this.isConnected)throw new Error("Already connected.");if(!this.protocol)throw new Error("The session was never previously connected.");if(this.reconnecting)throw new Error("Already reconnecting.");this.reconnecting=!0;try{await this.reconnectInternal(e,t)}finally{this.reconnecting=!1}}async reconnectInternal(e,t){var s,i,r,o,a,h;const l=this.sessionId,p=this.protocol,f=null===(s=this.kexService)||void 0===s?void 0:s.hostKey;if(!(l&&p&&this.kexService&&f&&(null===(i=p.extensions)||void 0===i?void 0:i.has(c.SshProtocolExtensionNames.sessionReconnect))))throw new Error("Reconnect was not enabled for this session.");let g;try{if(this.sessionId=null,await this.connect(e,t),!this.sessionId||!this.algorithms||!this.algorithms.signer)throw new Error("Session is not encrypted.");const s=this.kexService.hostKey,i=s?await s.getPublicKeyBytes():null,r=await f.getPublicKeyBytes();if(!i||!r||!i.equals(r)){const e="The server host key is different.";throw this.trace(d.TraceLevel.Error,d.SshTraceEventIds.clientSessionReconnectFailed,`Reconnection failed: ${e}`),new u.SshReconnectError(e,n.SshReconnectFailureReason.differentServerHostKey)}g=this.sessionId}catch(e){throw this.protocol=p,super.handleDisconnected(),e}finally{this.sessionId=l,this.kexService.hostKey=f}const m=await this.createReconnectToken(l,g),y=new n.SessionReconnectRequestMessage;y.requestType="session-reconnect@microsoft.com",y.clientReconnectToken=m,y.lastReceivedSequenceNumber=p.lastIncomingSequence,y.wantReply=!0;const v=await this.requestResponse(y,n.SessionReconnectResponseMessage,n.SessionReconnectFailureMessage,t);if(v instanceof n.SessionReconnectFailureMessage){const e=null!==(r=v.reasonCode)&&void 0!==r?r:n.SshReconnectFailureReason.unknownServerFailure,t=null!==(o=v.description)&&void 0!==o?o:"The server rejected the reconnect request.";throw this.trace(d.TraceLevel.Error,d.SshTraceEventIds.clientSessionReconnectFailed,`Reconnection failed: ${t}`),this.protocol=p,new u.SshReconnectError(t,e)}if(!this.verifyReconnectToken(l,g,null!==(a=v.serverReconnectToken)&&void 0!==a?a:Buffer.alloc(0))){const e="The reconnect token provided by the server was invalid.";throw this.trace(d.TraceLevel.Error,d.SshTraceEventIds.clientSessionReconnectFailed,`Reconnection failed: ${e}`),new u.SshReconnectError(e,n.SshReconnectFailureReason.invalidServerReconnectToken)}this.trace(d.TraceLevel.Info,d.SshTraceEventIds.clientSessionReconnecting,"Reconnect request was accepted by the server.");const w=p.getSentMessages((null!==(h=v.lastReceivedSequenceNumber)&&void 0!==h?h:0)+1);if(!w){const e="Client is unable to re-send messages requested by the server.";throw this.trace(d.TraceLevel.Error,d.SshTraceEventIds.clientSessionReconnectFailed,`Reconnection failed: ${e}`),new u.SshReconnectError(e,n.SshReconnectFailureReason.clientDroppedMessages)}let S=0;for(let e of w)await this.sendMessage(e,t),S++;p.dispose(),this.metrics.addReconnection(),this.trace(d.TraceLevel.Info,d.SshTraceEventIds.clientSessionReconnecting,`{this} reconnected. Re-sent ${S} dropped messages.`)}dispose(){this.clientAuthCompletion&&this.clientAuthCompletion.reject(new u.ObjectDisposedError(this)),super.dispose()}}t.SshClientSession=p},6521:(e,t,s)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.SshRpcMessageStream=void 0;const i=s(3730),n=s(4300),r=s(7914),o="Content-Length: ",a="\r\n\r\n";class c{constructor(e){this.channel=e,this.errorEmitter=new i.Emitter,this.closeEmitter=new i.Emitter,this.partialMessageEmitter=new i.Emitter,this.callback=null,this.messageBuffer=new r.SshDataWriter(n.Buffer.alloc(1024)),this.headersLength=null,this.messageLength=null,this.onError=this.errorEmitter.event,this.onClose=this.closeEmitter.event,this.onPartialMessage=this.partialMessageEmitter.event,this.eventRegistration=this.channel.onDataReceived(this.onDataReceived.bind(this)),this.channel.onClosed((e=>{e.error&&this.errorEmitter.fire(e.error),this.closeEmitter.fire()}))}listen(e){this.callback=e}dispose(){this.eventRegistration&&this.eventRegistration.dispose()}onDataReceived(e){if(this.messageBuffer.write(e),this.channel.adjustWindow(e.length),e=this.messageBuffer.toBuffer(),null===this.messageLength){const t=e.indexOf(a);if(t<0)return;const s=e.slice(0,t).toString();if(!s.startsWith(o))throw new Error(`Message does not start with JSON-RPC headers.\n${s}`);this.headersLength=t+a.length,this.messageLength=parseInt(s.substr(o.length,t-o.length),10)}const t=this.messageBuffer.position,s=this.headersLength+this.messageLength;if(t>=s){if(this.callback){const t=e.slice(this.headersLength,s).toString();let i;try{i=JSON.parse(t)}catch(e){if(!(e instanceof Error))throw e;throw new Error(`Failed to parse JSON-RPC message: ${e.message}\n${t}`)}this.callback(i)}this.messageLength=null,this.messageBuffer.position=0,t>s&&this.onDataReceived(e.slice(s))}}}class h{constructor(e){this.channel=e,this.errorEmitter=new i.Emitter,this.closeEmitter=new i.Emitter,this.onError=this.errorEmitter.event,this.onClose=this.closeEmitter.event,this.channel.onClosed((e=>{e.error&&this.errorEmitter.fire([e.error,e.errorMessage&&{jsonrpc:e.errorMessage}||void 0,e.exitStatus]),this.closeEmitter.fire()}))}write(e){const t=JSON.stringify(e),s=n.Buffer.from(t),i=n.Buffer.from(o+s.length+a),r=n.Buffer.alloc(i.length+s.length);i.copy(r,0),s.copy(r,i.length),this.channel.send(r).catch((e=>{this.errorEmitter.fire([e,void 0,void 0])}))}dispose(){}}t.SshRpcMessageStream=class{constructor(e){this.reader=new c(e),this.writer=new h(e)}}},1410:(e,t,s)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.SshServerSession=void 0;const i=s(7395),n=s(3730),r=s(818),o=s(2917),a=s(7183),c=s(3776);class h extends i.SshSession{constructor(e,t){super(e,!1),this.clientAuthenticatedEmitter=new n.Emitter,this.onClientAuthenticated=this.clientAuthenticatedEmitter.event,this.reconnectedEmitter=new n.Emitter,this.onReconnected=this.reconnectedEmitter.event,this.credentials={publicKeys:[]};const s=e.protocolExtensions.includes(a.SshProtocolExtensionNames.sessionReconnect);if(s&&!t)throw new Error("When reconnect is enabled, server sessions require a reference to a shared collection to track reconnectable sessions.");if(!s&&t)throw new Error("When reconnect is not enabled, the reconnectable sessions collection is not applicable.");this.reconnectableSessions=t}async handleServiceRequestMessage(e,t){if(!this.activateService(e.serviceName))throw new o.SshConnectionError(`Service "${e.serviceName}" not available.`,r.SshDisconnectReason.serviceNotAvailable);{const s=new r.ServiceAcceptMessage;s.serviceName=e.serviceName,await this.sendMessage(s,t)}}async handleRequestMessage(e,t){var s;if("session-reconnect@microsoft.com"===e.requestType&&(null===(s=this.config.protocolExtensions)||void 0===s?void 0:s.includes(a.SshProtocolExtensionNames.sessionReconnect))){const s=e.convertTo(new r.SessionReconnectRequestMessage);await this.reconnect(s,t)}else await super.handleRequestMessage(e,t)}handleClientAuthenticated(){this.clientAuthenticatedEmitter.fire()}async enableReconnect(e){await super.enableReconnect(e),this.reconnectableSessions.includes(this)||this.reconnectableSessions.push(this)}handleDisconnected(){return!!this.reconnecting||super.handleDisconnected()}async reconnect(e,t){var s,i,n;if(!this.reconnectableSessions)throw new Error("Disconnected sessions collection should have been initialied when reconnect is enabled.");let o;for(let t of this.reconnectableSessions)if(t!==this&&await this.verifyReconnectToken(t.sessionId,this.sessionId,null!==(s=e.clientReconnectToken)&&void 0!==s?s:Buffer.alloc(0))){o=t,this.reconnectableSessions.splice(this.reconnectableSessions.indexOf(o),1);break}if(!o||o.isClosed){const e="Requested reconnect session was not found or the reconnect token provided by the client was invalid.";this.trace(c.TraceLevel.Error,c.SshTraceEventIds.serverSessionReconnectFailed,`Reconnect failed: ${e}`);const s=new r.SessionReconnectFailureMessage;return s.reasonCode=r.SshReconnectFailureReason.sessionNotFound,s.description=e,void await this.sendMessage(s,t)}const a=o.protocol.getSentMessages((null!==(i=e.lastReceivedSequenceNumber)&&void 0!==i?i:0)+1);if(!a){this.reconnectableSessions.push(o);const e="Server is unable to re-send messages requested by the client.";this.trace(c.TraceLevel.Error,c.SshTraceEventIds.serverSessionReconnectFailed,`Reconnect failed: ${e}`);const s=new r.SessionReconnectFailureMessage;return s.reasonCode=r.SshReconnectFailureReason.serverDroppedMessages,s.description=e,void await this.sendMessage(s,t)}const h=new r.SessionReconnectResponseMessage;h.serverReconnectToken=await this.createReconnectToken(o.sessionId,this.sessionId),h.lastReceivedSequenceNumber=o.protocol.lastIncomingSequence,await this.sendMessage(h,t);try{for(o.reconnecting=!0,null===(n=o.protocol)||void 0===n||n.dispose();o.isConnected;)await new Promise((e=>setTimeout((()=>e()),5)));o.protocol=this.protocol,o.protocol.kexService=o.kexService,this.protocol=void 0;for(let e of a)await o.sendMessage(e,t);this.dispose()}finally{o.reconnecting=!1}this.reconnectableSessions.push(o),o.metrics.addReconnection(),o.processMessages().catch((e=>{this.trace(c.TraceLevel.Error,c.SshTraceEventIds.unknownError,`Unhandled error processing messages: ${e.message}`,e)})),this.trace(c.TraceLevel.Info,c.SshTraceEventIds.serverSessionReconnecting,`${o} reconnected. Re-sent ${a.length} dropped messages.`),o.reconnectedEmitter.fire()}dispose(){if(this.reconnectableSessions){const e=this.reconnectableSessions.indexOf(this);e>=0&&this.reconnectableSessions.splice(e,1)}super.dispose()}}t.SshServerSession=h},7395:(e,t,s)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.SshSession=void 0;const i=s(3776),n=s(4300),r=s(3730),o=s(7183),a=s(4756),c=s(7505),h=s(7585),l=s(3210),u=s(4670),d=s(7165),p=s(6502),f=s(285),g=s(856),m=s(5757),y=s(450),v=s(818),w=s(3965),S=s(3708),b=s(3068),E=s(6002),C=s(1605),R=s(7437),P=s(2917),T=s(4564),k=s(6356);class x{constructor(e,t){if(this.config=e,this.remoteVersion=null,this.activatedServices=new Map,this.connectionService=null,this.requestHandler=null,this.blockedMessages=[],this.blockedMessagesSemaphore=new T.Semaphore(1),this.connected=!1,this.disposed=!1,this.metrics=new w.SessionMetrics,this.reconnecting=!1,this.sessionId=null,this.principalValue=null,this.authenticatingEmitter=new r.Emitter,this.onAuthenticating=this.authenticatingEmitter.event,this.closedEmitter=new r.Emitter,this.onClosed=this.closedEmitter.event,this.disconnectedEmitter=new r.Emitter,this.onDisconnected=this.disconnectedEmitter.event,this.serviceActivatedEmitter=new r.Emitter,this.onServiceActivated=this.serviceActivatedEmitter.event,this.channelOpeningEmitter=new r.Emitter,this.onChannelOpening=this.channelOpeningEmitter.event,this.requestEmitter=new r.Emitter,this.onRequest=this.requestEmitter.event,this.trace=(e,t,s,i)=>{},!e)throw new TypeError("Session configuration is required.");if(e.keyExchangeAlgorithms.find((e=>!!e)))this.kexService=new l.KeyExchangeService(this,null!=t&&t);else{if(e.encryptionAlgorithms.length>0&&e.encryptionAlgorithms.indexOf(null)<0)throw new Error("Encryption requires a key-exchange algorithm to be configured.");if(e.hmacAlgorithms.length>0&&e.hmacAlgorithms.indexOf(null)<0)throw new Error("HMAC requires a key-exchange algorithm to be configured.");if(e.publicKeyAlgorithms.length>0&&e.publicKeyAlgorithms.indexOf(null)<0)throw new Error("Host authentication requires a key-exchange algorithm to be configured.");this.kexService=null}e.onConfigurationChanged((()=>{const t=this.protocol;t&&(t.traceChannelData=e.traceChannelData)}))}get algorithms(){return this.protocol?this.protocol.algorithms:null}get principal(){return this.principalValue}set principal(e){this.principalValue=e}get isConnected(){return this.connected}get isClosed(){return this.disposed}get services(){return[...this.activatedServices.values()]}get channels(){var e,t;return null!==(t=null===(e=this.connectionService)||void 0===e?void 0:e.channels)&&void 0!==t?t:[]}get protocolExtensions(){var e;return(null===(e=this.protocol)||void 0===e?void 0:e.extensions)||null}getService(e){return this.activatedServices.get(e)||null}activateService(e){let t;if("function"==typeof e)t=e;else{let s=e;if(t=(0,u.findService)(this.config.services,(e=>e.serviceRequest===s)),!t)return null}let s=this.activatedServices.get(t);if(!s){if(!this.config.services.has(t))throw new Error(`Service type not configured: ${t.name}`);s=new t(this,this.config.services.get(t)),t===d.ConnectionService&&(this.connectionService=s),this.activatedServices.set(t,s),this.serviceActivatedEmitter.fire(s)}return s}async connect(e,t){if(!e)throw new TypeError("A session stream is required.");if(this.disposed)throw new P.ObjectDisposedError(this);this.connectPromise||(this.connectPromise=this.doConnect(e,t)),await this.connectPromise}async doConnect(e,t){this.trace(i.TraceLevel.Info,i.SshTraceEventIds.sessionConnecting,`${this} ${this.reconnecting?"re":""}connecting...`),this.protocol=new h.SshProtocol(e,this.config,this.metrics,this.trace),this.protocol.kexService=this.kexService,await this.exchangeVersions(t),this.kexService?await this.encrypt(t):(await(0,R.withCancellation)(this.versionExchangePromise,t),this.connected=!0),this.processMessages().catch((e=>{this.trace(i.TraceLevel.Error,i.SshTraceEventIds.unknownError,`Unhandled error processing messages: ${e.message}`,e)}))}async exchangeVersions(e){const t=this.protocol.writeProtocolVersion(x.localVersion.toString(),e),s=this.protocol.readProtocolVersion(e);this.versionExchangePromise=s.then((async e=>{let t;this.trace(i.TraceLevel.Info,i.SshTraceEventIds.protocolVersion,`Local version: ${x.localVersion}, remote version: ${e}`);const s=c.SshVersionInfo.tryParse(e);if(s){if(this.remoteVersion=s,"2.0"===s.protocolVersion)return;t=`Remote SSH version ${this.remoteVersion} is not supported. This library only supports SSH v2.0.`}else t=`Could not parse remote SSH version ${e}`;await this.close(v.SshDisconnectReason.protocolVersionNotSupported,t,new Error(t))})),await t}async encrypt(e){var t,s;const n=this.protocol;if(!n)throw new P.ObjectDisposedError(this);await n.considerReExchange(!0,e),await(0,R.withCancellation)(this.versionExchangePromise,e),this.connected=!0;let r=null;for(;!(this.isClosed||(null===(t=this.protocol)||void 0===t?void 0:t.algorithms)||r instanceof v.DisconnectMessage)&&(r=await n.receiveMessage(e),r);)await this.handleMessage(r,e);if(!(null===(s=this.protocol)||void 0===s?void 0:s.algorithms))throw new P.SshConnectionError("Session closed while encrypting.",v.SshDisconnectReason.connectionLost);this.protocol.algorithms.cipher&&this.trace(i.TraceLevel.Info,i.SshTraceEventIds.sessionEncrypted,`${this} encrypted.`)}async processMessages(){var e;for(this.connected=!0;!this.disposed;){const t=this.protocol;if(!t)break;let s=null;try{s=await t.receiveMessage()}catch(t){if(!(t instanceof Error))throw t;let s=v.SshDisconnectReason.protocolError;t instanceof P.SshConnectionError?s=null!==(e=t.reason)&&void 0!==e?e:s:this.trace(i.TraceLevel.Error,i.SshTraceEventIds.receiveMessageFailed,`Error receiving message: ${t.message}`,t),await this.close(s,t.message,t)}if(!s){await this.close(v.SshDisconnectReason.connectionLost,"Connection lost.");break}try{await this.handleMessage(s)}catch(e){if(!(e instanceof Error))throw e;this.trace(i.TraceLevel.Error,i.SshTraceEventIds.handleMessageFailed,`Error handling ${s}: ${e.message}`,e),await this.close(v.SshDisconnectReason.protocolError,e.message,e)}}this.connected=!1}get canAcceptRequests(){var e;return!(this.kexService&&(!(null===(e=this.protocol)||void 0===e?void 0:e.algorithms)||this.protocol.algorithms.cipher&&!this.principal))}async sendMessage(e,t){var s,n;if(!e)throw new TypeError("Message expected.");if(t&&t.isCancellationRequested)throw new R.CancellationError;const r=this.protocol;if(!r||this.disposed)throw new P.ObjectDisposedError(this);if(this.kexService&&this.kexService.exchanging&&e.messageType>4&&(e.messageType<20||e.messageType>49))return void this.blockedMessages.push(e);let a;await this.blockedMessagesSemaphore.wait(t);try{a=await r.sendMessage(e,t),this.blockedMessagesSemaphore.release()}catch(t){if(this.blockedMessagesSemaphore.release(),t instanceof P.SshConnectionError&&t.reason===v.SshDisconnectReason.connectionLost&&(null===(s=this.protocolExtensions)||void 0===s?void 0:s.has(o.SshProtocolExtensionNames.sessionReconnect)))return;if(!(t instanceof Error))throw t;throw this.trace(i.TraceLevel.Error,i.SshTraceEventIds.sendMessageFailed,`Error sending ${e}: ${t.message}`,t),t}if(!a&&!(null===(n=this.protocolExtensions)||void 0===n?void 0:n.has(o.SshProtocolExtensionNames.sessionReconnect)))throw new P.SshConnectionError("Session disconnected.",v.SshDisconnectReason.connectionLost)}handleMessage(e,t){var s;if(e instanceof m.ConnectionMessage&&this.connectionService)return this.connectionService.handleMessage(e,t);if(e instanceof g.NewKeysMessage)return this.handleNewKeysMessage(e,t);if(e instanceof g.KeyExchangeMessage)return this.handleKeyExchangeMessage(e,t);if(e instanceof y.AuthenticationMessage)return null===(s=this.getService(p.AuthenticationService))||void 0===s?void 0:s.handleMessage(e,t);if(e instanceof v.ServiceRequestMessage)return this.handleServiceRequestMessage(e,t);if(e instanceof v.ServiceAcceptMessage)return this.handleServiceAcceptMessage(e,t);if(e instanceof v.SessionRequestMessage)return this.handleRequestMessage(e,t);if(e instanceof v.SessionRequestSuccessMessage)return this.handleRequestSuccessMessage(e);if(e instanceof v.SessionRequestFailureMessage)return this.handleRequestFailureMessage(e);if(e instanceof v.ExtensionInfoMessage)return this.handleExtensionInfoMessage(e,t);if(e instanceof v.DisconnectMessage)return this.handleDisconnectMessage(e);if(e instanceof v.UnimplementedMessage)return this.handleUnimplementedMessage(e,t);if(e instanceof v.DebugMessage)return this.handleDebugMessage(e);throw e instanceof f.SshMessage?new Error(`Unhandled message type: ${e.constructor.name}`):new TypeError("Message argument was "+(e?"invalid type.":"null."))}async handleRequestMessage(e,t){var s;let n=!1,r=null;if("initial-channel-request@microsoft.com"===e.requestType&&this.config.protocolExtensions.includes(o.SshProtocolExtensionNames.openChannelRequest)){const s=e.convertTo(new v.SessionChannelRequestMessage),i=s.senderChannel,r=this.channels.find((e=>e.remoteChannelId===i));r&&s.request&&(s.request.wantReply=!1,n=await r.handleRequest(s.request,t))}else if("enable-session-reconnect@microsoft.com"===e.requestType&&(null===(s=this.config.protocolExtensions)||void 0===s?void 0:s.includes(o.SshProtocolExtensionNames.sessionReconnect)))this.protocol.incomingMessagesHaveReconnectInfo||(this.protocol.incomingMessagesHaveReconnectInfo=!0,this.protocol.incomingMessagesHaveLatencyInfo=this.protocol.extensions.has(o.SshProtocolExtensionNames.sessionLatency),n=!0);else if(this.canAcceptRequests){const s=new E.SshRequestEventArgs(e.requestType||"",e,this.principal,t),i=(0,u.findService)(this.config.services,(t=>t.sessionRequest===e.requestType));if(i){const e=this.activateService(i);await e.onSessionRequest(s,t)}else this.raiseSessionRequest(s);s.responsePromise?(r=await s.responsePromise,n=r instanceof v.SessionRequestSuccessMessage):n=s.isAuthorized||!1}else this.trace(i.TraceLevel.Warning,i.SshTraceEventIds.sessionRequestFailed,"Session request blocked because the session is not yet authenticated."),n=!1;e.wantReply&&(n?r instanceof v.SessionRequestSuccessMessage||(r=new v.SessionRequestSuccessMessage):r instanceof v.SessionRequestFailureMessage||(r=new v.SessionRequestFailureMessage),await this.sendMessage(r,t))}raiseSessionRequest(e){this.requestEmitter.fire(e)}async handleServiceRequestMessage(e,t){}async handleServiceAcceptMessage(e,t){}async handleKeyExchangeMessage(e,t){if(!this.kexService){if(!(e instanceof g.KeyExchangeInitMessage&&this.protocol))return void await this.close(v.SshDisconnectReason.keyExchangeFailed);this.kexService=this.activateService(l.KeyExchangeService),this.protocol.kexService=this.kexService,await this.protocol.considerReExchange(!0,t)}return this.kexService.handleMessage(e,t)}async handleNewKeysMessage(e,t){try{await this.blockedMessagesSemaphore.wait(t),await this.protocol.handleNewKeys(t);try{for(;this.blockedMessages.length>0;){const e=this.blockedMessages.shift();if(!this.protocol)throw new P.ObjectDisposedError(this);await this.protocol.sendMessage(e,t)}}catch(e){if(!(e instanceof Error))throw e;await this.close(v.SshDisconnectReason.protocolError,void 0,e)}}finally{this.blockedMessagesSemaphore.release()}}async handleUnimplementedMessage(e,t){void 0!==e.unimplementedMessageType&&await this.sendMessage(e,t)}handleDebugMessage(e){e.message&&this.trace(e.alwaysDisplay?i.TraceLevel.Info:i.TraceLevel.Verbose,i.SshTraceEventIds.debugMessage,e.message)}async raiseAuthenticatingEvent(e){this.trace(i.TraceLevel.Info,i.SshTraceEventIds.sessionAuthenticating,`${this} Authenticating(${e})`),this.authenticatingEmitter.fire(e);let t=e.authenticationPromise;return t||(t=Promise.resolve(null)),await t}async request(e,t){if(!e)throw new TypeError("Request is required.");return e.wantReply?await this.requestResponse(e,v.SessionRequestSuccessMessage,v.SessionRequestFailureMessage,t)instanceof v.SessionRequestSuccessMessage:(await this.sendMessage(e,t),!0)}async requestResponse(e,t,s,i){if(!e)throw new TypeError("Request is required.");if(!t)throw new TypeError("Success response type is required.");if(!s)throw new TypeError("Failure response type is required.");if(this.requestHandler)throw new Error("Another request is already pending.");e.wantReply=!0;const n=new S.PromiseCompletionSource;if(i){if(i.isCancellationRequested)throw new R.CancellationError;i.onCancellationRequested((()=>{this.requestHandler=null,n.reject(new R.CancellationError)}))}return this.requestHandler=(e,i)=>{var r,o;if(this.requestHandler=null,e)n.reject(e);else if(i instanceof v.SessionRequestFailureMessage){const e=null!==(r=null==i?void 0:i.convertTo(new s,!0))&&void 0!==r?r:null;n.resolve(e)}else if(i instanceof v.SessionRequestSuccessMessage){const e=null!==(o=null==i?void 0:i.convertTo(new t,!0))&&void 0!==o?o:null;n.resolve(e)}else n.reject(new Error("Unknown response message type."))},await this.sendMessage(e,i),await n.promise}handleRequestSuccessMessage(e){this.requestHandler&&this.requestHandler(void 0,e)}handleRequestFailureMessage(e){this.requestHandler&&this.requestHandler(void 0,e)}async acceptChannel(e,t){const s="string"==typeof e?e:void 0;t||"object"!=typeof e||(t=e),this.activateService(d.ConnectionService);const i=this.connectionService.acceptChannel(s||a.SshChannel.sessionChannelType,t);return await i}async openChannel(e,t,s){let i;if("string"==typeof e||null===e?(i=new m.ChannelOpenMessage,i.channelType=null!=e?e:a.SshChannel.sessionChannelType):e instanceof m.ChannelOpenMessage?i=e:(i=new m.ChannelOpenMessage,i.channelType=a.SshChannel.sessionChannelType,s=e),t instanceof m.ChannelRequestMessage)return await this.openChannelWithInitialRequest(i,t,s);s||null===t||(s=t),this.activateService(d.ConnectionService);const n=new S.PromiseCompletionSource;return await this.connectionService.openChannel(i,n,s),await n.promise}async openChannelWithInitialRequest(e,t,s){var i;this.activateService(d.ConnectionService);const n=new S.PromiseCompletionSource,r=await this.connectionService.openChannel(e,n,s);if(s){if(s.isCancellationRequested)throw new R.CancellationError;s.onCancellationRequested((()=>n.reject(new R.CancellationError)))}let a,c;const h=this.config.protocolExtensions.includes(o.SshProtocolExtensionNames.openChannelRequest)&&(null===(i=this.protocolExtensions)||void 0===i?void 0:i.has(o.SshProtocolExtensionNames.openChannelRequest));if(!1===h)a=await n.promise,c=await a.request(t,s);else{const e=t.wantReply||void 0===h,i=new v.SessionChannelRequestMessage;i.requestType="initial-channel-request@microsoft.com",i.senderChannel=r,i.request=t,i.wantReply=e;const o=this.request(i,s);a=await n.promise,e?(c=await o,c||void 0!==h||(c=await a.request(t))):c=!0}if(!c)throw await a.close(),new Error("The initial channel request was denied.");return a}async handleChannelOpening(e,t,s=!0){if(s){const s=(0,u.findService)(this.config.services,(t=>t.channelType===e.channel.channelType&&!t.channelRequest));if(s){const i=this.activateService(s);return void await i.onChannelOpening(e,t)}}e.cancellation=null!=t?t:r.CancellationToken.None,this.channelOpeningEmitter.fire(e),e.openingPromise&&await e.openingPromise}async sendExtensionInfo(e){const t=new v.ExtensionInfoMessage;t.extensionInfo={};for(let e of this.config.protocolExtensions)if(e===o.SshProtocolExtensionNames.serverSignatureAlgorithms){const s=Array.from(new Set((0,C.algorithmNames)(this.config.publicKeyAlgorithms))).join(",");t.extensionInfo[e]=s}else t.extensionInfo[e]="";await this.sendMessage(t,e)}async handleExtensionInfoMessage(e,t){if(this.protocol&&(this.protocol.extensions=new Map,e.extensionInfo)){for(let t of this.config.protocolExtensions){const s=e.extensionInfo[t];"string"==typeof s&&this.protocol.extensions.set(t,s)}this.protocol.extensions.has(o.SshProtocolExtensionNames.sessionReconnect)&&await this.enableReconnect(t)}}async close(e,t,s){var n,r,o;if(!this.disposed&&this.connected){if(this.connected=!1,this.trace(i.TraceLevel.Info,i.SshTraceEventIds.sessionClosing,`${this} Close(${v.SshDisconnectReason[e]}, "${t||""}")`),e!==v.SshDisconnectReason.connectionLost)try{const s=new v.DisconnectMessage;s.reasonCode=e,s.description=t||"",await(null===(n=this.protocol)||void 0===n?void 0:n.sendMessage(s))}catch(e){}else if(this.handleDisconnected())return null===(r=this.protocol)||void 0===r||r.dispose(),this.trace(i.TraceLevel.Info,i.SshTraceEventIds.sessionDisconnected,`${this} disconnected.`),void this.disconnectedEmitter.fire();this.disposed=!0,s&&(null===(o=this.connectionService)||void 0===o||o.close(s)),this.closedEmitter.fire(new b.SshSessionClosedEventArgs(e,t||"Disconnected.",s||null)),this.dispose()}}handleDisconnected(){var e,t;return this.connectPromise=void 0,null===(e=this.kexService)||void 0===e||e.abortKeyExchange(),!!(null===(t=this.protocolExtensions)||void 0===t?void 0:t.has(o.SshProtocolExtensionNames.sessionReconnect))}async handleDisconnectMessage(e){var t;await this.close(null!==(t=e.reasonCode)&&void 0!==t?t:v.SshDisconnectReason.none,e.description)}dispose(){var e,t;this.disposed||(this.trace(i.TraceLevel.Info,i.SshTraceEventIds.sessionClosing,`${this} disposed.`),this.disposed=!0,this.closedEmitter.fire(new b.SshSessionClosedEventArgs(v.SshDisconnectReason.none,"SshSession disposed",null))),this.requestHandler&&this.requestHandler(new P.SshConnectionError("Connection closed.")),this.metrics.close(),null===(e=this.connectionService)||void 0===e||e.dispose();for(let e of this.activatedServices.values())e!==this.connectionService&&e.dispose();this.activatedServices.clear(),null===(t=this.protocol)||void 0===t||t.dispose(),this.protocol=void 0}async enableReconnect(e){var t;try{if(await this.blockedMessagesSemaphore.wait(),null===(t=this.kexService)||void 0===t?void 0:t.exchanging)this.trace(i.TraceLevel.Error,i.SshTraceEventIds.sessionReconnectInitFailed,"Failed to initialize session reconnect because a key-exchange was in-progress.");else{const t=new v.SessionRequestMessage("enable-session-reconnect@microsoft.com",!1);await this.protocol.sendMessage(t,e),this.protocol&&(this.protocol.outgoingMessagesHaveReconnectInfo=!0,this.protocol.outgoingMessagesHaveLatencyInfo=this.protocol.extensions.has(o.SshProtocolExtensionNames.sessionLatency))}this.blockedMessagesSemaphore.release()}catch(e){throw this.blockedMessagesSemaphore.release(),e instanceof Error&&await this.close(v.SshDisconnectReason.protocolError,void 0,e),e}}async createReconnectToken(e,t){return await this.algorithms.signer.sign(n.Buffer.concat([e,t]))}async verifyReconnectToken(e,t,s){return await this.algorithms.verifier.verify(n.Buffer.concat([e,t]),s)}pipe(e){return k.PipeExtensions.pipeSession(this,e)}toString(){return this.constructor.name}}t.SshSession=x,x.localVersion=c.SshVersionInfo.getLocalVersion()},7462:(e,t)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.SshSessionAlgorithms=void 0,t.SshSessionAlgorithms=class{dispose(){this.cipher&&this.cipher.dispose(),this.decipher&&this.decipher.dispose(),this.signer&&this.signer.dispose(),this.verifier&&this.verifier.dispose()}}},7183:(e,t,s)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.SshSessionConfiguration=t.SshProtocolExtensionNames=void 0;const i=s(3730),n=s(1605),r=s(3210),o=s(7165),a=s(6502),c=s(285);var h;!function(e){e.serverSignatureAlgorithms="server-sig-algs",e.openChannelRequest="open-channel-request@microsoft.com",e.sessionReconnect="session-reconnect@microsoft.com",e.sessionLatency="session-latency@microsoft.com"}(h=t.SshProtocolExtensionNames||(t.SshProtocolExtensionNames={})),t.SshSessionConfiguration=class{constructor(e=!0){this.protocolExtensions=[],this.services=new Map,this.messages=new Map,this.keyExchangeAlgorithms=[],this.publicKeyAlgorithms=[],this.encryptionAlgorithms=[],this.hmacAlgorithms=[],this.compressionAlgorithms=[],this.traceChannelDataValue=!1,this.configurationChangedEmitter=new i.Emitter,this.onConfigurationChanged=this.configurationChangedEmitter.event,this.maxClientAuthenticationAttempts=5,this.enableKeyExchangeGuess=!1,this.keyRotationThreshold=536870912,this.protocolExtensions.push(h.serverSignatureAlgorithms),this.protocolExtensions.push(h.openChannelRequest),this.services.set(r.KeyExchangeService,null),this.services.set(o.ConnectionService,null),this.services.set(a.AuthenticationService,null);for(let[e,t]of c.SshMessage.index)this.messages.set(e,t);e?(this.keyExchangeAlgorithms.push(n.SshAlgorithms.keyExchange.ecdhNistp384Sha384),this.keyExchangeAlgorithms.push(n.SshAlgorithms.keyExchange.ecdhNistp256Sha256),this.keyExchangeAlgorithms.push(n.SshAlgorithms.keyExchange.dhGroup16Sha512),this.keyExchangeAlgorithms.push(n.SshAlgorithms.keyExchange.dhGroup14Sha256),this.publicKeyAlgorithms.push(n.SshAlgorithms.publicKey.rsaWithSha512),this.publicKeyAlgorithms.push(n.SshAlgorithms.publicKey.rsaWithSha256),this.publicKeyAlgorithms.push(n.SshAlgorithms.publicKey.ecdsaSha2Nistp384),this.publicKeyAlgorithms.push(n.SshAlgorithms.publicKey.ecdsaSha2Nistp256),this.encryptionAlgorithms.push(n.SshAlgorithms.encryption.aes256Gcm),this.encryptionAlgorithms.push(n.SshAlgorithms.encryption.aes256Ctr),this.hmacAlgorithms.push(n.SshAlgorithms.hmac.hmacSha512Etm),this.hmacAlgorithms.push(n.SshAlgorithms.hmac.hmacSha256Etm),this.hmacAlgorithms.push(n.SshAlgorithms.hmac.hmacSha512),this.hmacAlgorithms.push(n.SshAlgorithms.hmac.hmacSha256)):(this.keyExchangeAlgorithms.push(n.SshAlgorithms.keyExchange.none),this.publicKeyAlgorithms.push(n.SshAlgorithms.publicKey.none),this.encryptionAlgorithms.push(n.SshAlgorithms.encryption.none),this.hmacAlgorithms.push(n.SshAlgorithms.hmac.none)),this.compressionAlgorithms.push(n.SshAlgorithms.compression.none)}addService(e,t){if(this.services.has(e))throw new Error("Duplicate service entry.");this.services.set(e,t)}getKeyExchangeAlgorithm(e){return this.getAlgorithm(e,this.keyExchangeAlgorithms)}getPublicKeyAlgorithm(e){return this.getAlgorithm(e,this.publicKeyAlgorithms)}getEncryptionAlgorithm(e){return this.getAlgorithm(e,this.encryptionAlgorithms)}getHmacAlgorithm(e){return this.getAlgorithm(e,this.hmacAlgorithms)}getCompressionAlgorithm(e){return this.getAlgorithm(e,this.compressionAlgorithms)}getAlgorithm(e,t){const s=t.find((t=>!!t&&t.name===e));if(!s){if("none"===e)return null;throw new Error("Algorithm not found: "+e)}return s}get traceChannelData(){return this.traceChannelDataValue}set traceChannelData(e){e!==this.traceChannelDataValue&&(this.traceChannelDataValue=e,this.configurationChangedEmitter.fire())}}},2656:(e,t,s)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.SshStream=void 0;const i=s(3708),n=s(2781);class r extends n.Duplex{constructor(e){let t=null;super({async write(t,s,i){let n;try{let i;if("string"==typeof t)i=Buffer.from(t,s);else{if(!(t instanceof Buffer))throw new Error("Unsupported chunk type: "+typeof t);i=t}await e.send(i)}catch(e){if(!(e instanceof Error))throw e;n=e}i&&i(n)},async writev(t,s){let i;try{if(1===t.length)return this.write(t[0].chunk,t[0].encoding,s);{function n(e,t){if(t.chunk instanceof Buffer)return e+t.chunk.length;throw new Error("Unsupported chunk type: "+typeof t.chunk)}const r=t.reduce(n,0),o=Buffer.alloc(r);let a=0;for(let c=0;c<t.length;c++)t[c].chunk.copy(o,a),a+=t[c].chunk.length;await e.send(o)}}catch(h){if(!(h instanceof Error))throw h;i=h}s&&s(i)},async final(t){let s;try{await e.close()}catch(e){if(!(e instanceof Error))throw e;s=e}t&&t(s)},read(){t&&(t.resolve(),t=null)}});const s=this;e.onDataReceived((async n=>{const r=Buffer.alloc(n.length);n.copy(r),s.push(r)||(t||(t=new i.PromiseCompletionSource),await t.promise),e.adjustWindow(r.length)})),e.onClosed((()=>{s.push(null)})),this.channel=e}destroy(){this.channel.close().catch(),super.destroy()}toString(){return`SshStream(Channel Type: ${this.channel.channelType}, Id: ${this.channel.channelId}, RemoteId: ${this.channel.remoteChannelId})`}}t.SshStream=r},7505:(e,t,s)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.SshVersionInfo=void 0;const i=s(3121),n=i.name.replace(/^@\w+\//,""),r=i.version;class o{constructor(e,t,s,i){this.versionString=e,this.protocolVersion=t,this.name=s,this.version=i}static tryParse(e){if(!e)throw new TypeError("Version string expected.");if(!e.startsWith("SSH-"))return null;const t=e.indexOf("-",4);if(t<=0)return null;const s=e.substring(4,t);if(!/^\d+\.\d+$/.test(s))return null;let i,n;const r=e.substring(t+1),a=r.indexOf(" "),c=r.lastIndexOf("_",a>=0?a:r.length-1);if(c>=0){i=r.substring(0,c).replace(/_/g," "),n=r.substring(c+1);for(let e=0;e<n.length;e++){const t=n[e];if(!(t>="0"&&t<="9")&&"."!==t){n=n.substring(0,e);break}}/^\d+(\.\d+)*$/.test(n)||(n=null)}else i=r,n=null;return new o(e,s,i,n)}static getLocalVersion(){return new o(`SSH-2.0-${n}_${r}`,"2.0",n,r)}toString(){return this.versionString}get isVsSsh(){return this.isVsSshCS||this.isVsSshTS}get isVsSshCS(){return"Microsoft.VisualStudio.Ssh"===this.name}get isVsSshTS(){return"vs-ssh"===this.name}}t.SshVersionInfo=o},569:(e,t,s)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.WebSocketStream=t.NodeStream=t.BaseStream=void 0;const i=s(4300),n=s(3730),r=s(7437),o=s(2917);function a(e,t){t&&(t.isCancellationRequested?e(new r.CancellationError):t.onCancellationRequested((()=>{e(new r.CancellationError)})))}class c{constructor(){this.incomingData=[],this.pendingReads=[],this.error=null,this.disposed=!1,this.closedEmitter=new n.Emitter,this.closed=this.closedEmitter.event}onData(e){for(;this.pendingReads.length>0;){const t=this.pendingReads.shift();if(t.count>=e.length)return void t.resolve(e);{const s=e.slice(0,t.count);e=e.slice(t.count),t.resolve(s)}}this.incomingData.push(e)}onEnd(){for(;this.pendingReads.length>0;)this.pendingReads.shift().resolve(null);this.incomingData.push(i.Buffer.alloc(0))}onError(e){for(this.error||(this.error=e);this.pendingReads.length>0;)this.pendingReads.shift().reject(e)}async read(e,t){if(this.disposed)throw new o.ObjectDisposedError(this);if(this.incomingData.length>0){let t=this.incomingData[0];return 0===t.length?null:(e>=t.length?this.incomingData.shift():(this.incomingData[0]=t.slice(e),t=t.slice(0,e)),t)}if(this.error)throw this.error;return await new Promise(((s,i)=>{if(t){if(t.isCancellationRequested)return void i(new r.CancellationError);t.onCancellationRequested((()=>{for(let e=0;e<this.pendingReads.length;e++)Object.is(t,this.pendingReads[e].cancellation)&&this.pendingReads.splice(e--,1)[0].reject(new r.CancellationError)}))}this.pendingReads.push({count:e,resolve:s,reject:i,cancellation:t})}))}dispose(){if(!this.disposed){this.disposed=!0;const e=new o.ObjectDisposedError(this);this.onError(e),this.fireOnClose(e)}}fireOnClose(e){this.closedEmitter.fire({error:e})}get isDisposed(){return this.disposed}}t.BaseStream=c,t.NodeStream=class extends c{constructor(e,t){if(super(),!e)throw new TypeError("Duplex or Readable/Writable stream are required.");this.readStream=e,this.writeStream=t||e,this.readStream.on("data",this.onData.bind(this)),this.readStream.on("end",this.onEnd.bind(this)),this.readStream.on("error",this.onError.bind(this)),this.readStream.on("close",(()=>{this.onEnd(),this.fireOnClose()}))}async write(e,t){if(!e)throw new TypeError("Data is required.");if(this.disposed)throw new o.ObjectDisposedError(this);return new Promise(((s,i)=>{a(i,t),this.writeStream.write(e,(e=>{e?i(e):s()}))}))}async close(e,t){if(this.disposed)throw new o.ObjectDisposedError(this);await new Promise(((e,s)=>{a(s,t),this.writeStream.end(e)})),this.disposed=!0,this.onError(e||new o.ObjectDisposedError(this)),this.closedEmitter.fire({error:e})}dispose(){if(!this.disposed){const e=new o.ObjectDisposedError(this);this.readStream.destroy(e),this.writeStream.destroy(e)}super.dispose()}},t.WebSocketStream=class extends c{constructor(e){if(super(),this.websocket=e,!e)throw new TypeError("WebSocket is required.");if("string"==typeof e.binaryType&&"arraybuffer"!==e.binaryType)throw new Error("WebSocket must use arraybuffer binary type.");e.onmessage=e=>{this.onData(i.Buffer.from(e.data))},e.onclose=e=>{if(e.wasClean)this.onEnd();else{const t=new Error(e.reason);t.code=e.code,this.onError(t)}}}async write(e,t){if(!e)throw new TypeError("Data is required.");if(this.disposed)throw new o.ObjectDisposedError(this);if("readyState"in this.websocket&&(2===this.websocket.readyState||3===this.websocket.readyState))throw new DOMException("WebSocket is already in CLOSING or CLOSED state.","InvalidStateError");this.websocket.send(e)}async close(e,t){if(this.disposed)throw new o.ObjectDisposedError(this);if(e){const t="number"==typeof e.code?e.code:void 0;this.websocket.close(t,e.message)}else this.websocket.close();this.disposed=!0,this.closedEmitter.fire({error:e}),this.onError(e||new Error("Stream closed."))}dispose(){this.disposed||this.websocket.close(),super.dispose()}}},3776:(e,t)=>{"use strict";var s;Object.defineProperty(t,"__esModule",{value:!0}),t.SshTraceEventIds=t.TraceLevel=void 0,(s=t.TraceLevel||(t.TraceLevel={})).Error="error",s.Warning="warning",s.Info="info",s.Verbose="verbose";class i{}t.SshTraceEventIds=i,i.unknownError=9e3,i.streamReadError=9001,i.streamWriteError=9002,i.streamCloseError=9003,i.sendMessageFailed=9004,i.receiveMessageFailed=9005,i.handleMessageFailed=9006,i.serverAuthenticationFailed=9007,i.clientAuthenticationFailed=9008,i.authenticationError=9009,i.channelWindowAdjustFailed=9010,i.channelWaitForWindowAdjust=9011,i.sessionReconnectInitFailed=9020,i.serverSessionReconnectFailed=9021,i.clientSessionReconnectFailed=9022,i.sessionRequestFailed=9023,i.channelRequestFailed=9024,i.serverListenFailed=9050,i.portForwardServerListenFailed=9051,i.portForwardRequestInvalid=9052,i.portForwardChannelInvalid=9053,i.portForwardChannelOpenFailed=9054,i.portForwardConnectionFailed=9055,i.protocolVersion=9100,i.sendingMessage=9101,i.receivingMessage=9102,i.sendingChannelData=9103,i.receivingChannelData=9104,i.sessionEncrypted=9110,i.sessionAuthenticating=9111,i.sessionAuthenticated=9112,i.sessionClosing=9113,i.sessionConnecting=9114,i.channelOpened=9120,i.channelOpenFailed=9121,i.channelEofReceived=9122,i.channelClosed=9123,i.serverListening=9150,i.serverClientConnected=9151,i.portForwardServerListening=9152,i.portForwardConnectionAccepted=9153,i.portForwardChannelOpened=9154,i.portForwardChannelClosed=9155,i.portForwardConnectionOpened=9156,i.portForwardConnectionClosed=9157,i.sessionDisconnected=9160,i.clientSessionReconnecting=9161,i.serverSessionReconnecting=9162,i.clientSessionStartReconnecting=9163,i.algorithmNegotiation=9170,i.debugMessage=9200},7437:(e,t,s)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.withCancellation=t.CancellationError=t.CancellationTokenSource=t.CancellationToken=void 0;const i=s(3730);Object.defineProperty(t,"CancellationToken",{enumerable:!0,get:function(){return i.CancellationToken}}),Object.defineProperty(t,"CancellationTokenSource",{enumerable:!0,get:function(){return i.CancellationTokenSource}});class n extends Error{constructor(e){super(e||"Operation cancelled.")}}t.CancellationError=n,t.withCancellation=function(e,t){return t?Promise.race([e,new Promise(((e,s)=>{t.isCancellationRequested?s(new n):t.onCancellationRequested((()=>{s(new n)}))}))]):e}},3708:(e,t)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.PromiseCompletionSource=void 0,t.PromiseCompletionSource=class{constructor(){this.promise=new Promise(((e,t)=>{this.resolve=e,this.reject=t}))}resolve(e){}reject(e){}}},8776:(e,t)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.Queue=void 0;class s{constructor(){this.array=new Array,this.first=0,this.count=0,this.version=0}get size(){return this.count}enqueue(e){if(this.count===this.array.length){const e=new Array(Math.max(16,2*this.count));for(let t=0;t<this.count;t++)e[t]=this.array[(this.first+t)%this.count];this.array=e,this.first=0}this.array[(this.first+this.count)%this.array.length]=e,this.count++,this.version++}dequeue(){if(0===this.count)return;const e=this.array[this.first];return this.array[this.first]=void 0,this.first=(this.first+1)%this.array.length,this.count--,this.version++,e}peek(){if(0!==this.count)return this.array[this.first]}clear(){this.first=0,this.count=0,this.array.fill(void 0),this.version++}*[Symbol.iterator](){const e=this.version;for(let t=0;t<this.count;t++){const s=this.array[(this.first+t)%this.array.length];if(yield s,this.version!==e)throw new Error("Iterator is invalid due to changes in the collection.")}}}t.Queue=s},4564:(e,t,s)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.Semaphore=void 0;const i=s(3708),n=s(7437),r=s(2917);t.Semaphore=class{constructor(e=0){this.completions=[],this.disposed=!1,this.count=e}get currentCount(){return this.count}release(e=1){if(this.disposed)throw new r.ObjectDisposedError(this);const t=this.count;for(;e>0;e--)this.completions.length>0?this.completions.shift().resolve(!0):this.count++;return t}tryRelease(){try{this.release()}catch(e){if(!(e instanceof r.ObjectDisposedError))throw e}}async wait(e,t){const s="number"==typeof e?e:void 0;if(void 0===t&&"object"==typeof e&&(t=e),this.disposed)throw new r.ObjectDisposedError(this);if(null==t?void 0:t.isCancellationRequested)throw new n.CancellationError;if(this.count>0)return this.count--,!0;if(0===s)return!1;{const e=new i.PromiseCompletionSource;this.completions.push(e);const r=[e.promise];if(s&&r.push(new Promise((e=>setTimeout((()=>e(!1)),s)))),t){const e=new i.PromiseCompletionSource;t.onCancellationRequested((()=>{e.reject(new n.CancellationError)})),r.push(e.promise)}if(await Promise.race(r))return!0;{const t=this.completions.indexOf(e);return t>=0&&this.completions.splice(t,1),!1}}}dispose(){if(!this.disposed){this.disposed=!0;for(let e of this.completions)e.reject(new r.ObjectDisposedError(this));this.completions.splice(0,this.completions.length),this.count=0}}}},5518:e=>{e.exports={newInvalidAsn1Error:function(e){var t=new Error;return t.name="InvalidAsn1Error",t.message=e||"",t}}},2697:(e,t,s)=>{var i=s(5518),n=s(5805),r=s(9194),o=s(5766);for(var a in e.exports={Reader:r,Writer:o},n)n.hasOwnProperty(a)&&(e.exports[a]=n[a]);for(var c in i)i.hasOwnProperty(c)&&(e.exports[c]=i[c])},9194:(e,t,s)=>{var i=s(9491),n=s(1788).Buffer,r=s(5805),o=s(5518).newInvalidAsn1Error;function a(e){if(!e||!n.isBuffer(e))throw new TypeError("data must be a node Buffer");this._buf=e,this._size=e.length,this._len=0,this._offset=0}Object.defineProperty(a.prototype,"length",{enumerable:!0,get:function(){return this._len}}),Object.defineProperty(a.prototype,"offset",{enumerable:!0,get:function(){return this._offset}}),Object.defineProperty(a.prototype,"remain",{get:function(){return this._size-this._offset}}),Object.defineProperty(a.prototype,"buffer",{get:function(){return this._buf.slice(this._offset)}}),a.prototype.readByte=function(e){if(this._size-this._offset<1)return null;var t=255&this._buf[this._offset];return e||(this._offset+=1),t},a.prototype.peek=function(){return this.readByte(!0)},a.prototype.readLength=function(e){if(void 0===e&&(e=this._offset),e>=this._size)return null;var t=255&this._buf[e++];if(null===t)return null;if(128==(128&t)){if(0==(t&=127))throw o("Indefinite length not supported");if(t>4)throw o("encoding too long");if(this._size-e<t)return null;this._len=0;for(var s=0;s<t;s++)this._len=(this._len<<8)+(255&this._buf[e++])}else this._len=t;return e},a.prototype.readSequence=function(e){var t=this.peek();if(null===t)return null;if(void 0!==e&&e!==t)throw o("Expected 0x"+e.toString(16)+": got 0x"+t.toString(16));var s=this.readLength(this._offset+1);return null===s?null:(this._offset=s,t)},a.prototype.readInt=function(){return this._readTag(r.Integer)},a.prototype.readBoolean=function(){return 0!==this._readTag(r.Boolean)},a.prototype.readEnumeration=function(){return this._readTag(r.Enumeration)},a.prototype.readString=function(e,t){e||(e=r.OctetString);var s=this.peek();if(null===s)return null;if(s!==e)throw o("Expected 0x"+e.toString(16)+": got 0x"+s.toString(16));var i=this.readLength(this._offset+1);if(null===i)return null;if(this.length>this._size-i)return null;if(this._offset=i,0===this.length)return t?n.alloc(0):"";var a=this._buf.slice(this._offset,this._offset+this.length);return this._offset+=this.length,t?a:a.toString("utf8")},a.prototype.readOID=function(e){e||(e=r.OID);var t=this.readString(e,!0);if(null===t)return null;for(var s=[],i=0,n=0;n<t.length;n++){var o=255&t[n];i<<=7,i+=127&o,0==(128&o)&&(s.push(i),i=0)}return i=s.shift(),s.unshift(i%40),s.unshift(i/40>>0),s.join(".")},a.prototype._readTag=function(e){i.ok(void 0!==e);var t=this.peek();if(null===t)return null;if(t!==e)throw o("Expected 0x"+e.toString(16)+": got 0x"+t.toString(16));var s=this.readLength(this._offset+1);if(null===s)return null;if(this.length>4)throw o("Integer too long: "+this.length);if(this.length>this._size-s)return null;this._offset=s;for(var n=this._buf[this._offset],r=0,a=0;a<this.length;a++)r<<=8,r|=255&this._buf[this._offset++];return 128==(128&n)&&4!==a&&(r-=1<<8*a),r>>0},e.exports=a},5805:e=>{e.exports={EOC:0,Boolean:1,Integer:2,BitString:3,OctetString:4,Null:5,OID:6,ObjectDescriptor:7,External:8,Real:9,Enumeration:10,PDV:11,Utf8String:12,RelativeOID:13,Sequence:16,Set:17,NumericString:18,PrintableString:19,T61String:20,VideotexString:21,IA5String:22,UTCTime:23,GeneralizedTime:24,GraphicString:25,VisibleString:26,GeneralString:28,UniversalString:29,CharacterString:30,BMPString:31,Constructor:32,Context:128}},5766:(e,t,s)=>{var i=s(9491),n=s(1788).Buffer,r=s(5805),o=s(5518).newInvalidAsn1Error,a={size:1024,growthFactor:8};function c(e){var t,s;t=a,s=e||{},i.ok(t),i.equal(typeof t,"object"),i.ok(s),i.equal(typeof s,"object"),Object.getOwnPropertyNames(t).forEach((function(e){if(!s[e]){var i=Object.getOwnPropertyDescriptor(t,e);Object.defineProperty(s,e,i)}})),e=s,this._buf=n.alloc(e.size||1024),this._size=this._buf.length,this._offset=0,this._options=e,this._seq=[]}Object.defineProperty(c.prototype,"buffer",{get:function(){if(this._seq.length)throw o(this._seq.length+" unended sequence(s)");return this._buf.slice(0,this._offset)}}),c.prototype.writeByte=function(e){if("number"!=typeof e)throw new TypeError("argument must be a Number");this._ensure(1),this._buf[this._offset++]=e},c.prototype.writeInt=function(e,t){if("number"!=typeof e)throw new TypeError("argument must be a Number");"number"!=typeof t&&(t=r.Integer);for(var s=4;(0==(4286578688&e)||-8388608==(4286578688&e))&&s>1;)s--,e<<=8;if(s>4)throw o("BER ints cannot be > 0xffffffff");for(this._ensure(2+s),this._buf[this._offset++]=t,this._buf[this._offset++]=s;s-- >0;)this._buf[this._offset++]=(4278190080&e)>>>24,e<<=8},c.prototype.writeNull=function(){this.writeByte(r.Null),this.writeByte(0)},c.prototype.writeEnumeration=function(e,t){if("number"!=typeof e)throw new TypeError("argument must be a Number");return"number"!=typeof t&&(t=r.Enumeration),this.writeInt(e,t)},c.prototype.writeBoolean=function(e,t){if("boolean"!=typeof e)throw new TypeError("argument must be a Boolean");"number"!=typeof t&&(t=r.Boolean),this._ensure(3),this._buf[this._offset++]=t,this._buf[this._offset++]=1,this._buf[this._offset++]=e?255:0},c.prototype.writeString=function(e,t){if("string"!=typeof e)throw new TypeError("argument must be a string (was: "+typeof e+")");"number"!=typeof t&&(t=r.OctetString);var s=n.byteLength(e);this.writeByte(t),this.writeLength(s),s&&(this._ensure(s),this._buf.write(e,this._offset),this._offset+=s)},c.prototype.writeBuffer=function(e,t){if("number"!=typeof t)throw new TypeError("tag must be a number");if(!n.isBuffer(e))throw new TypeError("argument must be a buffer");this.writeByte(t),this.writeLength(e.length),this._ensure(e.length),e.copy(this._buf,this._offset,0,e.length),this._offset+=e.length},c.prototype.writeStringArray=function(e){if(!e instanceof Array)throw new TypeError("argument must be an Array[String]");var t=this;e.forEach((function(e){t.writeString(e)}))},c.prototype.writeOID=function(e,t){if("string"!=typeof e)throw new TypeError("argument must be a string");if("number"!=typeof t&&(t=r.OID),!/^([0-9]+\.){3,}[0-9]+$/.test(e))throw new Error("argument is not a valid OID string");var s=e.split("."),i=[];i.push(40*parseInt(s[0],10)+parseInt(s[1],10)),s.slice(2).forEach((function(e){!function(e,t){t<128?e.push(t):t<16384?(e.push(t>>>7|128),e.push(127&t)):t<2097152?(e.push(t>>>14|128),e.push(255&(t>>>7|128)),e.push(127&t)):t<268435456?(e.push(t>>>21|128),e.push(255&(t>>>14|128)),e.push(255&(t>>>7|128)),e.push(127&t)):(e.push(255&(t>>>28|128)),e.push(255&(t>>>21|128)),e.push(255&(t>>>14|128)),e.push(255&(t>>>7|128)),e.push(127&t))}(i,parseInt(e,10))}));var n=this;this._ensure(2+i.length),this.writeByte(t),this.writeLength(i.length),i.forEach((function(e){n.writeByte(e)}))},c.prototype.writeLength=function(e){if("number"!=typeof e)throw new TypeError("argument must be a Number");if(this._ensure(4),e<=127)this._buf[this._offset++]=e;else if(e<=255)this._buf[this._offset++]=129,this._buf[this._offset++]=e;else if(e<=65535)this._buf[this._offset++]=130,this._buf[this._offset++]=e>>8,this._buf[this._offset++]=e;else{if(!(e<=16777215))throw o("Length too long (> 4 bytes)");this._buf[this._offset++]=131,this._buf[this._offset++]=e>>16,this._buf[this._offset++]=e>>8,this._buf[this._offset++]=e}},c.prototype.startSequence=function(e){"number"!=typeof e&&(e=r.Sequence|r.Constructor),this.writeByte(e),this._seq.push(this._offset),this._ensure(3),this._offset+=3},c.prototype.endSequence=function(){var e=this._seq.pop(),t=e+3,s=this._offset-t;if(s<=127)this._shift(t,s,-2),this._buf[e]=s;else if(s<=255)this._shift(t,s,-1),this._buf[e]=129,this._buf[e+1]=s;else if(s<=65535)this._buf[e]=130,this._buf[e+1]=s>>8,this._buf[e+2]=s;else{if(!(s<=16777215))throw o("Sequence too long");this._shift(t,s,1),this._buf[e]=131,this._buf[e+1]=s>>16,this._buf[e+2]=s>>8,this._buf[e+3]=s}},c.prototype._shift=function(e,t,s){i.ok(void 0!==e),i.ok(void 0!==t),i.ok(s),this._buf.copy(this._buf,e+s,e,e+t),this._offset+=s},c.prototype._ensure=function(e){if(i.ok(e),this._size-this._offset<e){var t=this._size*this._options.growthFactor;t-this._offset<e&&(t+=e);var s=n.alloc(t);this._buf.copy(s,0,0,this._offset),this._buf=s,this._size=t}},e.exports=c},2803:(e,t,s)=>{var i=s(2697);e.exports={Ber:i,BerReader:i.Reader,BerWriter:i.Writer}},2045:(e,t)=>{"use strict";class s{constructor(e){this.tasks=[],this.count=e}sched(){if(this.count>0&&this.tasks.length>0){this.count--;let e=this.tasks.shift();if(void 0===e)throw"Unexpected undefined value in tasks list";e()}}acquire(){return new Promise(((e,t)=>{this.tasks.push((()=>{var t=!1;e((()=>{t||(t=!0,this.count++,this.sched())}))})),process&&process.nextTick?process.nextTick(this.sched.bind(this)):setImmediate(this.sched.bind(this))}))}use(e){return this.acquire().then((t=>e().then((e=>(t(),e))).catch((e=>{throw t(),e}))))}}t.Semaphore=s,t.Mutex=class extends s{constructor(){super(1)}}},5693:e=>{"use strict";e.exports={mask:(e,t,s,i,n)=>{for(var r=0;r<n;r++)s[i+r]=e[r]^t[3&r]},unmask:(e,t)=>{const s=e.length;for(var i=0;i<s;i++)e[i]^=t[3&i]}}},796:(e,t,s)=>{"use strict";try{e.exports=s(601)(__dirname)}catch(t){e.exports=s(5693)}},3848:(e,t,s)=>{var i=s(6113);t.DiffieHellmanGroup=i.DiffieHellmanGroup,t.createDiffieHellmanGroup=i.createDiffieHellmanGroup,t.getDiffieHellman=i.getDiffieHellman,t.createDiffieHellman=i.createDiffieHellman,t.DiffieHellman=i.DiffieHellman},8275:e=>{e.exports=i,i.strict=n,i.loose=r;var t=Object.prototype.toString,s={"[object Int8Array]":!0,"[object Int16Array]":!0,"[object Int32Array]":!0,"[object Uint8Array]":!0,"[object Uint8ClampedArray]":!0,"[object Uint16Array]":!0,"[object Uint32Array]":!0,"[object Float32Array]":!0,"[object Float64Array]":!0};function i(e){return n(e)||r(e)}function n(e){return e instanceof Int8Array||e instanceof Int16Array||e instanceof Int32Array||e instanceof Uint8Array||e instanceof Uint8ClampedArray||e instanceof Uint16Array||e instanceof Uint32Array||e instanceof Float32Array||e instanceof Float64Array}function r(e){return s[t.call(e)]}},601:(e,t,s)=>{var i=s(7147),n=s(1017),r=s(2037),o=require,a=process.config&&process.config.variables||{},c=!!process.env.PREBUILDS_ONLY,h=process.versions.modules,l=process.versions&&process.versions.electron||process.env.ELECTRON_RUN_AS_NODE||"undefined"!=typeof window&&window.process&&"renderer"===window.process.type?"electron":process.versions&&process.versions.nw?"node-webkit":"node",u=r.arch(),d=r.platform(),p=process.env.LIBC||(function(e){return"linux"===e&&i.existsSync("/etc/alpine-release")}(d)?"musl":"glibc"),f=process.env.ARM_VERSION||("arm64"===u?"8":a.arm_version)||"",g=(process.versions.uv||"").split(".")[0];function m(e){return o(m.path(e))}function y(e){try{return i.readdirSync(e)}catch(e){return[]}}function v(e,t){var s=y(e).filter(t);return s[0]&&n.join(e,s[0])}function w(e){return/\.node$/.test(e)}function S(e){var t=e.split("-");if(2===t.length){var s=t[0],i=t[1].split("+");if(s&&i.length&&i.every(Boolean))return{name:e,platform:s,architectures:i}}}function b(e,t){return function(s){return null!=s&&s.platform===e&&s.architectures.includes(t)}}function E(e,t){return e.architectures.length-t.architectures.length}function C(e){var t=e.split("."),s={file:e,specificity:0};if("node"===t.pop()){for(var i=0;i<t.length;i++){var n=t[i];if("node"===n||"electron"===n||"node-webkit"===n)s.runtime=n;else if("napi"===n)s.napi=!0;else if("abi"===n.slice(0,3))s.abi=n.slice(3);else if("uv"===n.slice(0,2))s.uv=n.slice(2);else if("armv"===n.slice(0,4))s.armv=n.slice(4);else{if("glibc"!==n&&"musl"!==n)continue;s.libc=n}s.specificity++}return s}}function R(e,t){return function(s){return!(null==s||s.runtime!==e&&!function(e){return"node"===e.runtime&&e.napi}(s)||s.abi!==t&&!s.napi||s.uv&&s.uv!==g||s.armv&&s.armv!==f||s.libc&&s.libc!==p)}}function P(e){return function(t,s){return t.runtime!==s.runtime?t.runtime===e?-1:1:t.abi!==s.abi?t.abi?-1:1:t.specificity!==s.specificity?t.specificity>s.specificity?-1:1:0}}e.exports=m,m.path=function(e){e=n.resolve(e||".");try{var t=o(n.join(e,"package.json")).name.toUpperCase().replace(/-/g,"_");process.env[t+"_PREBUILD"]&&(e=process.env[t+"_PREBUILD"])}catch(e){}if(!c){var s=v(n.join(e,"build/Release"),w);if(s)return s;var i=v(n.join(e,"build/Debug"),w);if(i)return i}var r=T(e);if(r)return r;var a=T(n.dirname(process.execPath));if(a)return a;var m=["platform="+d,"arch="+u,"runtime="+l,"abi="+h,"uv="+g,f?"armv="+f:"","libc="+p,"node="+process.versions.node,process.versions.electron?"electron="+process.versions.electron:"","webpack=true"].filter(Boolean).join(" ");throw new Error("No native build was found for "+m+"\n    loaded from: "+e+"\n");function T(e){var t=y(n.join(e,"prebuilds")).map(S).filter(b(d,u)).sort(E)[0];if(t){var s=n.join(e,"prebuilds",t.name),i=y(s).map(C).filter(R(l,h)).sort(P(l))[0];return i?n.join(s,i.file):void 0}}},m.parseTags=C,m.matchTags=R,m.compareTags=P,m.parseTuple=S,m.matchTuple=b,m.compareTuples=E},2859:(e,t,s)=>{var i=s(2057),n=s(4153),r=(s(6113),s(2803).Ber,s(222)._),o=s(222),a=s(7178),c=s(9073);void 0===i.RSA_NO_PADDING&&(i.RSA_NO_PADDING=3),e.exports=function(){var e={node10:["md4","md5","ripemd160","sha1","sha224","sha256","sha384","sha512"],node:["md4","md5","ripemd160","sha1","sha224","sha256","sha384","sha512"],iojs:["md4","md5","ripemd160","sha1","sha224","sha256","sha384","sha512"],browser:["md5","ripemd160","sha1","sha256","sha512"]},t="pkcs1_oaep",s="pkcs1",i={private:"pkcs1-private-pem","private-der":"pkcs1-private-der",public:"pkcs8-public-pem","public-der":"pkcs8-public-der"};function h(e,i,a){if(!(this instanceof h))return new h(e,i,a);r.isObject(i)&&(a=i,i=void 0),this.$options={signingScheme:s,signingSchemeOptions:{hash:"sha256",saltLength:null},encryptionScheme:t,encryptionSchemeOptions:{hash:"sha1",label:null},environment:o.detectEnvironment(),rsaUtils:this},this.keyPair=new n.Key,this.$cache={},Buffer.isBuffer(e)||r.isString(e)?this.importKey(e,i):r.isObject(e)&&this.generateKeyPair(e.b,e.e),this.setOptions(a)}return h.prototype.setOptions=function(i){if((i=i||{}).environment&&(this.$options.environment=i.environment),i.signingScheme){if(r.isString(i.signingScheme)){var n=i.signingScheme.toLowerCase().split("-");1==n.length?e.node.indexOf(n[0])>-1?(this.$options.signingSchemeOptions={hash:n[0]},this.$options.signingScheme=s):(this.$options.signingScheme=n[0],this.$options.signingSchemeOptions={hash:null}):(this.$options.signingSchemeOptions={hash:n[1]},this.$options.signingScheme=n[0])}else r.isObject(i.signingScheme)&&(this.$options.signingScheme=i.signingScheme.scheme||s,this.$options.signingSchemeOptions=r.omit(i.signingScheme,"scheme"));if(!a.isSignature(this.$options.signingScheme))throw Error("Unsupported signing scheme");if(this.$options.signingSchemeOptions.hash&&-1===e[this.$options.environment].indexOf(this.$options.signingSchemeOptions.hash))throw Error("Unsupported hashing algorithm for "+this.$options.environment+" environment")}if(i.encryptionScheme){if(r.isString(i.encryptionScheme)?(this.$options.encryptionScheme=i.encryptionScheme.toLowerCase(),this.$options.encryptionSchemeOptions={}):r.isObject(i.encryptionScheme)&&(this.$options.encryptionScheme=i.encryptionScheme.scheme||t,this.$options.encryptionSchemeOptions=r.omit(i.encryptionScheme,"scheme")),!a.isEncryption(this.$options.encryptionScheme))throw Error("Unsupported encryption scheme");if(this.$options.encryptionSchemeOptions.hash&&-1===e[this.$options.environment].indexOf(this.$options.encryptionSchemeOptions.hash))throw Error("Unsupported hashing algorithm for "+this.$options.environment+" environment")}this.keyPair.setOptions(this.$options)},h.prototype.generateKeyPair=function(e,t){if(t=t||65537,(e=e||2048)%8!=0)throw Error("Key size must be a multiple of 8.");return this.keyPair.generate(e,t.toString(16)),this.$cache={},this},h.prototype.importKey=function(e,t){if(!e)throw Error("Empty key given");if(t&&(t=i[t]||t),!c.detectAndImport(this.keyPair,e,t)&&void 0===t)throw Error("Key format must be specified");return this.$cache={},this},h.prototype.exportKey=function(e){return e=i[e=e||"private"]||e,this.$cache[e]||(this.$cache[e]=c.detectAndExport(this.keyPair,e)),this.$cache[e]},h.prototype.isPrivate=function(){return this.keyPair.isPrivate()},h.prototype.isPublic=function(e){return this.keyPair.isPublic(e)},h.prototype.isEmpty=function(e){return!(this.keyPair.n||this.keyPair.e||this.keyPair.d)},h.prototype.encrypt=function(e,t,s){return this.$$encryptKey(!1,e,t,s)},h.prototype.decrypt=function(e,t){return this.$$decryptKey(!1,e,t)},h.prototype.encryptPrivate=function(e,t,s){return this.$$encryptKey(!0,e,t,s)},h.prototype.decryptPublic=function(e,t){return this.$$decryptKey(!0,e,t)},h.prototype.$$encryptKey=function(e,t,s,i){try{var n=this.keyPair.encrypt(this.$getDataForEncrypt(t,i),e);return"buffer"!=s&&s?n.toString(s):n}catch(e){throw Error("Error during encryption. Original error: "+e)}},h.prototype.$$decryptKey=function(e,t,s){try{t=r.isString(t)?Buffer.from(t,"base64"):t;var i=this.keyPair.decrypt(t,e);if(null===i)throw Error("Key decrypt method returns null.");return this.$getDecryptedData(i,s)}catch(e){throw Error("Error during decryption (probably incorrect key). Original error: "+e)}},h.prototype.sign=function(e,t,s){if(!this.isPrivate())throw Error("This is not private key");var i=this.keyPair.sign(this.$getDataForEncrypt(e,s));return t&&"buffer"!=t&&(i=i.toString(t)),i},h.prototype.verify=function(e,t,s,i){if(!this.isPublic())throw Error("This is not public key");return i=i&&"buffer"!=i?i:null,this.keyPair.verify(this.$getDataForEncrypt(e,s),t,i)},h.prototype.getKeySize=function(){return this.keyPair.keySize},h.prototype.getMaxMessageSize=function(){return this.keyPair.maxMessageLength},h.prototype.$getDataForEncrypt=function(e,t){if(r.isString(e)||r.isNumber(e))return Buffer.from(""+e,t||"utf8");if(Buffer.isBuffer(e))return e;if(r.isObject(e))return Buffer.from(JSON.stringify(e));throw Error("Unexpected data type")},h.prototype.$getDecryptedData=function(e,t){return"buffer"==(t=t||"buffer")?e:"json"==t?JSON.parse(e.toString()):e.toString(t)},h}()},2589:(e,t,s)=>{var i=s(6113);e.exports={getEngine:function(e,t){var n=s(9107);return"node"===t.environment&&"function"==typeof i.publicEncrypt&&"function"==typeof i.privateDecrypt&&(n="function"==typeof i.privateEncrypt&&"function"==typeof i.publicDecrypt?s(6252):s(3752)),n(e,t)}}},6252:(e,t,s)=>{var i=s(6113),n=s(2057),r=s(7178);e.exports=function(e,t){var s=r.pkcs1.makeScheme(e,t);return{encrypt:function(e,r){var o;if(r)return o=n.RSA_PKCS1_PADDING,t.encryptionSchemeOptions&&t.encryptionSchemeOptions.padding&&(o=t.encryptionSchemeOptions.padding),i.privateEncrypt({key:t.rsaUtils.exportKey("private"),padding:o},e);o=n.RSA_PKCS1_OAEP_PADDING,"pkcs1"===t.encryptionScheme&&(o=n.RSA_PKCS1_PADDING),t.encryptionSchemeOptions&&t.encryptionSchemeOptions.padding&&(o=t.encryptionSchemeOptions.padding);var a=e;return o===n.RSA_NO_PADDING&&(a=s.pkcs0pad(e)),i.publicEncrypt({key:t.rsaUtils.exportKey("public"),padding:o},a)},decrypt:function(e,r){var o;if(r)return o=n.RSA_PKCS1_PADDING,t.encryptionSchemeOptions&&t.encryptionSchemeOptions.padding&&(o=t.encryptionSchemeOptions.padding),i.publicDecrypt({key:t.rsaUtils.exportKey("public"),padding:o},e);o=n.RSA_PKCS1_OAEP_PADDING,"pkcs1"===t.encryptionScheme&&(o=n.RSA_PKCS1_PADDING),t.encryptionSchemeOptions&&t.encryptionSchemeOptions.padding&&(o=t.encryptionSchemeOptions.padding);var a=i.privateDecrypt({key:t.rsaUtils.exportKey("private"),padding:o},e);return o===n.RSA_NO_PADDING?s.pkcs0unpad(a):a}}}},9107:(e,t,s)=>{var i=s(8359),n=s(7178);e.exports=function(e,t){var s=n.pkcs1.makeScheme(e,t);return{encrypt:function(t,n){var r,o;return n?(r=new i(s.encPad(t,{type:1})),o=e.$doPrivate(r)):(r=new i(e.encryptionScheme.encPad(t)),o=e.$doPublic(r)),o.toBuffer(e.encryptedDataLength)},decrypt:function(t,n){var r,o=new i(t);return n?(r=e.$doPublic(o),s.encUnPad(r.toBuffer(e.encryptedDataLength),{type:1})):(r=e.$doPrivate(o),e.encryptionScheme.encUnPad(r.toBuffer(e.encryptedDataLength)))}}}},3752:(e,t,s)=>{var i=s(6113),n=s(2057),r=s(7178);e.exports=function(e,t){var o=s(9107)(e,t),a=r.pkcs1.makeScheme(e,t);return{encrypt:function(e,s){if(s)return o.encrypt(e,s);var r=n.RSA_PKCS1_OAEP_PADDING;"pkcs1"===t.encryptionScheme&&(r=n.RSA_PKCS1_PADDING),t.encryptionSchemeOptions&&t.encryptionSchemeOptions.padding&&(r=t.encryptionSchemeOptions.padding);var c=e;return r===n.RSA_NO_PADDING&&(c=a.pkcs0pad(e)),i.publicEncrypt({key:t.rsaUtils.exportKey("public"),padding:r},c)},decrypt:function(e,s){if(s)return o.decrypt(e,s);var r=n.RSA_PKCS1_OAEP_PADDING;"pkcs1"===t.encryptionScheme&&(r=n.RSA_PKCS1_PADDING),t.encryptionSchemeOptions&&t.encryptionSchemeOptions.padding&&(r=t.encryptionSchemeOptions.padding);var c=i.privateDecrypt({key:t.rsaUtils.exportKey("private"),padding:r},e);return r===n.RSA_NO_PADDING?a.pkcs0unpad(c):c}}}},2628:(e,t,s)=>{s(222)._,s(222),e.exports={privateExport:function(e,t){return{n:e.n.toBuffer(),e:e.e,d:e.d.toBuffer(),p:e.p.toBuffer(),q:e.q.toBuffer(),dmp1:e.dmp1.toBuffer(),dmq1:e.dmq1.toBuffer(),coeff:e.coeff.toBuffer()}},privateImport:function(e,t,s){if(!(t.n&&t.e&&t.d&&t.p&&t.q&&t.dmp1&&t.dmq1&&t.coeff))throw Error("Invalid key data");e.setPrivate(t.n,t.e,t.d,t.p,t.q,t.dmp1,t.dmq1,t.coeff)},publicExport:function(e,t){return{n:e.n.toBuffer(),e:e.e}},publicImport:function(e,t,s){if(!t.n||!t.e)throw Error("Invalid key data");e.setPublic(t.n,t.e)},autoImport:function(t,s){return!(!s.n||!s.e||(s.d&&s.p&&s.q&&s.dmp1&&s.dmq1&&s.coeff?(e.exports.privateImport(t,s),0):(e.exports.publicImport(t,s),0)))}}},9073:(e,t,s)=>{function i(e){e=e.split("-");for(var t="private",s={type:"default"},i=1;i<e.length;i++)if(e[i])switch(e[i]){case"public":case"private":t=e[i];break;case"pem":case"der":s.type=e[i]}return{scheme:e[0],keyType:t,keyOpt:s}}s(222)._,e.exports={pkcs1:s(6282),pkcs8:s(409),components:s(2628),openssh:s(8689),isPrivateExport:function(t){return e.exports[t]&&"function"==typeof e.exports[t].privateExport},isPrivateImport:function(t){return e.exports[t]&&"function"==typeof e.exports[t].privateImport},isPublicExport:function(t){return e.exports[t]&&"function"==typeof e.exports[t].publicExport},isPublicImport:function(t){return e.exports[t]&&"function"==typeof e.exports[t].publicImport},detectAndImport:function(t,s,n){if(void 0===n){for(var r in e.exports)if("function"==typeof e.exports[r].autoImport&&e.exports[r].autoImport(t,s))return!0}else if(n){var o=i(n);if(!e.exports[o.scheme])throw Error("Unsupported key format");"private"===o.keyType?e.exports[o.scheme].privateImport(t,s,o.keyOpt):e.exports[o.scheme].publicImport(t,s,o.keyOpt)}return!1},detectAndExport:function(t,s){if(s){var n=i(s);if(e.exports[n.scheme]){if("private"===n.keyType){if(!t.isPrivate())throw Error("This is not private key");return e.exports[n.scheme].privateExport(t,n.keyOpt)}if(!t.isPublic())throw Error("This is not public key");return e.exports[n.scheme].publicExport(t,n.keyOpt)}throw Error("Unsupported key format")}}}},8689:(e,t,s)=>{var i=s(222)._,n=s(222),r=s(8359);const o="-----BEGIN OPENSSH PRIVATE KEY-----",a="-----END OPENSSH PRIVATE KEY-----";function c(e){const t=e.buf.readInt32BE(e.off);e.off+=4;const s=e.buf.slice(e.off,e.off+t);return e.off+=t,s}function h(e,t){e.buf.writeInt32BE(t.byteLength,e.off),e.off+=4,e.off+=t.copy(e.buf,e.off)}e.exports={privateExport:function(e,t){const s=e.n.toBuffer();let i=Buffer.alloc(4);for(i.writeUInt32BE(e.e,0);0===i[0];)i=i.slice(1);const r=e.d.toBuffer(),c=e.coeff.toBuffer(),l=e.p.toBuffer(),u=e.q.toBuffer();let d;d=void 0!==e.sshcomment?Buffer.from(e.sshcomment):Buffer.from([]);const p=15+i.byteLength+4+s.byteLength,f=23+s.byteLength+4+i.byteLength+4+r.byteLength+4+c.byteLength+4+l.byteLength+4+u.byteLength+4+d.byteLength;let g=43+p+4+f;g+=8*Math.ceil(f/8)-f;const m=Buffer.alloc(g),y={buf:m,off:0};m.write("openssh-key-v1","utf8"),m.writeUInt8(0,14),y.off+=15,h(y,Buffer.from("none")),h(y,Buffer.from("none")),h(y,Buffer.from("")),y.off=y.buf.writeUInt32BE(1,y.off),y.off=y.buf.writeUInt32BE(p,y.off),h(y,Buffer.from("ssh-rsa")),h(y,i),h(y,s),y.off=y.buf.writeUInt32BE(g-47-p,y.off),y.off+=8,h(y,Buffer.from("ssh-rsa")),h(y,s),h(y,i),h(y,r),h(y,c),h(y,l),h(y,u),h(y,d);let v=1;for(;y.off<g;)y.off=y.buf.writeUInt8(v++,y.off);return"der"===t.type?y.buf:o+"\n"+n.linebrk(m.toString("base64"),70)+"\n"+a+"\n"},privateImport:function(e,t,s){var h;if("der"!==(s=s||{}).type){if(Buffer.isBuffer(t)&&(t=t.toString("utf8")),!i.isString(t))throw Error("Unsupported key format");var l=n.trimSurroundingText(t,o,a).replace(/\s+|\n\r|\n|\r$/gm,"");h=Buffer.from(l,"base64")}else{if(!Buffer.isBuffer(t))throw Error("Unsupported key format");h=t}const u={buf:h,off:0};if("openssh-key-v1"!==h.slice(0,14).toString("ascii"))throw"Invalid file format.";if(u.off+=15,"none"!==c(u).toString("ascii"))throw Error("Unsupported key type");if("none"!==c(u).toString("ascii"))throw Error("Unsupported key type");if(""!==c(u).toString("ascii"))throw Error("Unsupported key type");if(u.off+=4,u.off+=4,"ssh-rsa"!==c(u).toString("ascii"))throw Error("Unsupported key type");if(c(u),c(u),u.off+=12,"ssh-rsa"!==c(u).toString("ascii"))throw Error("Unsupported key type");const d=c(u),p=c(u),f=c(u),g=c(u),m=c(u),y=c(u),v=new r(f),w=new r(y),S=new r(m),b=v.mod(S.subtract(r.ONE)),E=v.mod(w.subtract(r.ONE));e.setPrivate(d,p,f,m,y,b.toBuffer(),E.toBuffer(),g),e.sshcomment=c(u).toString("ascii")},publicExport:function(e,t){let s=Buffer.alloc(4);for(s.writeUInt32BE(e.e,0);0===s[0];)s=s.slice(1);const i=e.n.toBuffer(),n=Buffer.alloc(s.byteLength+4+i.byteLength+4+"ssh-rsa".length+4),r={buf:n,off:0};h(r,Buffer.from("ssh-rsa")),h(r,s),h(r,i);let o=e.sshcomment||"";return"der"===t.type?r.buf:"ssh-rsa "+n.toString("base64")+" "+o+"\n"},publicImport:function(e,t,s){var n;if("der"!==(s=s||{}).type){if(Buffer.isBuffer(t)&&(t=t.toString("utf8")),!i.isString(t))throw Error("Unsupported key format");{if("ssh-rsa "!==t.substring(0,8))throw Error("Unsupported key format");let s=t.indexOf(" ",8);-1===s?s=t.length:e.sshcomment=t.substring(s+1).replace(/\s+|\n\r|\n|\r$/gm,"");const i=t.substring(8,s).replace(/\s+|\n\r|\n|\r$/gm,"");n=Buffer.from(i,"base64")}}else{if(!Buffer.isBuffer(t))throw Error("Unsupported key format");n=t}const r={buf:n,off:0},o=c(r).toString("ascii");if("ssh-rsa"!==o)throw Error("Invalid key type: "+o);const a=c(r),h=c(r);e.setPublic(h,a)},autoImport:function(t,s){return/^[\S\s]*-----BEGIN OPENSSH PRIVATE KEY-----\s*(?=(([A-Za-z0-9+/=]+\s*)+))\1-----END OPENSSH PRIVATE KEY-----[\S\s]*$/g.test(s)?(e.exports.privateImport(t,s),!0):!!/^[\S\s]*ssh-rsa \s*(?=(([A-Za-z0-9+/=]+\s*)+))\1[\S\s]*$/g.test(s)&&(e.exports.publicImport(t,s),!0)}}},6282:(e,t,s)=>{var i=s(2803).Ber,n=s(222)._,r=s(222);const o="-----BEGIN RSA PRIVATE KEY-----",a="-----END RSA PRIVATE KEY-----",c="-----BEGIN RSA PUBLIC KEY-----",h="-----END RSA PUBLIC KEY-----";e.exports={privateExport:function(e,t){t=t||{};var s=e.n.toBuffer(),n=e.d.toBuffer(),c=e.p.toBuffer(),h=e.q.toBuffer(),l=e.dmp1.toBuffer(),u=e.dmq1.toBuffer(),d=e.coeff.toBuffer(),p=s.length+n.length+c.length+h.length+l.length+u.length+d.length+512,f=new i.Writer({size:p});return f.startSequence(),f.writeInt(0),f.writeBuffer(s,2),f.writeInt(e.e),f.writeBuffer(n,2),f.writeBuffer(c,2),f.writeBuffer(h,2),f.writeBuffer(l,2),f.writeBuffer(u,2),f.writeBuffer(d,2),f.endSequence(),"der"===t.type?f.buffer:o+"\n"+r.linebrk(f.buffer.toString("base64"),64)+"\n"+a},privateImport:function(e,t,s){var c;if("der"!==(s=s||{}).type){if(Buffer.isBuffer(t)&&(t=t.toString("utf8")),!n.isString(t))throw Error("Unsupported key format");var h=r.trimSurroundingText(t,o,a).replace(/\s+|\n\r|\n|\r$/gm,"");c=Buffer.from(h,"base64")}else{if(!Buffer.isBuffer(t))throw Error("Unsupported key format");c=t}var l=new i.Reader(c);l.readSequence(),l.readString(2,!0),e.setPrivate(l.readString(2,!0),l.readString(2,!0),l.readString(2,!0),l.readString(2,!0),l.readString(2,!0),l.readString(2,!0),l.readString(2,!0),l.readString(2,!0))},publicExport:function(e,t){t=t||{};var s=e.n.toBuffer(),n=s.length+512,o=new i.Writer({size:n});return o.startSequence(),o.writeBuffer(s,2),o.writeInt(e.e),o.endSequence(),"der"===t.type?o.buffer:c+"\n"+r.linebrk(o.buffer.toString("base64"),64)+"\n"+h},publicImport:function(e,t,s){var o;if("der"!==(s=s||{}).type){if(Buffer.isBuffer(t)&&(t=t.toString("utf8")),n.isString(t)){var a=r.trimSurroundingText(t,c,h).replace(/\s+|\n\r|\n|\r$/gm,"");o=Buffer.from(a,"base64")}}else{if(!Buffer.isBuffer(t))throw Error("Unsupported key format");o=t}var l=new i.Reader(o);l.readSequence(),e.setPublic(l.readString(2,!0),l.readString(2,!0))},autoImport:function(t,s){return/^[\S\s]*-----BEGIN RSA PRIVATE KEY-----\s*(?=(([A-Za-z0-9+/=]+\s*)+))\1-----END RSA PRIVATE KEY-----[\S\s]*$/g.test(s)?(e.exports.privateImport(t,s),!0):!!/^[\S\s]*-----BEGIN RSA PUBLIC KEY-----\s*(?=(([A-Za-z0-9+/=]+\s*)+))\1-----END RSA PUBLIC KEY-----[\S\s]*$/g.test(s)&&(e.exports.publicImport(t,s),!0)}}},409:(e,t,s)=>{var i=s(2803).Ber,n=s(222)._,r="1.2.840.113549.1.1.1",o=s(222);const a="-----BEGIN PRIVATE KEY-----",c="-----END PRIVATE KEY-----",h="-----BEGIN PUBLIC KEY-----",l="-----END PUBLIC KEY-----";e.exports={privateExport:function(e,t){t=t||{};var s=e.n.toBuffer(),n=e.d.toBuffer(),h=e.p.toBuffer(),l=e.q.toBuffer(),u=e.dmp1.toBuffer(),d=e.dmq1.toBuffer(),p=e.coeff.toBuffer(),f=s.length+n.length+h.length+l.length+u.length+d.length+p.length+512,g=new i.Writer({size:f});g.startSequence(),g.writeInt(0),g.writeBuffer(s,2),g.writeInt(e.e),g.writeBuffer(n,2),g.writeBuffer(h,2),g.writeBuffer(l,2),g.writeBuffer(u,2),g.writeBuffer(d,2),g.writeBuffer(p,2),g.endSequence();var m=new i.Writer({size:f});return m.startSequence(),m.writeInt(0),m.startSequence(),m.writeOID(r),m.writeNull(),m.endSequence(),m.writeBuffer(g.buffer,4),m.endSequence(),"der"===t.type?m.buffer:a+"\n"+o.linebrk(m.buffer.toString("base64"),64)+"\n"+c},privateImport:function(e,t,s){var h;if("der"!==(s=s||{}).type){if(Buffer.isBuffer(t)&&(t=t.toString("utf8")),!n.isString(t))throw Error("Unsupported key format");var l=o.trimSurroundingText(t,a,c).replace("-----END PRIVATE KEY-----","").replace(/\s+|\n\r|\n|\r$/gm,"");h=Buffer.from(l,"base64")}else{if(!Buffer.isBuffer(t))throw Error("Unsupported key format");h=t}var u=new i.Reader(h);if(u.readSequence(),u.readInt(0),new i.Reader(u.readString(48,!0)).readOID(6,!0)!==r)throw Error("Invalid Public key format");var d=new i.Reader(u.readString(4,!0));d.readSequence(),d.readString(2,!0),e.setPrivate(d.readString(2,!0),d.readString(2,!0),d.readString(2,!0),d.readString(2,!0),d.readString(2,!0),d.readString(2,!0),d.readString(2,!0),d.readString(2,!0))},publicExport:function(e,t){t=t||{};var s=e.n.toBuffer(),n=s.length+512,a=new i.Writer({size:n});a.writeByte(0),a.startSequence(),a.writeBuffer(s,2),a.writeInt(e.e),a.endSequence();var c=new i.Writer({size:n});return c.startSequence(),c.startSequence(),c.writeOID(r),c.writeNull(),c.endSequence(),c.writeBuffer(a.buffer,3),c.endSequence(),"der"===t.type?c.buffer:h+"\n"+o.linebrk(c.buffer.toString("base64"),64)+"\n"+l},publicImport:function(e,t,s){var a;if("der"!==(s=s||{}).type){if(Buffer.isBuffer(t)&&(t=t.toString("utf8")),n.isString(t)){var c=o.trimSurroundingText(t,h,l).replace(/\s+|\n\r|\n|\r$/gm,"");a=Buffer.from(c,"base64")}}else{if(!Buffer.isBuffer(t))throw Error("Unsupported key format");a=t}var u=new i.Reader(a);if(u.readSequence(),new i.Reader(u.readString(48,!0)).readOID(6,!0)!==r)throw Error("Invalid Public key format");var d=new i.Reader(u.readString(3,!0));d.readByte(),d.readSequence(),e.setPublic(d.readString(2,!0),d.readString(2,!0))},autoImport:function(t,s){return/^[\S\s]*-----BEGIN PRIVATE KEY-----\s*(?=(([A-Za-z0-9+/=]+\s*)+))\1-----END PRIVATE KEY-----[\S\s]*$/g.test(s)?(e.exports.privateImport(t,s),!0):!!/^[\S\s]*-----BEGIN PUBLIC KEY-----\s*(?=(([A-Za-z0-9+/=]+\s*)+))\1-----END PUBLIC KEY-----[\S\s]*$/g.test(s)&&(e.exports.publicImport(t,s),!0)}}},8359:(e,t,s)=>{var i=s(6113),n=s(222)._;function r(e,t){null!=e&&("number"==typeof e?this.fromNumber(e,t):Buffer.isBuffer(e)?this.fromBuffer(e):null==t&&"string"!=typeof e?this.fromByteArray(e):this.fromString(e,t))}function o(){return new r(null)}r.prototype.am=function(e,t,s,i,n,r){for(var o=16383&t,a=t>>14;--r>=0;){var c=16383&this[e],h=this[e++]>>14,l=a*c+h*o;n=((c=o*c+((16383&l)<<14)+s[i]+n)>>28)+(l>>14)+a*h,s[i++]=268435455&c}return n},r.prototype.DB=28,r.prototype.DM=268435455,r.prototype.DV=1<<28,r.prototype.FV=Math.pow(2,52),r.prototype.F1=24,r.prototype.F2=4;var a,c,h=new Array;for(a="0".charCodeAt(0),c=0;c<=9;++c)h[a++]=c;for(a="a".charCodeAt(0),c=10;c<36;++c)h[a++]=c;for(a="A".charCodeAt(0),c=10;c<36;++c)h[a++]=c;function l(e){return"0123456789abcdefghijklmnopqrstuvwxyz".charAt(e)}function u(e,t){var s=h[e.charCodeAt(t)];return null==s?-1:s}function d(e){var t=o();return t.fromInt(e),t}function p(e){var t,s=1;return 0!=(t=e>>>16)&&(e=t,s+=16),0!=(t=e>>8)&&(e=t,s+=8),0!=(t=e>>4)&&(e=t,s+=4),0!=(t=e>>2)&&(e=t,s+=2),0!=(t=e>>1)&&(e=t,s+=1),s}function f(e){this.m=e}function g(e){this.m=e,this.mp=e.invDigit(),this.mpl=32767&this.mp,this.mph=this.mp>>15,this.um=(1<<e.DB-15)-1,this.mt2=2*e.t}function m(e,t){return e&t}function y(e,t){return e|t}function v(e,t){return e^t}function w(e,t){return e&~t}function S(e){if(0===e)return-1;var t=0;return 0==(65535&e)&&(e>>=16,t+=16),0==(255&e)&&(e>>=8,t+=8),0==(15&e)&&(e>>=4,t+=4),0==(3&e)&&(e>>=2,t+=2),0==(1&e)&&++t,t}function b(e){for(var t=0;0!=e;)e&=e-1,++t;return t}function E(){}function C(e){return e}function R(e){this.r2=o(),this.q3=o(),r.ONE.dlShiftTo(2*e.t,this.r2),this.mu=this.r2.divide(e),this.m=e}f.prototype.convert=function(e){return e.s<0||e.compareTo(this.m)>=0?e.mod(this.m):e},f.prototype.revert=function(e){return e},f.prototype.reduce=function(e){e.divRemTo(this.m,null,e)},f.prototype.mulTo=function(e,t,s){e.multiplyTo(t,s),this.reduce(s)},f.prototype.sqrTo=function(e,t){e.squareTo(t),this.reduce(t)},g.prototype.convert=function(e){var t=o();return e.abs().dlShiftTo(this.m.t,t),t.divRemTo(this.m,null,t),e.s<0&&t.compareTo(r.ZERO)>0&&this.m.subTo(t,t),t},g.prototype.revert=function(e){var t=o();return e.copyTo(t),this.reduce(t),t},g.prototype.reduce=function(e){for(;e.t<=this.mt2;)e[e.t++]=0;for(var t=0;t<this.m.t;++t){var s=32767&e[t],i=s*this.mpl+((s*this.mph+(e[t]>>15)*this.mpl&this.um)<<15)&e.DM;for(e[s=t+this.m.t]+=this.m.am(0,i,e,t,0,this.m.t);e[s]>=e.DV;)e[s]-=e.DV,e[++s]++}e.clamp(),e.drShiftTo(this.m.t,e),e.compareTo(this.m)>=0&&e.subTo(this.m,e)},g.prototype.mulTo=function(e,t,s){e.multiplyTo(t,s),this.reduce(s)},g.prototype.sqrTo=function(e,t){e.squareTo(t),this.reduce(t)},E.prototype.convert=C,E.prototype.revert=C,E.prototype.mulTo=function(e,t,s){e.multiplyTo(t,s)},E.prototype.sqrTo=function(e,t){e.squareTo(t)},R.prototype.convert=function(e){if(e.s<0||e.t>2*this.m.t)return e.mod(this.m);if(e.compareTo(this.m)<0)return e;var t=o();return e.copyTo(t),this.reduce(t),t},R.prototype.revert=function(e){return e},R.prototype.reduce=function(e){for(e.drShiftTo(this.m.t-1,this.r2),e.t>this.m.t+1&&(e.t=this.m.t+1,e.clamp()),this.mu.multiplyUpperTo(this.r2,this.m.t+1,this.q3),this.m.multiplyLowerTo(this.q3,this.m.t+1,this.r2);e.compareTo(this.r2)<0;)e.dAddOffset(1,this.m.t+1);for(e.subTo(this.r2,e);e.compareTo(this.m)>=0;)e.subTo(this.m,e)},R.prototype.mulTo=function(e,t,s){e.multiplyTo(t,s),this.reduce(s)},R.prototype.sqrTo=function(e,t){e.squareTo(t),this.reduce(t)};var P=[2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,103,107,109,113,127,131,137,139,149,151,157,163,167,173,179,181,191,193,197,199,211,223,227,229,233,239,241,251,257,263,269,271,277,281,283,293,307,311,313,317,331,337,347,349,353,359,367,373,379,383,389,397,401,409,419,421,431,433,439,443,449,457,461,463,467,479,487,491,499,503,509,521,523,541,547,557,563,569,571,577,587,593,599,601,607,613,617,619,631,641,643,647,653,659,661,673,677,683,691,701,709,719,727,733,739,743,751,757,761,769,773,787,797,809,811,821,823,827,829,839,853,857,859,863,877,881,883,887,907,911,919,929,937,941,947,953,967,971,977,983,991,997],T=(1<<26)/P[P.length-1];r.prototype.copyTo=function(e){for(var t=this.t-1;t>=0;--t)e[t]=this[t];e.t=this.t,e.s=this.s},r.prototype.fromInt=function(e){this.t=1,this.s=e<0?-1:0,e>0?this[0]=e:e<-1?this[0]=e+DV:this.t=0},r.prototype.fromString=function(e,t,s){var i;switch(t){case 2:i=1;break;case 4:i=2;break;case 8:i=3;break;case 16:i=4;break;case 32:i=5;break;case 256:i=8;break;default:return void this.fromRadix(e,t)}this.t=0,this.s=0;for(var n=e.length,o=!1,a=0;--n>=0;){var c=8==i?255&e[n]:u(e,n);c<0?"-"==e.charAt(n)&&(o=!0):(o=!1,0===a?this[this.t++]=c:a+i>this.DB?(this[this.t-1]|=(c&(1<<this.DB-a)-1)<<a,this[this.t++]=c>>this.DB-a):this[this.t-1]|=c<<a,(a+=i)>=this.DB&&(a-=this.DB))}s||8!=i||0==(128&e[0])||(this.s=-1,a>0&&(this[this.t-1]|=(1<<this.DB-a)-1<<a)),this.clamp(),o&&r.ZERO.subTo(this,this)},r.prototype.fromByteArray=function(e,t){this.fromString(e,256,t)},r.prototype.fromBuffer=function(e){this.fromString(e,256,!0)},r.prototype.clamp=function(){for(var e=this.s&this.DM;this.t>0&&this[this.t-1]==e;)--this.t},r.prototype.dlShiftTo=function(e,t){var s;for(s=this.t-1;s>=0;--s)t[s+e]=this[s];for(s=e-1;s>=0;--s)t[s]=0;t.t=this.t+e,t.s=this.s},r.prototype.drShiftTo=function(e,t){for(var s=e;s<this.t;++s)t[s-e]=this[s];t.t=Math.max(this.t-e,0),t.s=this.s},r.prototype.lShiftTo=function(e,t){var s,i=e%this.DB,n=this.DB-i,r=(1<<n)-1,o=Math.floor(e/this.DB),a=this.s<<i&this.DM;for(s=this.t-1;s>=0;--s)t[s+o+1]=this[s]>>n|a,a=(this[s]&r)<<i;for(s=o-1;s>=0;--s)t[s]=0;t[o]=a,t.t=this.t+o+1,t.s=this.s,t.clamp()},r.prototype.rShiftTo=function(e,t){t.s=this.s;var s=Math.floor(e/this.DB);if(s>=this.t)t.t=0;else{var i=e%this.DB,n=this.DB-i,r=(1<<i)-1;t[0]=this[s]>>i;for(var o=s+1;o<this.t;++o)t[o-s-1]|=(this[o]&r)<<n,t[o-s]=this[o]>>i;i>0&&(t[this.t-s-1]|=(this.s&r)<<n),t.t=this.t-s,t.clamp()}},r.prototype.subTo=function(e,t){for(var s=0,i=0,n=Math.min(e.t,this.t);s<n;)i+=this[s]-e[s],t[s++]=i&this.DM,i>>=this.DB;if(e.t<this.t){for(i-=e.s;s<this.t;)i+=this[s],t[s++]=i&this.DM,i>>=this.DB;i+=this.s}else{for(i+=this.s;s<e.t;)i-=e[s],t[s++]=i&this.DM,i>>=this.DB;i-=e.s}t.s=i<0?-1:0,i<-1?t[s++]=this.DV+i:i>0&&(t[s++]=i),t.t=s,t.clamp()},r.prototype.multiplyTo=function(e,t){var s=this.abs(),i=e.abs(),n=s.t;for(t.t=n+i.t;--n>=0;)t[n]=0;for(n=0;n<i.t;++n)t[n+s.t]=s.am(0,i[n],t,n,0,s.t);t.s=0,t.clamp(),this.s!=e.s&&r.ZERO.subTo(t,t)},r.prototype.squareTo=function(e){for(var t=this.abs(),s=e.t=2*t.t;--s>=0;)e[s]=0;for(s=0;s<t.t-1;++s){var i=t.am(s,t[s],e,2*s,0,1);(e[s+t.t]+=t.am(s+1,2*t[s],e,2*s+1,i,t.t-s-1))>=t.DV&&(e[s+t.t]-=t.DV,e[s+t.t+1]=1)}e.t>0&&(e[e.t-1]+=t.am(s,t[s],e,2*s,0,1)),e.s=0,e.clamp()},r.prototype.divRemTo=function(e,t,s){var i=e.abs();if(!(i.t<=0)){var n=this.abs();if(n.t<i.t)return null!=t&&t.fromInt(0),void(null!=s&&this.copyTo(s));null==s&&(s=o());var a=o(),c=this.s,h=e.s,l=this.DB-p(i[i.t-1]);l>0?(i.lShiftTo(l,a),n.lShiftTo(l,s)):(i.copyTo(a),n.copyTo(s));var u=a.t,d=a[u-1];if(0!==d){var f=d*(1<<this.F1)+(u>1?a[u-2]>>this.F2:0),g=this.FV/f,m=(1<<this.F1)/f,y=1<<this.F2,v=s.t,w=v-u,S=null==t?o():t;for(a.dlShiftTo(w,S),s.compareTo(S)>=0&&(s[s.t++]=1,s.subTo(S,s)),r.ONE.dlShiftTo(u,S),S.subTo(a,a);a.t<u;)a[a.t++]=0;for(;--w>=0;){var b=s[--v]==d?this.DM:Math.floor(s[v]*g+(s[v-1]+y)*m);if((s[v]+=a.am(0,b,s,w,0,u))<b)for(a.dlShiftTo(w,S),s.subTo(S,s);s[v]<--b;)s.subTo(S,s)}null!=t&&(s.drShiftTo(u,t),c!=h&&r.ZERO.subTo(t,t)),s.t=u,s.clamp(),l>0&&s.rShiftTo(l,s),c<0&&r.ZERO.subTo(s,s)}}},r.prototype.invDigit=function(){if(this.t<1)return 0;var e=this[0];if(0==(1&e))return 0;var t=3&e;return(t=(t=(t=(t=t*(2-(15&e)*t)&15)*(2-(255&e)*t)&255)*(2-((65535&e)*t&65535))&65535)*(2-e*t%this.DV)%this.DV)>0?this.DV-t:-t},r.prototype.isEven=function(){return 0===(this.t>0?1&this[0]:this.s)},r.prototype.exp=function(e,t){if(e>4294967295||e<1)return r.ONE;var s=o(),i=o(),n=t.convert(this),a=p(e)-1;for(n.copyTo(s);--a>=0;)if(t.sqrTo(s,i),(e&1<<a)>0)t.mulTo(i,n,s);else{var c=s;s=i,i=c}return t.revert(s)},r.prototype.chunkSize=function(e){return Math.floor(Math.LN2*this.DB/Math.log(e))},r.prototype.toRadix=function(e){if(null==e&&(e=10),0===this.signum()||e<2||e>36)return"0";var t=this.chunkSize(e),s=Math.pow(e,t),i=d(s),n=o(),r=o(),a="";for(this.divRemTo(i,n,r);n.signum()>0;)a=(s+r.intValue()).toString(e).substr(1)+a,n.divRemTo(i,n,r);return r.intValue().toString(e)+a},r.prototype.fromRadix=function(e,t){this.fromInt(0),null==t&&(t=10);for(var s=this.chunkSize(t),i=Math.pow(t,s),n=!1,o=0,a=0,c=0;c<e.length;++c){var h=u(e,c);h<0?"-"==e.charAt(c)&&0===this.signum()&&(n=!0):(a=t*a+h,++o>=s&&(this.dMultiply(i),this.dAddOffset(a,0),o=0,a=0))}o>0&&(this.dMultiply(Math.pow(t,o)),this.dAddOffset(a,0)),n&&r.ZERO.subTo(this,this)},r.prototype.fromNumber=function(e,t){if("number"==typeof t)if(e<2)this.fromInt(1);else for(this.fromNumber(e),this.testBit(e-1)||this.bitwiseTo(r.ONE.shiftLeft(e-1),y,this),this.isEven()&&this.dAddOffset(1,0);!this.isProbablePrime(t);)this.dAddOffset(2,0),this.bitLength()>e&&this.subTo(r.ONE.shiftLeft(e-1),this);else{var s=i.randomBytes(1+(e>>3)),n=7&e;n>0?s[0]&=(1<<n)-1:s[0]=0,this.fromByteArray(s)}},r.prototype.bitwiseTo=function(e,t,s){var i,n,r=Math.min(e.t,this.t);for(i=0;i<r;++i)s[i]=t(this[i],e[i]);if(e.t<this.t){for(n=e.s&this.DM,i=r;i<this.t;++i)s[i]=t(this[i],n);s.t=this.t}else{for(n=this.s&this.DM,i=r;i<e.t;++i)s[i]=t(n,e[i]);s.t=e.t}s.s=t(this.s,e.s),s.clamp()},r.prototype.changeBit=function(e,t){var s=r.ONE.shiftLeft(e);return this.bitwiseTo(s,t,s),s},r.prototype.addTo=function(e,t){for(var s=0,i=0,n=Math.min(e.t,this.t);s<n;)i+=this[s]+e[s],t[s++]=i&this.DM,i>>=this.DB;if(e.t<this.t){for(i+=e.s;s<this.t;)i+=this[s],t[s++]=i&this.DM,i>>=this.DB;i+=this.s}else{for(i+=this.s;s<e.t;)i+=e[s],t[s++]=i&this.DM,i>>=this.DB;i+=e.s}t.s=i<0?-1:0,i>0?t[s++]=i:i<-1&&(t[s++]=this.DV+i),t.t=s,t.clamp()},r.prototype.dMultiply=function(e){this[this.t]=this.am(0,e-1,this,0,0,this.t),++this.t,this.clamp()},r.prototype.dAddOffset=function(e,t){if(0!==e){for(;this.t<=t;)this[this.t++]=0;for(this[t]+=e;this[t]>=this.DV;)this[t]-=this.DV,++t>=this.t&&(this[this.t++]=0),++this[t]}},r.prototype.multiplyLowerTo=function(e,t,s){var i,n=Math.min(this.t+e.t,t);for(s.s=0,s.t=n;n>0;)s[--n]=0;for(i=s.t-this.t;n<i;++n)s[n+this.t]=this.am(0,e[n],s,n,0,this.t);for(i=Math.min(e.t,t);n<i;++n)this.am(0,e[n],s,n,0,t-n);s.clamp()},r.prototype.multiplyUpperTo=function(e,t,s){--t;var i=s.t=this.t+e.t-t;for(s.s=0;--i>=0;)s[i]=0;for(i=Math.max(t-this.t,0);i<e.t;++i)s[this.t+i-t]=this.am(t-i,e[i],s,0,0,this.t+i-t);s.clamp(),s.drShiftTo(1,s)},r.prototype.modInt=function(e){if(e<=0)return 0;var t=this.DV%e,s=this.s<0?e-1:0;if(this.t>0)if(0===t)s=this[0]%e;else for(var i=this.t-1;i>=0;--i)s=(t*s+this[i])%e;return s},r.prototype.millerRabin=function(e){var t=this.subtract(r.ONE),s=t.getLowestSetBit();if(s<=0)return!1;var i=t.shiftRight(s);(e=e+1>>1)>P.length&&(e=P.length);for(var n=o(),a=0;a<e;++a){n.fromInt(P[Math.floor(Math.random()*P.length)]);var c=n.modPow(i,this);if(0!=c.compareTo(r.ONE)&&0!=c.compareTo(t)){for(var h=1;h++<s&&0!=c.compareTo(t);)if(0===(c=c.modPowInt(2,this)).compareTo(r.ONE))return!1;if(0!=c.compareTo(t))return!1}}return!0},r.prototype.toString=function(e){if(this.s<0)return"-"+this.negate().toString(e);var t;if(16==e)t=4;else if(8==e)t=3;else if(2==e)t=1;else if(32==e)t=5;else{if(4!=e)return this.toRadix(e);t=2}var s,i=(1<<t)-1,n=!1,r="",o=this.t,a=this.DB-o*this.DB%t;if(o-- >0)for(a<this.DB&&(s=this[o]>>a)>0&&(n=!0,r=l(s));o>=0;)a<t?(s=(this[o]&(1<<a)-1)<<t-a,s|=this[--o]>>(a+=this.DB-t)):(s=this[o]>>(a-=t)&i,a<=0&&(a+=this.DB,--o)),s>0&&(n=!0),n&&(r+=l(s));return n?r:"0"},r.prototype.negate=function(){var e=o();return r.ZERO.subTo(this,e),e},r.prototype.abs=function(){return this.s<0?this.negate():this},r.prototype.compareTo=function(e){var t=this.s-e.s;if(0!=t)return t;var s=this.t;if(0!=(t=s-e.t))return this.s<0?-t:t;for(;--s>=0;)if(0!=(t=this[s]-e[s]))return t;return 0},r.prototype.bitLength=function(){return this.t<=0?0:this.DB*(this.t-1)+p(this[this.t-1]^this.s&this.DM)},r.prototype.mod=function(e){var t=o();return this.abs().divRemTo(e,null,t),this.s<0&&t.compareTo(r.ZERO)>0&&e.subTo(t,t),t},r.prototype.modPowInt=function(e,t){var s;return s=e<256||t.isEven()?new f(t):new g(t),this.exp(e,s)},r.prototype.clone=function(){var e=o();return this.copyTo(e),e},r.prototype.intValue=function(){if(this.s<0){if(1==this.t)return this[0]-this.DV;if(0===this.t)return-1}else{if(1==this.t)return this[0];if(0===this.t)return 0}return(this[1]&(1<<32-this.DB)-1)<<this.DB|this[0]},r.prototype.byteValue=function(){return 0==this.t?this.s:this[0]<<24>>24},r.prototype.shortValue=function(){return 0==this.t?this.s:this[0]<<16>>16},r.prototype.signum=function(){return this.s<0?-1:this.t<=0||1==this.t&&this[0]<=0?0:1},r.prototype.toByteArray=function(){var e=this.t,t=new Array;t[0]=this.s;var s,i=this.DB-e*this.DB%8,n=0;if(e-- >0)for(i<this.DB&&(s=this[e]>>i)!=(this.s&this.DM)>>i&&(t[n++]=s|this.s<<this.DB-i);e>=0;)i<8?(s=(this[e]&(1<<i)-1)<<8-i,s|=this[--e]>>(i+=this.DB-8)):(s=this[e]>>(i-=8)&255,i<=0&&(i+=this.DB,--e)),0!=(128&s)&&(s|=-256),0===n&&(128&this.s)!=(128&s)&&++n,(n>0||s!=this.s)&&(t[n++]=s);return t},r.prototype.toBuffer=function(e){var t=Buffer.from(this.toByteArray());if(!0===e&&0===t[0])t=t.slice(1);else if(n.isNumber(e)){if(t.length>e){for(var s=0;s<t.length-e;s++)if(0!==t[s])return null;return t.slice(t.length-e)}if(t.length<e){var i=Buffer.alloc(e);return i.fill(0,0,e-t.length),t.copy(i,e-t.length),i}}return t},r.prototype.equals=function(e){return 0==this.compareTo(e)},r.prototype.min=function(e){return this.compareTo(e)<0?this:e},r.prototype.max=function(e){return this.compareTo(e)>0?this:e},r.prototype.and=function(e){var t=o();return this.bitwiseTo(e,m,t),t},r.prototype.or=function(e){var t=o();return this.bitwiseTo(e,y,t),t},r.prototype.xor=function(e){var t=o();return this.bitwiseTo(e,v,t),t},r.prototype.andNot=function(e){var t=o();return this.bitwiseTo(e,w,t),t},r.prototype.not=function(){for(var e=o(),t=0;t<this.t;++t)e[t]=this.DM&~this[t];return e.t=this.t,e.s=~this.s,e},r.prototype.shiftLeft=function(e){var t=o();return e<0?this.rShiftTo(-e,t):this.lShiftTo(e,t),t},r.prototype.shiftRight=function(e){var t=o();return e<0?this.lShiftTo(-e,t):this.rShiftTo(e,t),t},r.prototype.getLowestSetBit=function(){for(var e=0;e<this.t;++e)if(0!=this[e])return e*this.DB+S(this[e]);return this.s<0?this.t*this.DB:-1},r.prototype.bitCount=function(){for(var e=0,t=this.s&this.DM,s=0;s<this.t;++s)e+=b(this[s]^t);return e},r.prototype.testBit=function(e){var t=Math.floor(e/this.DB);return t>=this.t?0!=this.s:0!=(this[t]&1<<e%this.DB)},r.prototype.setBit=function(e){return this.changeBit(e,y)},r.prototype.clearBit=function(e){return this.changeBit(e,w)},r.prototype.flipBit=function(e){return this.changeBit(e,v)},r.prototype.add=function(e){var t=o();return this.addTo(e,t),t},r.prototype.subtract=function(e){var t=o();return this.subTo(e,t),t},r.prototype.multiply=function(e){var t=o();return this.multiplyTo(e,t),t},r.prototype.divide=function(e){var t=o();return this.divRemTo(e,t,null),t},r.prototype.remainder=function(e){var t=o();return this.divRemTo(e,null,t),t},r.prototype.divideAndRemainder=function(e){var t=o(),s=o();return this.divRemTo(e,t,s),new Array(t,s)},r.prototype.modPow=function(e,t){var s,i,n=e.bitLength(),r=d(1);if(n<=0)return r;s=n<18?1:n<48?3:n<144?4:n<768?5:6,i=n<8?new f(t):t.isEven()?new R(t):new g(t);var a=new Array,c=3,h=s-1,l=(1<<s)-1;if(a[1]=i.convert(this),s>1){var u=o();for(i.sqrTo(a[1],u);c<=l;)a[c]=o(),i.mulTo(u,a[c-2],a[c]),c+=2}var m,y,v=e.t-1,w=!0,S=o();for(n=p(e[v])-1;v>=0;){for(n>=h?m=e[v]>>n-h&l:(m=(e[v]&(1<<n+1)-1)<<h-n,v>0&&(m|=e[v-1]>>this.DB+n-h)),c=s;0==(1&m);)m>>=1,--c;if((n-=c)<0&&(n+=this.DB,--v),w)a[m].copyTo(r),w=!1;else{for(;c>1;)i.sqrTo(r,S),i.sqrTo(S,r),c-=2;c>0?i.sqrTo(r,S):(y=r,r=S,S=y),i.mulTo(S,a[m],r)}for(;v>=0&&0==(e[v]&1<<n);)i.sqrTo(r,S),y=r,r=S,S=y,--n<0&&(n=this.DB-1,--v)}return i.revert(r)},r.prototype.modInverse=function(e){var t=e.isEven();if(this.isEven()&&t||0===e.signum())return r.ZERO;for(var s=e.clone(),i=this.clone(),n=d(1),o=d(0),a=d(0),c=d(1);0!=s.signum();){for(;s.isEven();)s.rShiftTo(1,s),t?(n.isEven()&&o.isEven()||(n.addTo(this,n),o.subTo(e,o)),n.rShiftTo(1,n)):o.isEven()||o.subTo(e,o),o.rShiftTo(1,o);for(;i.isEven();)i.rShiftTo(1,i),t?(a.isEven()&&c.isEven()||(a.addTo(this,a),c.subTo(e,c)),a.rShiftTo(1,a)):c.isEven()||c.subTo(e,c),c.rShiftTo(1,c);s.compareTo(i)>=0?(s.subTo(i,s),t&&n.subTo(a,n),o.subTo(c,o)):(i.subTo(s,i),t&&a.subTo(n,a),c.subTo(o,c))}return 0!=i.compareTo(r.ONE)?r.ZERO:c.compareTo(e)>=0?c.subtract(e):c.signum()<0?(c.addTo(e,c),c.signum()<0?c.add(e):c):c},r.prototype.pow=function(e){return this.exp(e,new E)},r.prototype.gcd=function(e){var t=this.s<0?this.negate():this.clone(),s=e.s<0?e.negate():e.clone();if(t.compareTo(s)<0){var i=t;t=s,s=i}var n=t.getLowestSetBit(),r=s.getLowestSetBit();if(r<0)return t;for(n<r&&(r=n),r>0&&(t.rShiftTo(r,t),s.rShiftTo(r,s));t.signum()>0;)(n=t.getLowestSetBit())>0&&t.rShiftTo(n,t),(n=s.getLowestSetBit())>0&&s.rShiftTo(n,s),t.compareTo(s)>=0?(t.subTo(s,t),t.rShiftTo(1,t)):(s.subTo(t,s),s.rShiftTo(1,s));return r>0&&s.lShiftTo(r,s),s},r.prototype.isProbablePrime=function(e){var t,s=this.abs();if(1==s.t&&s[0]<=P[P.length-1]){for(t=0;t<P.length;++t)if(s[0]==P[t])return!0;return!1}if(s.isEven())return!1;for(t=1;t<P.length;){for(var i=P[t],n=t+1;n<P.length&&i<T;)i*=P[n++];for(i=s.modInt(i);t<n;)if(i%P[t++]==0)return!1}return s.millerRabin(e)},r.int2char=l,r.ZERO=d(0),r.ONE=d(1),r.prototype.square=function(){var e=o();return this.squareTo(e),e},e.exports=r},4153:(e,t,s)=>{var i=s(222)._,n=(s(6113),s(8359)),r=s(222),o=s(7178),a=s(2589);t.BigInteger=n,e.exports.Key=function(){function e(){this.n=null,this.e=0,this.d=null,this.p=null,this.q=null,this.dmp1=null,this.dmq1=null,this.coeff=null}return e.prototype.setOptions=function(e){var t=o[e.signingScheme],s=o[e.encryptionScheme];t===s?this.signingScheme=this.encryptionScheme=s.makeScheme(this,e):(this.encryptionScheme=s.makeScheme(this,e),this.signingScheme=t.makeScheme(this,e)),this.encryptEngine=a.getEngine(this,e)},e.prototype.generate=function(e,t){var s=e>>1;this.e=parseInt(t,16);for(var i=new n(t,16);;){for(;this.p=new n(e-s,1),0!==this.p.subtract(n.ONE).gcd(i).compareTo(n.ONE)||!this.p.isProbablePrime(10););for(;this.q=new n(s,1),0!==this.q.subtract(n.ONE).gcd(i).compareTo(n.ONE)||!this.q.isProbablePrime(10););if(this.p.compareTo(this.q)<=0){var r=this.p;this.p=this.q,this.q=r}var o=this.p.subtract(n.ONE),a=this.q.subtract(n.ONE),c=o.multiply(a);if(0===c.gcd(i).compareTo(n.ONE)){if(this.n=this.p.multiply(this.q),this.n.bitLength()<e)continue;this.d=i.modInverse(c),this.dmp1=this.d.mod(o),this.dmq1=this.d.mod(a),this.coeff=this.q.modInverse(this.p);break}}this.$$recalculateCache()},e.prototype.setPrivate=function(e,t,s,o,a,c,h,l){if(!(e&&t&&s&&e.length>0&&(i.isNumber(t)||t.length>0)&&s.length>0))throw Error("Invalid RSA private key");this.n=new n(e),this.e=i.isNumber(t)?t:r.get32IntFromBuffer(t,0),this.d=new n(s),o&&a&&c&&h&&l&&(this.p=new n(o),this.q=new n(a),this.dmp1=new n(c),this.dmq1=new n(h),this.coeff=new n(l)),this.$$recalculateCache()},e.prototype.setPublic=function(e,t){if(!(e&&t&&e.length>0&&(i.isNumber(t)||t.length>0)))throw Error("Invalid RSA public key");this.n=new n(e),this.e=i.isNumber(t)?t:r.get32IntFromBuffer(t,0),this.$$recalculateCache()},e.prototype.$doPrivate=function(e){if(this.p||this.q)return e.modPow(this.d,this.n);for(var t=e.mod(this.p).modPow(this.dmp1,this.p),s=e.mod(this.q).modPow(this.dmq1,this.q);t.compareTo(s)<0;)t=t.add(this.p);return t.subtract(s).multiply(this.coeff).mod(this.p).multiply(this.q).add(s)},e.prototype.$doPublic=function(e){return e.modPowInt(this.e,this.n)},e.prototype.encrypt=function(e,t){var s=[],i=[],n=e.length,r=Math.ceil(n/this.maxMessageLength)||1,o=Math.ceil(n/r||1);if(1==r)s.push(e);else for(var a=0;a<r;a++)s.push(e.slice(a*o,(a+1)*o));for(var c=0;c<s.length;c++)i.push(this.encryptEngine.encrypt(s[c],t));return Buffer.concat(i)},e.prototype.decrypt=function(e,t){if(e.length%this.encryptedDataLength>0)throw Error("Incorrect data or key");for(var s=[],i=0,n=0,r=e.length/this.encryptedDataLength,o=0;o<r;o++)n=(i=o*this.encryptedDataLength)+this.encryptedDataLength,s.push(this.encryptEngine.decrypt(e.slice(i,Math.min(n,e.length)),t));return Buffer.concat(s)},e.prototype.sign=function(e){return this.signingScheme.sign.apply(this.signingScheme,arguments)},e.prototype.verify=function(e,t,s){return this.signingScheme.verify.apply(this.signingScheme,arguments)},e.prototype.isPrivate=function(){return!!(this.n&&this.e&&this.d)},e.prototype.isPublic=function(e){return this.n&&this.e&&!(e&&this.d)||!1},Object.defineProperty(e.prototype,"keySize",{get:function(){return this.cache.keyBitLength}}),Object.defineProperty(e.prototype,"encryptedDataLength",{get:function(){return this.cache.keyByteLength}}),Object.defineProperty(e.prototype,"maxMessageLength",{get:function(){return this.encryptionScheme.maxMessageLength()}}),e.prototype.$$recalculateCache=function(){this.cache=this.cache||{},this.cache.keyBitLength=this.n.bitLength(),this.cache.keyByteLength=this.cache.keyBitLength+6>>3},e}()},6400:(e,t,s)=>{s(8359);var i=s(6113);e.exports={isEncryption:!0,isSignature:!1},e.exports.digestLength={md4:16,md5:16,ripemd160:20,rmd160:20,sha1:20,sha224:28,sha256:32,sha384:48,sha512:64};var n="sha1";e.exports.eme_oaep_mgf1=function(t,s,r){r=r||n;for(var o=e.exports.digestLength[r],a=Math.ceil(s/o),c=Buffer.alloc(o*a),h=Buffer.alloc(4),l=0;l<a;++l){var u=i.createHash(r);u.update(t),h.writeUInt32BE(l,0),u.update(h),u.digest().copy(c,l*o)}return c.slice(0,s)},e.exports.makeScheme=function(t,s){function r(e,t){this.key=e,this.options=t}return r.prototype.maxMessageLength=function(){return this.key.encryptedDataLength-2*e.exports.digestLength[this.options.encryptionSchemeOptions.hash||n]-2},r.prototype.encPad=function(t){var s=this.options.encryptionSchemeOptions.hash||n,r=this.options.encryptionSchemeOptions.mgf||e.exports.eme_oaep_mgf1,o=this.options.encryptionSchemeOptions.label||Buffer.alloc(0),a=this.key.encryptedDataLength,c=e.exports.digestLength[s];if(t.length>a-2*c-2)throw new Error("Message is too long to encode into an encoded message with a length of "+a+" bytes, increaseemLen to fix this error (minimum value for given parameters and options: "+(a-2*c-2)+")");var h=i.createHash(s);h.update(o),h=h.digest();var l=Buffer.alloc(a-t.length-2*c-1);l.fill(0),l[l.length-1]=1;for(var u=Buffer.concat([h,l,t]),d=i.randomBytes(c),p=r(d,u.length,s),f=0;f<u.length;f++)u[f]^=p[f];for(p=r(u,c,s),f=0;f<d.length;f++)d[f]^=p[f];var g=Buffer.alloc(1+d.length+u.length);return g[0]=0,d.copy(g,1),u.copy(g,1+d.length),g},r.prototype.encUnPad=function(t){var s=this.options.encryptionSchemeOptions.hash||n,r=this.options.encryptionSchemeOptions.mgf||e.exports.eme_oaep_mgf1,o=this.options.encryptionSchemeOptions.label||Buffer.alloc(0),a=e.exports.digestLength[s];if(t.length<2*a+2)throw new Error("Error decoding message, the supplied message is not long enough to be a valid OAEP encoded message");for(var c=t.slice(1,a+1),h=t.slice(1+a),l=r(h,a,s),u=0;u<c.length;u++)c[u]^=l[u];for(l=r(c,h.length,s),u=0;u<h.length;u++)h[u]^=l[u];var d=i.createHash(s);if(d.update(o),d=d.digest(),h.slice(0,a).toString("hex")!=d.toString("hex"))throw new Error("Error decoding message, the lHash calculated from the label provided and the lHash in the encrypted data do not match.");for(u=a;0===h[u++]&&u<h.length;);if(1!=h[u-1])throw new Error("Error decoding message, there is no padding message separator byte");return h.slice(u)},new r(t,s)}},1067:(e,t,s)=>{var i=s(8359),n=s(6113),r=s(2057),o={md2:Buffer.from("3020300c06082a864886f70d020205000410","hex"),md5:Buffer.from("3020300c06082a864886f70d020505000410","hex"),sha1:Buffer.from("3021300906052b0e03021a05000414","hex"),sha224:Buffer.from("302d300d06096086480165030402040500041c","hex"),sha256:Buffer.from("3031300d060960864801650304020105000420","hex"),sha384:Buffer.from("3041300d060960864801650304020205000430","hex"),sha512:Buffer.from("3051300d060960864801650304020305000440","hex"),ripemd160:Buffer.from("3021300906052b2403020105000414","hex"),rmd160:Buffer.from("3021300906052b2403020105000414","hex")},a={ripemd160:"rmd160"},c="sha256";e.exports={isEncryption:!0,isSignature:!0},e.exports.makeScheme=function(e,t){function s(e,t){this.key=e,this.options=t}return s.prototype.maxMessageLength=function(){return this.options.encryptionSchemeOptions&&this.options.encryptionSchemeOptions.padding==r.RSA_NO_PADDING?this.key.encryptedDataLength:this.key.encryptedDataLength-11},s.prototype.encPad=function(e,t){var s;if(t=t||{},e.length>this.key.maxMessageLength)throw new Error("Message too long for RSA (n="+this.key.encryptedDataLength+", l="+e.length+")");if(this.options.encryptionSchemeOptions&&this.options.encryptionSchemeOptions.padding==r.RSA_NO_PADDING)return(s=Buffer.alloc(this.key.maxMessageLength-e.length)).fill(0),Buffer.concat([s,e]);if(1===t.type)return(s=Buffer.alloc(this.key.encryptedDataLength-e.length-1)).fill(255,0,s.length-1),s[0]=1,s[s.length-1]=0,Buffer.concat([s,e]);(s=Buffer.alloc(this.key.encryptedDataLength-e.length))[0]=0,s[1]=2;for(var i=n.randomBytes(s.length-3),o=0;o<i.length;o++){for(var a=i[o];0===a;)a=n.randomBytes(1)[0];s[o+2]=a}return s[s.length-1]=0,Buffer.concat([s,e])},s.prototype.encUnPad=function(e,t){t=t||{};var s=0;if(this.options.encryptionSchemeOptions&&this.options.encryptionSchemeOptions.padding==r.RSA_NO_PADDING)return"function"==typeof e.lastIndexOf?e.slice(e.lastIndexOf("\0")+1,e.length):e.slice(String.prototype.lastIndexOf.call(e,"\0")+1,e.length);if(e.length<4)return null;if(1===t.type){if(0!==e[0]||1!==e[1])return null;for(s=3;0!==e[s];)if(255!=e[s]||++s>=e.length)return null}else{if(0!==e[0]||2!==e[1])return null;for(s=3;0!==e[s];)if(++s>=e.length)return null}return e.slice(s+1,e.length)},s.prototype.sign=function(e){var t=this.options.signingSchemeOptions.hash||c;if("browser"===this.options.environment){t=a[t]||t;var s=n.createHash(t);s.update(e);var r=this.pkcs1pad(s.digest(),t);return this.key.$doPrivate(new i(r)).toBuffer(this.key.encryptedDataLength)}var o=n.createSign("RSA-"+t.toUpperCase());return o.update(e),o.sign(this.options.rsaUtils.exportKey("private"))},s.prototype.verify=function(e,t,s){if(this.options.encryptionSchemeOptions&&this.options.encryptionSchemeOptions.padding==r.RSA_NO_PADDING)return!1;var o=this.options.signingSchemeOptions.hash||c;if("browser"===this.options.environment){o=a[o]||o,s&&(t=Buffer.from(t,s));var h=n.createHash(o);h.update(e);var l=this.pkcs1pad(h.digest(),o);return this.key.$doPublic(new i(t)).toBuffer().toString("hex")==l.toString("hex")}var u=n.createVerify("RSA-"+o.toUpperCase());return u.update(e),u.verify(this.options.rsaUtils.exportKey("public"),t,s)},s.prototype.pkcs0pad=function(e){var t=Buffer.alloc(this.key.maxMessageLength-e.length);return t.fill(0),Buffer.concat([t,e])},s.prototype.pkcs0unpad=function(e){return"function"==typeof e.lastIndexOf?e.slice(e.lastIndexOf("\0")+1,e.length):e.slice(String.prototype.lastIndexOf.call(e,"\0")+1,e.length)},s.prototype.pkcs1pad=function(e,t){var s=o[t];if(!s)throw Error("Unsupported hash algorithm");var i=Buffer.concat([s,e]);if(i.length+10>this.key.encryptedDataLength)throw Error("Key is too short for signing algorithm ("+t+")");var n=Buffer.alloc(this.key.encryptedDataLength-i.length-1);return n.fill(255,0,n.length-1),n[0]=1,n[n.length-1]=0,Buffer.concat([n,i])},new s(e,t)}},2085:(e,t,s)=>{var i=s(8359),n=s(6113);e.exports={isEncryption:!1,isSignature:!0};var r="sha1";e.exports.makeScheme=function(e,t){var o=s(7178).pkcs1_oaep;function a(e,t){this.key=e,this.options=t}return a.prototype.sign=function(e){var t=n.createHash(this.options.signingSchemeOptions.hash||r);t.update(e);var s=this.emsa_pss_encode(t.digest(),this.key.keySize-1);return this.key.$doPrivate(new i(s)).toBuffer(this.key.encryptedDataLength)},a.prototype.verify=function(e,t,s){s&&(t=Buffer.from(t,s)),t=new i(t);var o=Math.ceil((this.key.keySize-1)/8),a=this.key.$doPublic(t).toBuffer(o),c=n.createHash(this.options.signingSchemeOptions.hash||r);return c.update(e),this.emsa_pss_verify(c.digest(),a,this.key.keySize-1)},a.prototype.emsa_pss_encode=function(e,t){var s=this.options.signingSchemeOptions.hash||r,i=this.options.signingSchemeOptions.mgf||o.eme_oaep_mgf1,a=this.options.signingSchemeOptions.saltLength||20,c=o.digestLength[s],h=Math.ceil(t/8);if(h<c+a+2)throw new Error("Output length passed to emBits("+t+") is too small for the options specified("+s+", "+a+"). To fix this issue increase the value of emBits. (minimum size: "+(8*c+8*a+9)+")");var l=n.randomBytes(a),u=Buffer.alloc(8+c+a);u.fill(0,0,8),e.copy(u,8),l.copy(u,8+e.length);var d=n.createHash(s);d.update(u),d=d.digest();var p=Buffer.alloc(h-l.length-c-2);p.fill(0);var f=Buffer.alloc(p.length+1+l.length);p.copy(f),f[p.length]=1,l.copy(f,p.length+1);for(var g=i(d,f.length,s),m=Buffer.alloc(f.length),y=0;y<g.length;y++)m[y]=f[y]^g[y];var v=8*h-t,w=255^255>>8-v<<8-v;m[0]=m[0]&w;var S=Buffer.alloc(m.length+d.length+1);return m.copy(S,0),d.copy(S,m.length),S[S.length-1]=188,S},a.prototype.emsa_pss_verify=function(e,t,s){var i=this.options.signingSchemeOptions.hash||r,a=this.options.signingSchemeOptions.mgf||o.eme_oaep_mgf1,c=this.options.signingSchemeOptions.saltLength||20,h=o.digestLength[i],l=Math.ceil(s/8);if(l<h+c+2||188!=t[t.length-1])return!1;var u=Buffer.alloc(l-h-1);t.copy(u,0,0,l-h-1);for(var d=0,p=0,f=8*l-s;p<f;p++)d|=1<<7-p;if(0!=(u[0]&d))return!1;var g=t.slice(l-h-1,l-1),m=a(g,u.length,i);for(p=0;p<u.length;p++)u[p]^=m[p];for(d=255^255>>8-(f=8*l-s)<<8-f,u[0]=u[0]&d,p=0;0===u[p]&&p<u.length;p++);if(1!=u[p])return!1;var y=u.slice(u.length-c),v=Buffer.alloc(8+h+c);v.fill(0,0,8),e.copy(v,8),y.copy(v,8+e.length);var w=n.createHash(i);return w.update(v),w=w.digest(),g.toString("hex")===w.toString("hex")},new a(e,t)}},7178:(e,t,s)=>{e.exports={pkcs1:s(1067),pkcs1_oaep:s(6400),pss:s(2085),isEncryption:function(t){return e.exports[t]&&e.exports[t].isEncryption},isSignature:function(t){return e.exports[t]&&e.exports[t].isSignature}}},222:(e,t,s)=>{s(6113),e.exports.linebrk=function(e,t){for(var s="",i=0;i+t<e.length;)s+=e.substring(i,i+t)+"\n",i+=t;return s+e.substring(i,e.length)},e.exports.detectEnvironment=function(){return"undefined"==typeof window||!window||process&&"node"===process.title?"node":"browser"},e.exports.get32IntFromBuffer=function(e,t){var s;if(t=t||0,(s=e.length-t)>0){if(s>=4)return e.readUIntBE(t,s);for(var i=0,n=t+s,r=0;n>t;n--,r+=2)i+=e[n-1]*Math.pow(16,r);return i}return NaN},e.exports._={isObject:function(e){var t=typeof e;return!!e&&("object"==t||"function"==t)},isString:function(e){return"string"==typeof e||e instanceof String},isNumber:function(e){return"number"==typeof e||!isNaN(parseFloat(e))&&isFinite(e)},omit:function(e,t){var s={};for(var i in e)e.hasOwnProperty(i)&&i!==t&&(s[i]=e[i]);return s}},e.exports.trimSurroundingText=function(e,t,s){var i=0,n=e.length,r=e.indexOf(t);r>=0&&(i=r+t.length);var o=e.indexOf(s,r);return o>=0&&(n=o),e.substring(i,n)}},1788:(e,t,s)=>{"use strict";var i,n=s(4300),r=n.Buffer,o={};for(i in n)n.hasOwnProperty(i)&&"SlowBuffer"!==i&&"Buffer"!==i&&(o[i]=n[i]);var a=o.Buffer={};for(i in r)r.hasOwnProperty(i)&&"allocUnsafe"!==i&&"allocUnsafeSlow"!==i&&(a[i]=r[i]);if(o.Buffer.prototype=r.prototype,a.from&&a.from!==Uint8Array.from||(a.from=function(e,t,s){if("number"==typeof e)throw new TypeError('The "value" argument must not be of type number. Received type '+typeof e);if(e&&void 0===e.length)throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type "+typeof e);return r(e,t,s)}),a.alloc||(a.alloc=function(e,t,s){if("number"!=typeof e)throw new TypeError('The "size" argument must be of type number. Received type '+typeof e);if(e<0||e>=2*(1<<30))throw new RangeError('The value "'+e+'" is invalid for option "size"');var i=r(e);return t&&0!==t.length?"string"==typeof s?i.fill(t,s):i.fill(t):i.fill(0),i}),!o.kStringMaxLength)try{o.kStringMaxLength=process.binding("buffer").kStringMaxLength}catch(e){}o.constants||(o.constants={MAX_LENGTH:o.kMaxLength},o.kStringMaxLength&&(o.constants.MAX_STRING_LENGTH=o.kStringMaxLength)),e.exports=o},4792:(e,t,s)=>{var i=s(8275).strict;e.exports=function(e){if(i(e)){var t=Buffer.from(e.buffer);return e.byteLength!==e.buffer.byteLength&&(t=t.slice(e.byteOffset,e.byteOffset+e.byteLength)),t}return Buffer.from(e)}},3991:e=>{"use strict";e.exports=function(e){const t=e.length;let s=0;for(;s<t;)if(0==(128&e[s]))s++;else if(192==(224&e[s])){if(s+1===t||128!=(192&e[s+1])||192==(254&e[s]))return!1;s+=2}else if(224==(240&e[s])){if(s+2>=t||128!=(192&e[s+1])||128!=(192&e[s+2])||224===e[s]&&128==(224&e[s+1])||237===e[s]&&160==(224&e[s+1]))return!1;s+=3}else{if(240!=(248&e[s]))return!1;if(s+3>=t||128!=(192&e[s+1])||128!=(192&e[s+2])||128!=(192&e[s+3])||240===e[s]&&128==(240&e[s+1])||244===e[s]&&e[s+1]>143||e[s]>244)return!1;s+=4}return!0}},9167:(e,t,s)=>{"use strict";try{e.exports=s(601)(__dirname)}catch(t){e.exports=s(3991)}},1719:(e,t,s)=>{var i=s(2998),n=s(6541),r=n;r.v1=i,r.v4=n,e.exports=r},3973:e=>{for(var t=[],s=0;s<256;++s)t[s]=(s+256).toString(16).substr(1);e.exports=function(e,s){var i=s||0,n=t;return[n[e[i++]],n[e[i++]],n[e[i++]],n[e[i++]],"-",n[e[i++]],n[e[i++]],"-",n[e[i++]],n[e[i++]],"-",n[e[i++]],n[e[i++]],"-",n[e[i++]],n[e[i++]],n[e[i++]],n[e[i++]],n[e[i++]],n[e[i++]]].join("")}},3926:(e,t,s)=>{var i=s(6113);e.exports=function(){return i.randomBytes(16)}},2998:(e,t,s)=>{var i,n,r=s(3926),o=s(3973),a=0,c=0;e.exports=function(e,t,s){var h=t&&s||0,l=t||[],u=(e=e||{}).node||i,d=void 0!==e.clockseq?e.clockseq:n;if(null==u||null==d){var p=r();null==u&&(u=i=[1|p[0],p[1],p[2],p[3],p[4],p[5]]),null==d&&(d=n=16383&(p[6]<<8|p[7]))}var f=void 0!==e.msecs?e.msecs:(new Date).getTime(),g=void 0!==e.nsecs?e.nsecs:c+1,m=f-a+(g-c)/1e4;if(m<0&&void 0===e.clockseq&&(d=d+1&16383),(m<0||f>a)&&void 0===e.nsecs&&(g=0),g>=1e4)throw new Error("uuid.v1(): Can't create more than 10M uuids/sec");a=f,c=g,n=d;var y=(1e4*(268435455&(f+=122192928e5))+g)%4294967296;l[h++]=y>>>24&255,l[h++]=y>>>16&255,l[h++]=y>>>8&255,l[h++]=255&y;var v=f/4294967296*1e4&268435455;l[h++]=v>>>8&255,l[h++]=255&v,l[h++]=v>>>24&15|16,l[h++]=v>>>16&255,l[h++]=d>>>8|128,l[h++]=255&d;for(var w=0;w<6;++w)l[h+w]=u[w];return t||o(l)}},6541:(e,t,s)=>{var i=s(3926),n=s(3973);e.exports=function(e,t,s){var r=t&&s||0;"string"==typeof e&&(t="binary"===e?new Array(16):null,e=null);var o=(e=e||{}).random||(e.rng||i)();if(o[6]=15&o[6]|64,o[8]=63&o[8]|128,t)for(var a=0;a<16;++a)t[r+a]=o[a];return t||n(o)}},9336:(e,t,s)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0});const i=s(6559),n=s(8352);var r;!function(e){e.None=Object.freeze({isCancellationRequested:!1,onCancellationRequested:i.Event.None}),e.Cancelled=Object.freeze({isCancellationRequested:!0,onCancellationRequested:i.Event.None}),e.is=function(t){let s=t;return s&&(s===e.None||s===e.Cancelled||n.boolean(s.isCancellationRequested)&&!!s.onCancellationRequested)}}(r=t.CancellationToken||(t.CancellationToken={}));const o=Object.freeze((function(e,t){let s=setTimeout(e.bind(t),0);return{dispose(){clearTimeout(s)}}}));class a{constructor(){this._isCancelled=!1}cancel(){this._isCancelled||(this._isCancelled=!0,this._emitter&&(this._emitter.fire(void 0),this._emitter=void 0))}get isCancellationRequested(){return this._isCancelled}get onCancellationRequested(){return this._isCancelled?o:(this._emitter||(this._emitter=new i.Emitter),this._emitter.event)}}t.CancellationTokenSource=class{get token(){return this._token||(this._token=new a),this._token}cancel(){this._token?this._token.cancel():this._token=r.Cancelled}dispose(){this.cancel()}}},6559:(e,t)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),(t.Disposable||(t.Disposable={})).create=function(e){return{dispose:e}},function(e){const t={dispose(){}};e.None=function(){return t}}(t.Event||(t.Event={}));class s{add(e,t=null,s){this._callbacks||(this._callbacks=[],this._contexts=[]),this._callbacks.push(e),this._contexts.push(t),Array.isArray(s)&&s.push({dispose:()=>this.remove(e,t)})}remove(e,t=null){if(this._callbacks){for(var s=!1,i=0,n=this._callbacks.length;i<n;i++)if(this._callbacks[i]===e){if(this._contexts[i]===t)return this._callbacks.splice(i,1),void this._contexts.splice(i,1);s=!0}if(s)throw new Error("When adding a listener with a context, you should remove it with the same context")}}invoke(...e){if(!this._callbacks)return[];for(var t=[],s=this._callbacks.slice(0),i=this._contexts.slice(0),n=0,r=s.length;n<r;n++)try{t.push(s[n].apply(i[n],e))}catch(e){console.error(e)}return t}isEmpty(){return!this._callbacks||0===this._callbacks.length}dispose(){this._callbacks=void 0,this._contexts=void 0}}class i{constructor(e){this._options=e}get event(){return this._event||(this._event=(e,t,n)=>{let r;return this._callbacks||(this._callbacks=new s),this._options&&this._options.onFirstListenerAdd&&this._callbacks.isEmpty()&&this._options.onFirstListenerAdd(this),this._callbacks.add(e,t),r={dispose:()=>{this._callbacks.remove(e,t),r.dispose=i._noop,this._options&&this._options.onLastListenerRemove&&this._callbacks.isEmpty()&&this._options.onLastListenerRemove(this)}},Array.isArray(n)&&n.push(r),r}),this._event}fire(e){this._callbacks&&this._callbacks.invoke.call(this._callbacks,e)}dispose(){this._callbacks&&(this._callbacks.dispose(),this._callbacks=void 0)}}i._noop=function(){},t.Emitter=i},8352:(e,t)=>{"use strict";function s(e){return"string"==typeof e||e instanceof String}function i(e){return Array.isArray(e)}Object.defineProperty(t,"__esModule",{value:!0}),t.boolean=function(e){return!0===e||!1===e},t.string=s,t.number=function(e){return"number"==typeof e||e instanceof Number},t.error=function(e){return e instanceof Error},t.func=function(e){return"function"==typeof e},t.array=i,t.stringArray=function(e){return i(e)&&e.every((e=>s(e)))}},2299:(e,t)=>{"use strict";var s;Object.defineProperty(t,"__esModule",{value:!0}),function(e){e.None=0,e.First=1,e.Last=2}(s=t.Touch||(t.Touch={})),t.LinkedMap=class{constructor(){this._map=new Map,this._head=void 0,this._tail=void 0,this._size=0}clear(){this._map.clear(),this._head=void 0,this._tail=void 0,this._size=0}isEmpty(){return!this._head&&!this._tail}get size(){return this._size}has(e){return this._map.has(e)}get(e){const t=this._map.get(e);if(t)return t.value}set(e,t,i=s.None){let n=this._map.get(e);if(n)n.value=t,i!==s.None&&this.touch(n,i);else{switch(n={key:e,value:t,next:void 0,previous:void 0},i){case s.None:this.addItemLast(n);break;case s.First:this.addItemFirst(n);break;case s.Last:default:this.addItemLast(n)}this._map.set(e,n),this._size++}}delete(e){const t=this._map.get(e);return!!t&&(this._map.delete(e),this.removeItem(t),this._size--,!0)}shift(){if(!this._head&&!this._tail)return;if(!this._head||!this._tail)throw new Error("Invalid list");const e=this._head;return this._map.delete(e.key),this.removeItem(e),this._size--,e.value}forEach(e,t){let s=this._head;for(;s;)t?e.bind(t)(s.value,s.key,this):e(s.value,s.key,this),s=s.next}forEachReverse(e,t){let s=this._tail;for(;s;)t?e.bind(t)(s.value,s.key,this):e(s.value,s.key,this),s=s.previous}values(){let e=[],t=this._head;for(;t;)e.push(t.value),t=t.next;return e}keys(){let e=[],t=this._head;for(;t;)e.push(t.key),t=t.next;return e}addItemFirst(e){if(this._head||this._tail){if(!this._head)throw new Error("Invalid list");e.next=this._head,this._head.previous=e}else this._tail=e;this._head=e}addItemLast(e){if(this._head||this._tail){if(!this._tail)throw new Error("Invalid list");e.previous=this._tail,this._tail.next=e}else this._head=e;this._tail=e}removeItem(e){if(e===this._head&&e===this._tail)this._head=void 0,this._tail=void 0;else if(e===this._head)this._head=e.next;else if(e===this._tail)this._tail=e.previous;else{const t=e.next,s=e.previous;if(!t||!s)throw new Error("Invalid list");t.previous=s,s.next=t}}touch(e,t){if(!this._head||!this._tail)throw new Error("Invalid list");if(t===s.First||t===s.Last)if(t===s.First){if(e===this._head)return;const t=e.next,s=e.previous;e===this._tail?(s.next=void 0,this._tail=s):(t.previous=s,s.next=t),e.previous=void 0,e.next=this._head,this._head.previous=e,this._head=e}else if(t===s.Last){if(e===this._tail)return;const t=e.next,s=e.previous;e===this._head?(t.previous=void 0,this._head=t):(t.previous=s,s.next=t),e.next=void 0,e.previous=this._tail,this._tail.next=e,this._tail=e}}}},3730:(e,t,s)=>{"use strict";function i(e){for(var s in e)t.hasOwnProperty(s)||(t[s]=e[s])}Object.defineProperty(t,"__esModule",{value:!0});const n=s(8352),r=s(9121);t.RequestType=r.RequestType,t.RequestType0=r.RequestType0,t.RequestType1=r.RequestType1,t.RequestType2=r.RequestType2,t.RequestType3=r.RequestType3,t.RequestType4=r.RequestType4,t.RequestType5=r.RequestType5,t.RequestType6=r.RequestType6,t.RequestType7=r.RequestType7,t.RequestType8=r.RequestType8,t.RequestType9=r.RequestType9,t.ResponseError=r.ResponseError,t.ErrorCodes=r.ErrorCodes,t.NotificationType=r.NotificationType,t.NotificationType0=r.NotificationType0,t.NotificationType1=r.NotificationType1,t.NotificationType2=r.NotificationType2,t.NotificationType3=r.NotificationType3,t.NotificationType4=r.NotificationType4,t.NotificationType5=r.NotificationType5,t.NotificationType6=r.NotificationType6,t.NotificationType7=r.NotificationType7,t.NotificationType8=r.NotificationType8,t.NotificationType9=r.NotificationType9;const o=s(9909);t.MessageReader=o.MessageReader,t.StreamMessageReader=o.StreamMessageReader,t.IPCMessageReader=o.IPCMessageReader,t.SocketMessageReader=o.SocketMessageReader;const a=s(5841);t.MessageWriter=a.MessageWriter,t.StreamMessageWriter=a.StreamMessageWriter,t.IPCMessageWriter=a.IPCMessageWriter,t.SocketMessageWriter=a.SocketMessageWriter;const c=s(6559);t.Disposable=c.Disposable,t.Event=c.Event,t.Emitter=c.Emitter;const h=s(9336);t.CancellationTokenSource=h.CancellationTokenSource,t.CancellationToken=h.CancellationToken;const l=s(2299);var u,d,p,f,g,m,y;i(s(7339)),i(s(3105)),function(e){e.type=new r.NotificationType("$/cancelRequest")}(u||(u={})),t.NullLogger=Object.freeze({error:()=>{},warn:()=>{},info:()=>{},log:()=>{}}),function(e){e[e.Off=0]="Off",e[e.Messages=1]="Messages",e[e.Verbose=2]="Verbose"}(d=t.Trace||(t.Trace={})),function(e){e.fromString=function(t){switch(t=t.toLowerCase()){case"off":default:return e.Off;case"messages":return e.Messages;case"verbose":return e.Verbose}},e.toString=function(t){switch(t){case e.Off:return"off";case e.Messages:return"messages";case e.Verbose:return"verbose";default:return"off"}}}(d=t.Trace||(t.Trace={})),function(e){e.Text="text",e.JSON="json"}(t.TraceFormat||(t.TraceFormat={})),function(e){e.fromString=function(t){return"json"===(t=t.toLowerCase())?e.JSON:e.Text}}(p=t.TraceFormat||(t.TraceFormat={})),function(e){e.type=new r.NotificationType("$/setTraceNotification")}(f=t.SetTraceNotification||(t.SetTraceNotification={})),function(e){e.type=new r.NotificationType("$/logTraceNotification")}(g=t.LogTraceNotification||(t.LogTraceNotification={})),function(e){e[e.Closed=1]="Closed",e[e.Disposed=2]="Disposed",e[e.AlreadyListening=3]="AlreadyListening"}(m=t.ConnectionErrors||(t.ConnectionErrors={}));class v extends Error{constructor(e,t){super(t),this.code=e,Object.setPrototypeOf(this,v.prototype)}}function w(e,t,s,i){let o=0,a=0,w=0;const S="2.0";let b,E,C,R,P=Object.create(null),T=Object.create(null),k=new l.LinkedMap,x=Object.create(null),A=Object.create(null),M=d.Off,B=p.Text,I=y.New,_=new c.Emitter,O=new c.Emitter,q=new c.Emitter,L=new c.Emitter;function F(e){return"req-"+e.toString()}function N(e){}function D(){return I===y.Listening}function K(){return I===y.Closed}function j(){return I===y.Disposed}function $(){I!==y.New&&I!==y.Listening||(I=y.Closed,O.fire(void 0))}function W(){C||0===k.size||(C=setImmediate((()=>{C=void 0,function(){if(0===k.size)return;let e=k.shift();try{r.isRequestMessage(e)?function(e){if(j())return;function s(s,i,n){let o={jsonrpc:S,id:e.id};s instanceof r.ResponseError?o.error=s.toJson():o.result=void 0===s?null:s,U(o,i,n),t.write(o)}function i(s,i,n){let r={jsonrpc:S,id:e.id,error:s.toJson()};U(r,i,n),t.write(r)}!function(e){if(M!==d.Off&&R)if(B===p.Text){let t;M===d.Verbose&&e.params&&(t=`Params: ${JSON.stringify(e.params,null,4)}\n\n`),R.log(`Received request '${e.method} - (${e.id})'.`,t)}else z("receive-request",e)}(e);let o,a,c=P[e.method];c&&(o=c.type,a=c.handler);let l=Date.now();if(a||b){let c=new h.CancellationTokenSource,u=String(e.id);A[u]=c;try{let h;h=void 0===e.params||void 0!==o&&0===o.numberOfParams?a?a(c.token):b(e.method,c.token):n.array(e.params)&&(void 0===o||o.numberOfParams>1)?a?a(...e.params,c.token):b(e.method,...e.params,c.token):a?a(e.params,c.token):b(e.method,e.params,c.token);let d=h;h?d.then?d.then((t=>{delete A[u],s(t,e.method,l)}),(t=>{delete A[u],t instanceof r.ResponseError?i(t,e.method,l):t&&n.string(t.message)?i(new r.ResponseError(r.ErrorCodes.InternalError,`Request ${e.method} failed with message: ${t.message}`),e.method,l):i(new r.ResponseError(r.ErrorCodes.InternalError,`Request ${e.method} failed unexpectedly without providing any details.`),e.method,l)})):(delete A[u],s(h,e.method,l)):(delete A[u],function(s,i,n){void 0===s&&(s=null);let r={jsonrpc:S,id:e.id,result:s};U(r,i,n),t.write(r)}(h,e.method,l))}catch(t){delete A[u],t instanceof r.ResponseError?s(t,e.method,l):t&&n.string(t.message)?i(new r.ResponseError(r.ErrorCodes.InternalError,`Request ${e.method} failed with message: ${t.message}`),e.method,l):i(new r.ResponseError(r.ErrorCodes.InternalError,`Request ${e.method} failed unexpectedly without providing any details.`),e.method,l)}}else i(new r.ResponseError(r.ErrorCodes.MethodNotFound,`Unhandled method ${e.method}`),e.method,l)}(e):r.isNotificationMessage(e)?function(e){if(j())return;let t,i;if(e.method===u.type.method)i=e=>{let t=e.id,s=A[String(t)];s&&s.cancel()};else{let s=T[e.method];s&&(i=s.handler,t=s.type)}if(i||E)try{!function(e){if(M!==d.Off&&R&&e.method!==g.type.method)if(B===p.Text){let t;M===d.Verbose&&(t=e.params?`Params: ${JSON.stringify(e.params,null,4)}\n\n`:"No parameters provided.\n\n"),R.log(`Received notification '${e.method}'.`,t)}else z("receive-notification",e)}(e),void 0===e.params||void 0!==t&&0===t.numberOfParams?i?i():E(e.method):n.array(e.params)&&(void 0===t||t.numberOfParams>1)?i?i(...e.params):E(e.method,...e.params):i?i(e.params):E(e.method,e.params)}catch(t){t.message?s.error(`Notification handler '${e.method}' failed with message: ${t.message}`):s.error(`Notification handler '${e.method}' failed unexpectedly.`)}else q.fire(e)}(e):r.isResponseMessage(e)?function(e){if(!j())if(null===e.id)e.error?s.error(`Received response message without id: Error is: \n${JSON.stringify(e.error,void 0,4)}`):s.error("Received response message without id. No further error information provided.");else{let t=String(e.id),i=x[t];if(function(e,t){if(M!==d.Off&&R)if(B===p.Text){let s;if(M===d.Verbose&&(e.error&&e.error.data?s=`Error data: ${JSON.stringify(e.error.data,null,4)}\n\n`:e.result?s=`Result: ${JSON.stringify(e.result,null,4)}\n\n`:void 0===e.error&&(s="No result returned.\n\n")),t){let i=e.error?` Request failed: ${e.error.message} (${e.error.code}).`:"";R.log(`Received response '${t.method} - (${e.id})' in ${Date.now()-t.timerStart}ms.${i}`,s)}else R.log(`Received response ${e.id} without active response promise.`,s)}else z("receive-response",e)}(e,i),i){delete x[t];try{if(e.error){let t=e.error;i.reject(new r.ResponseError(t.code,t.message,t.data))}else{if(void 0===e.result)throw new Error("Should never happen.");i.resolve(e.result)}}catch(e){e.message?s.error(`Response handler '${i.method}' failed with message: ${e.message}`):s.error(`Response handler '${i.method}' failed unexpectedly.`)}}}}(e):function(e){if(!e)return void s.error("Received empty message.");s.error(`Received message which is neither a response nor a notification message:\n${JSON.stringify(e,null,4)}`);let t=e;if(n.string(t.id)||n.number(t.id)){let e=String(t.id),s=x[e];s&&s.reject(new Error("The received response has neither a result nor an error property."))}}(e)}finally{W()}}()})))}e.onClose($),e.onError((function(e){_.fire([e,void 0,void 0])})),t.onClose($),t.onError((function(e){_.fire(e)}));let H=e=>{try{if(r.isNotificationMessage(e)&&e.method===u.type.method){let s=F(e.params.id),n=k.get(s);if(r.isRequestMessage(n)){let r=i&&i.cancelUndispatched?i.cancelUndispatched(n,N):void 0;if(r&&(void 0!==r.error||void 0!==r.result))return k.delete(s),r.id=n.id,U(r,e.method,Date.now()),void t.write(r)}}!function(e,t){var s;r.isRequestMessage(t)?e.set(F(t.id),t):r.isResponseMessage(t)?e.set(null===(s=t.id)?"res-unknown-"+(++w).toString():"res-"+s.toString(),t):e.set("not-"+(++a).toString(),t)}(k,e)}finally{W()}};function U(e,t,s){if(M!==d.Off&&R)if(B===p.Text){let i;M===d.Verbose&&(e.error&&e.error.data?i=`Error data: ${JSON.stringify(e.error.data,null,4)}\n\n`:e.result?i=`Result: ${JSON.stringify(e.result,null,4)}\n\n`:void 0===e.error&&(i="No result returned.\n\n")),R.log(`Sending response '${t} - (${e.id})'. Processing request took ${Date.now()-s}ms`,i)}else z("send-response",e)}function z(e,t){if(!R||M===d.Off)return;const s={isLSPMessage:!0,type:e,message:t,timestamp:Date.now()};R.log(s)}function V(){if(K())throw new v(m.Closed,"Connection is closed.");if(j())throw new v(m.Disposed,"Connection is disposed.")}function G(e){return void 0===e?null:e}function J(e,t){let s,i=e.numberOfParams;switch(i){case 0:s=null;break;case 1:s=G(t[0]);break;default:s=[];for(let e=0;e<t.length&&e<i;e++)s.push(G(t[e]));if(t.length<i)for(let e=t.length;e<i;e++)s.push(null)}return s}let Y={sendNotification:(e,...s)=>{let i,r;if(V(),n.string(e))switch(i=e,s.length){case 0:r=null;break;case 1:r=s[0];break;default:r=s}else i=e.method,r=J(e,s);let o={jsonrpc:S,method:i,params:r};!function(e){if(M!==d.Off&&R)if(B===p.Text){let t;M===d.Verbose&&(t=e.params?`Params: ${JSON.stringify(e.params,null,4)}\n\n`:"No parameters provided.\n\n"),R.log(`Sending notification '${e.method}'.`,t)}else z("send-notification",e)}(o),t.write(o)},onNotification:(e,t)=>{V(),n.func(e)?E=e:t&&(n.string(e)?T[e]={type:void 0,handler:t}:T[e.method]={type:e,handler:t})},sendRequest:(e,...s)=>{let i,a,c;if(V(),function(){if(!D())throw new Error("Call listen() first.")}(),n.string(e))switch(i=e,s.length){case 0:a=null;break;case 1:h.CancellationToken.is(s[0])?(a=null,c=s[0]):a=G(s[0]);break;default:const e=s.length-1;h.CancellationToken.is(s[e])?(c=s[e],a=2===s.length?G(s[0]):s.slice(0,e).map((e=>G(e)))):a=s.map((e=>G(e)))}else{i=e.method,a=J(e,s);let t=e.numberOfParams;c=h.CancellationToken.is(s[t])?s[t]:void 0}let l=o++,f=new Promise(((e,s)=>{let n={jsonrpc:S,id:l,method:i,params:a},o={method:i,timerStart:Date.now(),resolve:e,reject:s};!function(e){if(M!==d.Off&&R)if(B===p.Text){let t;M===d.Verbose&&e.params&&(t=`Params: ${JSON.stringify(e.params,null,4)}\n\n`),R.log(`Sending request '${e.method} - (${e.id})'.`,t)}else z("send-request",e)}(n);try{t.write(n)}catch(e){o.reject(new r.ResponseError(r.ErrorCodes.MessageWriteError,e.message?e.message:"Unknown reason")),o=null}o&&(x[String(l)]=o)}));return c&&c.onCancellationRequested((()=>{Y.sendNotification(u.type,{id:l})})),f},onRequest:(e,t)=>{V(),n.func(e)?b=e:t&&(n.string(e)?P[e]={type:void 0,handler:t}:P[e.method]={type:e,handler:t})},trace:(e,t,s)=>{let i=!1,r=p.Text;void 0!==s&&(n.boolean(s)?i=s:(i=s.sendNotification||!1,r=s.traceFormat||p.Text)),M=e,B=r,R=M===d.Off?void 0:t,!i||K()||j()||Y.sendNotification(f.type,{value:d.toString(e)})},onError:_.event,onClose:O.event,onUnhandledNotification:q.event,onDispose:L.event,dispose:()=>{if(j())return;I=y.Disposed,L.fire(void 0);let s=new Error("Connection got disposed.");Object.keys(x).forEach((e=>{x[e].reject(s)})),x=Object.create(null),A=Object.create(null),k=new l.LinkedMap,n.func(t.dispose)&&t.dispose(),n.func(e.dispose)&&e.dispose()},listen:()=>{V(),function(){if(D())throw new v(m.AlreadyListening,"Connection is already listening")}(),I=y.Listening,e.listen(H)},inspect:()=>{console.log("inspect")}};return Y.onNotification(g.type,(e=>{M!==d.Off&&R&&R.log(e.message,M===d.Verbose?e.verbose:void 0)})),Y}t.ConnectionError=v,(t.ConnectionStrategy||(t.ConnectionStrategy={})).is=function(e){let t=e;return t&&n.func(t.cancelUndispatched)},function(e){e[e.New=1]="New",e[e.Listening=2]="Listening",e[e.Closed=3]="Closed",e[e.Disposed=4]="Disposed"}(y||(y={})),t.createMessageConnection=function(e,s,i,n){i||(i=t.NullLogger);let r=void 0!==(c=e).listen&&void 0===c.read?e:new o.StreamMessageReader(e);var c;let h=function(e){return void 0!==e.write&&void 0===e.end}(s)?s:new a.StreamMessageWriter(s);return w(r,h,i,n)}},9909:(e,t,s)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0});const i=s(6559),n=s(8352);let r=8192,o=Buffer.from("\r","ascii")[0],a=Buffer.from("\n","ascii")[0];class c{constructor(e="utf8"){this.encoding=e,this.index=0,this.buffer=Buffer.allocUnsafe(r)}append(e){var t=e;if("string"==typeof e){var s=e,i=Buffer.byteLength(s,this.encoding);(t=Buffer.allocUnsafe(i)).write(s,0,i,this.encoding)}if(this.buffer.length-this.index>=t.length)t.copy(this.buffer,this.index,0,t.length);else{var n=(Math.ceil((this.index+t.length)/r)+1)*r;0===this.index?(this.buffer=Buffer.allocUnsafe(n),t.copy(this.buffer,0,0,t.length)):this.buffer=Buffer.concat([this.buffer.slice(0,this.index),t],n)}this.index+=t.length}tryReadHeaders(){let e,t=0;for(;t+3<this.index&&(this.buffer[t]!==o||this.buffer[t+1]!==a||this.buffer[t+2]!==o||this.buffer[t+3]!==a);)t++;if(t+3>=this.index)return e;e=Object.create(null),this.buffer.toString("ascii",0,t).split("\r\n").forEach((t=>{let s=t.indexOf(":");if(-1===s)throw new Error("Message header must separate key and value using :");let i=t.substr(0,s),n=t.substr(s+1).trim();e[i]=n}));let s=t+4;return this.buffer=this.buffer.slice(s),this.index=this.index-s,e}tryReadContent(e){if(this.index<e)return null;let t=this.buffer.toString(this.encoding,0,e),s=e;return this.buffer.copy(this.buffer,0,s),this.index=this.index-s,t}get numberOfBytes(){return this.index}}(t.MessageReader||(t.MessageReader={})).is=function(e){let t=e;return t&&n.func(t.listen)&&n.func(t.dispose)&&n.func(t.onError)&&n.func(t.onClose)&&n.func(t.onPartialMessage)};class h{constructor(){this.errorEmitter=new i.Emitter,this.closeEmitter=new i.Emitter,this.partialMessageEmitter=new i.Emitter}dispose(){this.errorEmitter.dispose(),this.closeEmitter.dispose()}get onError(){return this.errorEmitter.event}fireError(e){this.errorEmitter.fire(this.asError(e))}get onClose(){return this.closeEmitter.event}fireClose(){this.closeEmitter.fire(void 0)}get onPartialMessage(){return this.partialMessageEmitter.event}firePartialMessage(e){this.partialMessageEmitter.fire(e)}asError(e){return e instanceof Error?e:new Error(`Reader recevied error. Reason: ${n.string(e.message)?e.message:"unknown"}`)}}t.AbstractMessageReader=h;class l extends h{constructor(e,t="utf8"){super(),this.readable=e,this.buffer=new c(t),this._partialMessageTimeout=1e4}set partialMessageTimeout(e){this._partialMessageTimeout=e}get partialMessageTimeout(){return this._partialMessageTimeout}listen(e){this.nextMessageLength=-1,this.messageToken=0,this.partialMessageTimer=void 0,this.callback=e,this.readable.on("data",(e=>{this.onData(e)})),this.readable.on("error",(e=>this.fireError(e))),this.readable.on("close",(()=>this.fireClose()))}onData(e){for(this.buffer.append(e);;){if(-1===this.nextMessageLength){let e=this.buffer.tryReadHeaders();if(!e)return;let t=e["Content-Length"];if(!t)throw new Error("Header must provide a Content-Length property.");let s=parseInt(t);if(isNaN(s))throw new Error("Content-Length value must be a number.");this.nextMessageLength=s}var t=this.buffer.tryReadContent(this.nextMessageLength);if(null===t)return void this.setPartialMessageTimer();this.clearPartialMessageTimer(),this.nextMessageLength=-1,this.messageToken++;var s=JSON.parse(t);this.callback(s)}}clearPartialMessageTimer(){this.partialMessageTimer&&(clearTimeout(this.partialMessageTimer),this.partialMessageTimer=void 0)}setPartialMessageTimer(){this.clearPartialMessageTimer(),this._partialMessageTimeout<=0||(this.partialMessageTimer=setTimeout(((e,t)=>{this.partialMessageTimer=void 0,e===this.messageToken&&(this.firePartialMessage({messageToken:e,waitingTime:t}),this.setPartialMessageTimer())}),this._partialMessageTimeout,this.messageToken,this._partialMessageTimeout))}}t.StreamMessageReader=l,t.IPCMessageReader=class extends h{constructor(e){super(),this.process=e;let t=this.process;t.on("error",(e=>this.fireError(e))),t.on("close",(()=>this.fireClose()))}listen(e){this.process.on("message",e)}},t.SocketMessageReader=class extends l{constructor(e,t="utf-8"){super(e,t)}}},5841:(e,t,s)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0});const i=s(6559),n=s(8352);let r="Content-Length: ",o="\r\n";(t.MessageWriter||(t.MessageWriter={})).is=function(e){let t=e;return t&&n.func(t.dispose)&&n.func(t.onClose)&&n.func(t.onError)&&n.func(t.write)};class a{constructor(){this.errorEmitter=new i.Emitter,this.closeEmitter=new i.Emitter}dispose(){this.errorEmitter.dispose(),this.closeEmitter.dispose()}get onError(){return this.errorEmitter.event}fireError(e,t,s){this.errorEmitter.fire([this.asError(e),t,s])}get onClose(){return this.closeEmitter.event}fireClose(){this.closeEmitter.fire(void 0)}asError(e){return e instanceof Error?e:new Error(`Writer recevied error. Reason: ${n.string(e.message)?e.message:"unknown"}`)}}t.AbstractMessageWriter=a,t.StreamMessageWriter=class extends a{constructor(e,t="utf8"){super(),this.writable=e,this.encoding=t,this.errorCount=0,this.writable.on("error",(e=>this.fireError(e))),this.writable.on("close",(()=>this.fireClose()))}write(e){let t=JSON.stringify(e),s=Buffer.byteLength(t,this.encoding),i=[r,s.toString(),o,o];try{this.writable.write(i.join(""),"ascii"),this.writable.write(t,this.encoding),this.errorCount=0}catch(t){this.errorCount++,this.fireError(t,e,this.errorCount)}}},t.IPCMessageWriter=class extends a{constructor(e){super(),this.process=e,this.errorCount=0,this.queue=[],this.sending=!1;let t=this.process;t.on("error",(e=>this.fireError(e))),t.on("close",(()=>this.fireClose))}write(e){this.sending||0!==this.queue.length?this.queue.push(e):this.doWriteMessage(e)}doWriteMessage(e){try{this.process.send&&(this.sending=!0,this.process.send(e,void 0,void 0,(t=>{this.sending=!1,t?(this.errorCount++,this.fireError(t,e,this.errorCount)):this.errorCount=0,this.queue.length>0&&this.doWriteMessage(this.queue.shift())})))}catch(t){this.errorCount++,this.fireError(t,e,this.errorCount)}}},t.SocketMessageWriter=class extends a{constructor(e,t="utf8"){super(),this.socket=e,this.queue=[],this.sending=!1,this.encoding=t,this.errorCount=0,this.socket.on("error",(e=>this.fireError(e))),this.socket.on("close",(()=>this.fireClose()))}write(e){this.sending||0!==this.queue.length?this.queue.push(e):this.doWriteMessage(e)}doWriteMessage(e){let t=JSON.stringify(e),s=Buffer.byteLength(t,this.encoding),i=[r,s.toString(),o,o];try{this.sending=!0,this.socket.write(i.join(""),"ascii",(s=>{s&&this.handleError(s,e);try{this.socket.write(t,this.encoding,(t=>{this.sending=!1,t?this.handleError(t,e):this.errorCount=0,this.queue.length>0&&this.doWriteMessage(this.queue.shift())}))}catch(s){this.handleError(s,e)}}))}catch(t){this.handleError(t,e)}}handleError(e,t){this.errorCount++,this.fireError(e,t,this.errorCount)}}},9121:(e,t,s)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0});const i=s(8352);var n;!function(e){e.ParseError=-32700,e.InvalidRequest=-32600,e.MethodNotFound=-32601,e.InvalidParams=-32602,e.InternalError=-32603,e.serverErrorStart=-32099,e.serverErrorEnd=-32e3,e.ServerNotInitialized=-32002,e.UnknownErrorCode=-32001,e.RequestCancelled=-32800,e.MessageWriteError=1,e.MessageReadError=2}(n=t.ErrorCodes||(t.ErrorCodes={}));class r extends Error{constructor(e,t,s){super(t),this.code=i.number(e)?e:n.UnknownErrorCode,this.data=s,Object.setPrototypeOf(this,r.prototype)}toJson(){return{code:this.code,message:this.message,data:this.data}}}t.ResponseError=r;class o{constructor(e,t){this._method=e,this._numberOfParams=t}get method(){return this._method}get numberOfParams(){return this._numberOfParams}}t.AbstractMessageType=o,t.RequestType0=class extends o{constructor(e){super(e,0),this._=void 0}},t.RequestType=class extends o{constructor(e){super(e,1),this._=void 0}},t.RequestType1=class extends o{constructor(e){super(e,1),this._=void 0}},t.RequestType2=class extends o{constructor(e){super(e,2),this._=void 0}},t.RequestType3=class extends o{constructor(e){super(e,3),this._=void 0}},t.RequestType4=class extends o{constructor(e){super(e,4),this._=void 0}},t.RequestType5=class extends o{constructor(e){super(e,5),this._=void 0}},t.RequestType6=class extends o{constructor(e){super(e,6),this._=void 0}},t.RequestType7=class extends o{constructor(e){super(e,7),this._=void 0}},t.RequestType8=class extends o{constructor(e){super(e,8),this._=void 0}},t.RequestType9=class extends o{constructor(e){super(e,9),this._=void 0}},t.NotificationType=class extends o{constructor(e){super(e,1),this._=void 0}},t.NotificationType0=class extends o{constructor(e){super(e,0),this._=void 0}},t.NotificationType1=class extends o{constructor(e){super(e,1),this._=void 0}},t.NotificationType2=class extends o{constructor(e){super(e,2),this._=void 0}},t.NotificationType3=class extends o{constructor(e){super(e,3),this._=void 0}},t.NotificationType4=class extends o{constructor(e){super(e,4),this._=void 0}},t.NotificationType5=class extends o{constructor(e){super(e,5),this._=void 0}},t.NotificationType6=class extends o{constructor(e){super(e,6),this._=void 0}},t.NotificationType7=class extends o{constructor(e){super(e,7),this._=void 0}},t.NotificationType8=class extends o{constructor(e){super(e,8),this._=void 0}},t.NotificationType9=class extends o{constructor(e){super(e,9),this._=void 0}},t.isRequestMessage=function(e){let t=e;return t&&i.string(t.method)&&(i.string(t.id)||i.number(t.id))},t.isNotificationMessage=function(e){let t=e;return t&&i.string(t.method)&&void 0===e.id},t.isResponseMessage=function(e){let t=e;return t&&(void 0!==t.result||!!t.error)&&(i.string(t.id)||i.number(t.id)||null===t.id)}},7339:(e,t,s)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0});const i=s(1017),n=s(2037),r=s(6113),o=s(1808),a=s(9909),c=s(5841);t.generateRandomPipeName=function(){const e=r.randomBytes(21).toString("hex");return"win32"===process.platform?`\\\\.\\pipe\\vscode-jsonrpc-${e}-sock`:i.join(n.tmpdir(),`vscode-${e}.sock`)},t.createClientPipeTransport=function(e,t="utf-8"){let s,i=new Promise(((e,t)=>{s=e}));return new Promise(((n,r)=>{let h=o.createServer((e=>{h.close(),s([new a.SocketMessageReader(e,t),new c.SocketMessageWriter(e,t)])}));h.on("error",r),h.listen(e,(()=>{h.removeListener("error",r),n({onConnected:()=>i})}))}))},t.createServerPipeTransport=function(e,t="utf-8"){const s=o.createConnection(e);return[new a.SocketMessageReader(s,t),new c.SocketMessageWriter(s,t)]}},3105:(e,t,s)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0});const i=s(1808),n=s(9909),r=s(5841);t.createClientSocketTransport=function(e,t="utf-8"){let s,o=new Promise(((e,t)=>{s=e}));return new Promise(((a,c)=>{let h=i.createServer((e=>{h.close(),s([new n.SocketMessageReader(e,t),new r.SocketMessageWriter(e,t)])}));h.on("error",c),h.listen(e,"127.0.0.1",(()=>{h.removeListener("error",c),a({onConnected:()=>o})}))}))},t.createServerSocketTransport=function(e,t="utf-8"){const s=i.createConnection(e,"127.0.0.1");return[new n.SocketMessageReader(s,t),new r.SocketMessageWriter(s,t)]}},454:(e,t,s)=>{e.exports=s(7865)},205:e=>{var t={disableWarnings:!1,deprecationWarningMap:{},warn:function(e){!this.disableWarnings&&this.deprecationWarningMap[e]&&(console.warn("DEPRECATION WARNING: "+this.deprecationWarningMap[e]),this.deprecationWarningMap[e]=!1)}};e.exports=t},8152:(e,t,s)=>{var i=s(2283),n=s(4792),r=s(41);const o=0,a=1,c=2,h=3;function l(e,t,s,n,a,c){r.EventTarget.call(this),(c=c||{}).assembleFragments=!0;var h=this;this._url=e,this._readyState=o,this._protocol=void 0,this._extensions="",this._bufferedAmount=0,this._binaryType="arraybuffer",this._connection=void 0,this._client=new i(c),this._client.on("connect",(function(e){p.call(h,e)})),this._client.on("connectFailed",(function(){f.call(h)})),this._client.connect(e,t,s,n,a)}function u(e,t){var s=new r.Event("close");return s.code=e,s.reason=t,s.wasClean=void 0===e||1e3===e,s}function d(e){var t=new r.Event("message");return t.data=e,t}function p(e){var t=this;this._readyState=a,this._connection=e,this._protocol=e.protocol,this._extensions=e.extensions,this._connection.on("close",(function(e,s){g.call(t,e,s)})),this._connection.on("message",(function(e){m.call(t,e)})),this.dispatchEvent(new r.Event("open"))}function f(){y.call(this),this._readyState=h;try{this.dispatchEvent(new r.Event("error"))}finally{this.dispatchEvent(u(1006,"connection failed"))}}function g(e,t){y.call(this),this._readyState=h,this.dispatchEvent(u(e,t||""))}function m(e){if(e.utf8Data)this.dispatchEvent(d(e.utf8Data));else if(e.binaryData&&"arraybuffer"===this.binaryType){for(var t=e.binaryData,s=new ArrayBuffer(t.length),i=new Uint8Array(s),n=0,r=t.length;n<r;++n)i[n]=t[n];this.dispatchEvent(d(s))}}function y(){this._client.removeAllListeners(),this._connection&&this._connection.removeAllListeners()}e.exports=l,Object.defineProperties(l.prototype,{url:{get:function(){return this._url}},readyState:{get:function(){return this._readyState}},protocol:{get:function(){return this._protocol}},extensions:{get:function(){return this._extensions}},bufferedAmount:{get:function(){return this._bufferedAmount}}}),Object.defineProperties(l.prototype,{binaryType:{get:function(){return this._binaryType},set:function(e){if("arraybuffer"!==e)throw new SyntaxError('just "arraybuffer" type allowed for "binaryType" attribute');this._binaryType=e}}}),[["CONNECTING",o],["OPEN",a],["CLOSING",c],["CLOSED",h]].forEach((function(e){Object.defineProperty(l.prototype,e[0],{get:function(){return e[1]}})})),[["CONNECTING",o],["OPEN",a],["CLOSING",c],["CLOSED",h]].forEach((function(e){Object.defineProperty(l,e[0],{get:function(){return e[1]}})})),l.prototype.send=function(e){if(this._readyState!==a)throw new Error("cannot call send() while not connected");if("string"==typeof e||e instanceof String)this._connection.sendUTF(e);else if(e instanceof Buffer)this._connection.sendBytes(e);else{if(!e.byteLength&&0!==e.byteLength)throw new Error("unknown binary data:",e);e=n(e),this._connection.sendBytes(e)}},l.prototype.close=function(e,t){switch(this._readyState){case o:f.call(this),this._client.on("connect",(function(s){e?s.close(e,t):s.close()}));break;case a:this._readyState=c,e?this._connection.close(e,t):this._connection.close()}}},2283:(e,t,s)=>{var i=s(8550),n=i.extend,r=s(3837),o=s(2361).EventEmitter,a=s(3685),c=s(5687),h=s(7310),l=s(6113),u=s(7561),d=i.bufferAllocUnsafe,p=["(",")","<",">","@",",",";",":","\\",'"',"/","[","]","?","=","{","}"," ",String.fromCharCode(9)],f=["hostname","port","method","path","headers"];function g(e){var t;switch(o.call(this),this.config={maxReceivedFrameSize:1048576,maxReceivedMessageSize:8388608,fragmentOutgoingMessages:!0,fragmentationThreshold:16384,webSocketVersion:13,assembleFragments:!0,disableNagleAlgorithm:!0,closeTimeout:5e3,tlsOptions:{}},e&&(e.tlsOptions?(t=e.tlsOptions,delete e.tlsOptions):t={},n(this.config,e),n(this.config.tlsOptions,t)),this._req=null,this.config.webSocketVersion){case 8:case 13:break;default:throw new Error("Requested webSocketVersion is not supported. Allowed values are 8 and 13.")}}r.inherits(g,o),g.prototype.connect=function(e,t,s,r,o){var l=this;if("string"==typeof t&&(t=t.length>0?[t]:[]),t instanceof Array||(t=[]),this.protocols=t,this.origin=s,this.url="string"==typeof e?h.parse(e):e,!this.url.protocol)throw new Error("You must specify a full WebSocket URL, including protocol.");if(!this.url.host)throw new Error("You must specify a full WebSocket URL, including hostname. Relative URLs are not supported.");this.secure="wss:"===this.url.protocol,this.protocols.forEach((function(e){for(var t=0;t<e.length;t++){var s=e.charCodeAt(t),i=e.charAt(t);if(s<33||s>126||-1!==p.indexOf(i))throw new Error('Protocol list contains invalid character "'+String.fromCharCode(s)+'"')}})),this.url.port||(this.url.port={"ws:":"80","wss:":"443"}[this.url.protocol]);for(var u=d(16),g=0;g<16;g++)u[g]=Math.round(255*Math.random());this.base64nonce=u.toString("base64");var m=this.url.hostname;("ws:"===this.url.protocol&&"80"!==this.url.port||"wss:"===this.url.protocol&&"443"!==this.url.port)&&(m+=":"+this.url.port);var y,v={};function w(e){l._req=null,l.emit("connectFailed",e)}this.secure&&this.config.tlsOptions.hasOwnProperty("headers")&&n(v,this.config.tlsOptions.headers),r&&n(v,r),n(v,{Upgrade:"websocket",Connection:"Upgrade","Sec-WebSocket-Version":this.config.webSocketVersion.toString(10),"Sec-WebSocket-Key":this.base64nonce,Host:v.Host||m}),this.protocols.length>0&&(v["Sec-WebSocket-Protocol"]=this.protocols.join(", ")),this.origin&&(13===this.config.webSocketVersion?v.Origin=this.origin:8===this.config.webSocketVersion&&(v["Sec-WebSocket-Origin"]=this.origin)),y=this.url.pathname?this.url.path:this.url.path?"/"+this.url.path:"/";var S={agent:!1};if(o&&n(S,o),n(S,{hostname:this.url.hostname,port:this.url.port,method:"GET",path:y,headers:v}),this.secure){var b=this.config.tlsOptions;for(var E in b)b.hasOwnProperty(E)&&-1===f.indexOf(E)&&(S[E]=b[E])}var C=this._req=(this.secure?c:a).request(S);C.on("upgrade",(function(e,t,s){l._req=null,C.removeListener("error",w),l.socket=t,l.response=e,l.firstDataChunk=s,l.validateHandshake()})),C.on("error",w),C.on("response",(function(e){if(l._req=null,i.eventEmitterListenerCount(l,"httpResponse")>0)l.emit("httpResponse",e,l),e.socket&&e.socket.end();else{var t=[];for(var s in e.headers)t.push(s+": "+e.headers[s]);l.failHandshake("Server responded with a non-101 status: "+e.statusCode+" "+e.statusMessage+"\nResponse Headers Follow:\n"+t.join("\n")+"\n")}})),C.end()},g.prototype.validateHandshake=function(){var e=this.response.headers;if(this.protocols.length>0){if(this.protocol=e["sec-websocket-protocol"],!this.protocol)return void this.failHandshake("Expected a Sec-WebSocket-Protocol header.");if(-1===this.protocols.indexOf(this.protocol))return void this.failHandshake("Server did not respond with a requested protocol.")}if(e.connection&&"upgrade"===e.connection.toLocaleLowerCase())if(e.upgrade&&"websocket"===e.upgrade.toLocaleLowerCase()){var t=l.createHash("sha1");t.update(this.base64nonce+"258EAFA5-E914-47DA-95CA-C5AB0DC85B11");var s=t.digest("base64");e["sec-websocket-accept"]?e["sec-websocket-accept"]===s?this.succeedHandshake():this.failHandshake("Sec-WebSocket-Accept header from server didn't match expected value of "+s):this.failHandshake("Expected Sec-WebSocket-Accept header from server")}else this.failHandshake("Expected an Upgrade: websocket header from the server");else this.failHandshake("Expected a Connection: Upgrade header from the server")},g.prototype.failHandshake=function(e){this.socket&&this.socket.writable&&this.socket.end(),this.emit("connectFailed",new Error(e))},g.prototype.succeedHandshake=function(){var e=new u(this.socket,[],this.protocol,!0,this.config);e.webSocketVersion=this.config.webSocketVersion,e._addSocketEventListeners(),this.emit("connect",e),this.firstDataChunk.length>0&&e.handleSocketData(this.firstDataChunk),this.firstDataChunk=null},g.prototype.abort=function(){this._req&&this._req.abort()},e.exports=g},7561:(e,t,s)=>{var i=s(3837),n=s(8550),r=s(2361).EventEmitter,o=s(9891),a=s(8671),c=s(9167),h=n.bufferAllocUnsafe,l=n.bufferFromString;const u="open",d="peer_requested_close",p="ending",f="closed";var g="setImmediate"in global?global.setImmediate.bind(global):process.nextTick.bind(process),m=0;function y(e,t,s,i,c){if(this._debug=n.BufferingLogger("websocket:connection",++m),this._debug("constructor"),this._debug.enabled&&function(e,t){if(e._debug.enabled){var s=t.emit;for(var i in t.emit=function(t){e._debug("||| Socket Event  '%s'",t),s.apply(this,arguments)},t)"function"==typeof t[i]&&-1===["emit"].indexOf(i)&&function(s){var i=t[s];t[s]="on"!==s?function(){return e._debug("||| Socket method called:  %s",s),i.apply(this,arguments)}:function(){return e._debug("||| Socket method called:  %s (%s)",s,arguments[0]),i.apply(this,arguments)}}(i)}}(this,e),r.call(this),this._pingListenerCount=0,this.on("newListener",(function(e){"ping"===e&&this._pingListenerCount++})).on("removeListener",(function(e){"ping"===e&&this._pingListenerCount--})),this.config=c,this.socket=e,this.protocol=s,this.extensions=t,this.remoteAddress=e.remoteAddress,this.closeReasonCode=-1,this.closeDescription=null,this.closeEventEmitted=!1,this.maskOutgoingPackets=i,this.maskBytes=h(4),this.frameHeader=h(10),this.bufferList=new a,this.currentFrame=new o(this.maskBytes,this.frameHeader,this.config),this.fragmentationSize=0,this.frameQueue=[],this.connected=!0,this.state=u,this.waitingForCloseResponse=!1,this.receivedEnd=!1,this.closeTimeout=this.config.closeTimeout,this.assembleFragments=this.config.assembleFragments,this.maxReceivedMessageSize=this.config.maxReceivedMessageSize,this.outputBufferFull=!1,this.inputPaused=!1,this.receivedDataHandler=this.processReceivedData.bind(this),this._closeTimerHandler=this.handleCloseTimer.bind(this),this.socket.setNoDelay(this.config.disableNagleAlgorithm),this.socket.setTimeout(0),this.config.keepalive&&!this.config.useNativeKeepalive){if("number"!=typeof this.config.keepaliveInterval)throw new Error("keepaliveInterval must be specified and numeric if keepalive is true.");if(this._keepaliveTimerHandler=this.handleKeepaliveTimer.bind(this),this.setKeepaliveTimer(),this.config.dropConnectionOnKeepaliveTimeout){if("number"!=typeof this.config.keepaliveGracePeriod)throw new Error("keepaliveGracePeriod  must be specified and numeric if dropConnectionOnKeepaliveTimeout is true.");this._gracePeriodTimerHandler=this.handleGracePeriodTimer.bind(this)}}else if(this.config.keepalive&&this.config.useNativeKeepalive){if(!("setKeepAlive"in this.socket))throw new Error("Unable to use native keepalive: unsupported by this version of Node.");this.socket.setKeepAlive(!0,this.config.keepaliveInterval)}this.socket.removeAllListeners("error")}function v(e){return!(e<1e3)&&(e>=1e3&&e<=2999?-1!==[1e3,1001,1002,1003,1007,1008,1009,1010,1011,1012,1013,1014,1015].indexOf(e):e>=3e3&&e<=3999||e>=4e3&&e<=4999||!(e>=5e3)&&void 0)}y.CLOSE_REASON_NORMAL=1e3,y.CLOSE_REASON_GOING_AWAY=1001,y.CLOSE_REASON_PROTOCOL_ERROR=1002,y.CLOSE_REASON_UNPROCESSABLE_INPUT=1003,y.CLOSE_REASON_RESERVED=1004,y.CLOSE_REASON_NOT_PROVIDED=1005,y.CLOSE_REASON_ABNORMAL=1006,y.CLOSE_REASON_INVALID_DATA=1007,y.CLOSE_REASON_POLICY_VIOLATION=1008,y.CLOSE_REASON_MESSAGE_TOO_BIG=1009,y.CLOSE_REASON_EXTENSION_REQUIRED=1010,y.CLOSE_REASON_INTERNAL_SERVER_ERROR=1011,y.CLOSE_REASON_TLS_HANDSHAKE_FAILED=1015,y.CLOSE_DESCRIPTIONS={1e3:"Normal connection closure",1001:"Remote peer is going away",1002:"Protocol error",1003:"Unprocessable input",1004:"Reserved",1005:"Reason not provided",1006:"Abnormal closure, no further detail available",1007:"Invalid data received",1008:"Policy violation",1009:"Message too big",1010:"Extension requested by client is required",1011:"Internal Server Error",1015:"TLS Handshake Failed"},i.inherits(y,r),y.prototype._addSocketEventListeners=function(){this.socket.on("error",this.handleSocketError.bind(this)),this.socket.on("end",this.handleSocketEnd.bind(this)),this.socket.on("close",this.handleSocketClose.bind(this)),this.socket.on("drain",this.handleSocketDrain.bind(this)),this.socket.on("pause",this.handleSocketPause.bind(this)),this.socket.on("resume",this.handleSocketResume.bind(this)),this.socket.on("data",this.handleSocketData.bind(this))},y.prototype.setKeepaliveTimer=function(){this._debug("setKeepaliveTimer"),this.config.keepalive&&!this.config.useNativeKeepalive&&(this.clearKeepaliveTimer(),this.clearGracePeriodTimer(),this._keepaliveTimeoutID=setTimeout(this._keepaliveTimerHandler,this.config.keepaliveInterval))},y.prototype.clearKeepaliveTimer=function(){this._keepaliveTimeoutID&&clearTimeout(this._keepaliveTimeoutID)},y.prototype.handleKeepaliveTimer=function(){this._debug("handleKeepaliveTimer"),this._keepaliveTimeoutID=null,this.ping(),this.config.dropConnectionOnKeepaliveTimeout?this.setGracePeriodTimer():this.setKeepaliveTimer()},y.prototype.setGracePeriodTimer=function(){this._debug("setGracePeriodTimer"),this.clearGracePeriodTimer(),this._gracePeriodTimeoutID=setTimeout(this._gracePeriodTimerHandler,this.config.keepaliveGracePeriod)},y.prototype.clearGracePeriodTimer=function(){this._gracePeriodTimeoutID&&clearTimeout(this._gracePeriodTimeoutID)},y.prototype.handleGracePeriodTimer=function(){this._debug("handleGracePeriodTimer"),this._gracePeriodTimeoutID=null,this.drop(y.CLOSE_REASON_ABNORMAL,"Peer not responding.",!0)},y.prototype.handleSocketData=function(e){this._debug("handleSocketData"),this.setKeepaliveTimer(),this.bufferList.write(e),this.processReceivedData()},y.prototype.processReceivedData=function(){if(this._debug("processReceivedData"),this.connected&&!this.inputPaused){var e=this.currentFrame;if(e.addData(this.bufferList)){var t=this;if(e.protocolError)return this._debug("-- protocol error"),void process.nextTick((function(){t.drop(y.CLOSE_REASON_PROTOCOL_ERROR,e.dropReason)}));if(e.frameTooLarge)return this._debug("-- frame too large"),void process.nextTick((function(){t.drop(y.CLOSE_REASON_MESSAGE_TOO_BIG,e.dropReason)}));if(e.rsv1||e.rsv2||e.rsv3)return this._debug("-- illegal rsv flag"),void process.nextTick((function(){t.drop(y.CLOSE_REASON_PROTOCOL_ERROR,"Unsupported usage of rsv bits without negotiated extension.")}));this.assembleFragments||(this._debug("-- emitting frame"),process.nextTick((function(){t.emit("frame",e)}))),process.nextTick((function(){t.processFrame(e)})),this.currentFrame=new o(this.maskBytes,this.frameHeader,this.config),this.bufferList.length>0&&g(this.receivedDataHandler)}else this._debug("-- insufficient data for frame")}},y.prototype.handleSocketError=function(e){this._debug("handleSocketError: %j",e),this.state!==f?(this.closeReasonCode=y.CLOSE_REASON_ABNORMAL,this.closeDescription="Socket Error: "+e.syscall+" "+e.code,this.connected=!1,this.state=f,this.fragmentationSize=0,n.eventEmitterListenerCount(this,"error")>0&&this.emit("error",e),this.socket.destroy(),this._debug.printOutput()):this._debug("  --- Socket 'error' after 'close'")},y.prototype.handleSocketEnd=function(){this._debug("handleSocketEnd: received socket end.  state = %s",this.state),this.receivedEnd=!0,this.state!==f?this.state!==d&&this.state!==p&&(this._debug("  --- UNEXPECTED socket end."),this.socket.end()):this._debug("  --- Socket 'end' after 'close'")},y.prototype.handleSocketClose=function(e){this._debug("handleSocketClose: received socket close"),this.socketHadError=e,this.connected=!1,this.state=f,-1===this.closeReasonCode&&(this.closeReasonCode=y.CLOSE_REASON_ABNORMAL,this.closeDescription="Connection dropped by remote peer."),this.clearCloseTimer(),this.clearKeepaliveTimer(),this.clearGracePeriodTimer(),this.closeEventEmitted||(this.closeEventEmitted=!0,this._debug("-- Emitting WebSocketConnection close event"),this.emit("close",this.closeReasonCode,this.closeDescription))},y.prototype.handleSocketDrain=function(){this._debug("handleSocketDrain: socket drain event"),this.outputBufferFull=!1,this.emit("drain")},y.prototype.handleSocketPause=function(){this._debug("handleSocketPause: socket pause event"),this.inputPaused=!0,this.emit("pause")},y.prototype.handleSocketResume=function(){this._debug("handleSocketResume: socket resume event"),this.inputPaused=!1,this.emit("resume"),this.processReceivedData()},y.prototype.pause=function(){this._debug("pause: pause requested"),this.socket.pause()},y.prototype.resume=function(){this._debug("resume: resume requested"),this.socket.resume()},y.prototype.close=function(e,t){if(this.connected){if(this._debug("close: Initating clean WebSocket close sequence."),"number"!=typeof e&&(e=y.CLOSE_REASON_NORMAL),!v(e))throw new Error("Close code "+e+" is not valid.");"string"!=typeof t&&(t=y.CLOSE_DESCRIPTIONS[e]),this.closeReasonCode=e,this.closeDescription=t,this.setCloseTimer(),this.sendCloseFrame(this.closeReasonCode,this.closeDescription),this.state=p,this.connected=!1}},y.prototype.drop=function(e,t,s){this._debug("drop"),"number"!=typeof e&&(e=y.CLOSE_REASON_PROTOCOL_ERROR),"string"!=typeof t&&(t=y.CLOSE_DESCRIPTIONS[e]),this._debug("Forcefully dropping connection. skipCloseFrame: %s, code: %d, description: %s",s,e,t),this.closeReasonCode=e,this.closeDescription=t,this.frameQueue=[],this.fragmentationSize=0,s||this.sendCloseFrame(e,t),this.connected=!1,this.state=f,this.clearCloseTimer(),this.clearKeepaliveTimer(),this.clearGracePeriodTimer(),this.closeEventEmitted||(this.closeEventEmitted=!0,this._debug("Emitting WebSocketConnection close event"),this.emit("close",this.closeReasonCode,this.closeDescription)),this._debug("Drop: destroying socket"),this.socket.destroy()},y.prototype.setCloseTimer=function(){this._debug("setCloseTimer"),this.clearCloseTimer(),this._debug("Setting close timer"),this.waitingForCloseResponse=!0,this.closeTimer=setTimeout(this._closeTimerHandler,this.closeTimeout)},y.prototype.clearCloseTimer=function(){this._debug("clearCloseTimer"),this.closeTimer&&(this._debug("Clearing close timer"),clearTimeout(this.closeTimer),this.waitingForCloseResponse=!1,this.closeTimer=null)},y.prototype.handleCloseTimer=function(){this._debug("handleCloseTimer"),this.closeTimer=null,this.waitingForCloseResponse&&(this._debug("Close response not received from client.  Forcing socket end."),this.waitingForCloseResponse=!1,this.state=f,this.socket.end())},y.prototype.processFrame=function(e){if(this._debug("processFrame"),this._debug(" -- frame: %s",e),0!==this.frameQueue.length&&e.opcode>0&&e.opcode<8)this.drop(y.CLOSE_REASON_PROTOCOL_ERROR,"Illegal frame opcode 0x"+e.opcode.toString(16)+" received in middle of fragmented message.");else switch(e.opcode){case 2:this._debug("-- Binary Frame"),this.assembleFragments&&(e.fin?(this._debug("---- Emitting 'message' event"),this.emit("message",{type:"binary",binaryData:e.binaryPayload})):(this.frameQueue.push(e),this.fragmentationSize=e.length));break;case 1:if(this._debug("-- Text Frame"),this.assembleFragments)if(e.fin){if(!c(e.binaryPayload))return void this.drop(y.CLOSE_REASON_INVALID_DATA,"Invalid UTF-8 Data Received");this._debug("---- Emitting 'message' event"),this.emit("message",{type:"utf8",utf8Data:e.binaryPayload.toString("utf8")})}else this.frameQueue.push(e),this.fragmentationSize=e.length;break;case 0:if(this._debug("-- Continuation Frame"),this.assembleFragments){if(0===this.frameQueue.length)return void this.drop(y.CLOSE_REASON_PROTOCOL_ERROR,"Unexpected Continuation Frame");if(this.fragmentationSize+=e.length,this.fragmentationSize>this.maxReceivedMessageSize)return void this.drop(y.CLOSE_REASON_MESSAGE_TOO_BIG,"Maximum message size exceeded.");if(this.frameQueue.push(e),e.fin){var t=0,s=h(this.fragmentationSize),i=this.frameQueue[0].opcode;switch(this.frameQueue.forEach((function(e){e.binaryPayload.copy(s,t),t+=e.binaryPayload.length})),this.frameQueue=[],this.fragmentationSize=0,i){case 2:this.emit("message",{type:"binary",binaryData:s});break;case 1:if(!c(s))return void this.drop(y.CLOSE_REASON_INVALID_DATA,"Invalid UTF-8 Data Received");this.emit("message",{type:"utf8",utf8Data:s.toString("utf8")});break;default:return void this.drop(y.CLOSE_REASON_PROTOCOL_ERROR,"Unexpected first opcode in fragmentation sequence: 0x"+i.toString(16))}}}break;case 9:if(this._debug("-- Ping Frame"),this._pingListenerCount>0){var n=!1;this.emit("ping",(function(){n=!0}),e.binaryPayload),n||this.pong(e.binaryPayload)}else this.pong(e.binaryPayload);break;case 10:this._debug("-- Pong Frame"),this.emit("pong",e.binaryPayload);break;case 8:if(this._debug("-- Close Frame"),this.waitingForCloseResponse)return this._debug("---- Got close response from peer.  Completing closing handshake."),this.clearCloseTimer(),this.waitingForCloseResponse=!1,this.state=f,void this.socket.end();var r;if(this._debug("---- Closing handshake initiated by peer."),this.state=d,e.invalidCloseFrameLength?(this.closeReasonCode=1005,r=y.CLOSE_REASON_PROTOCOL_ERROR):-1===e.closeStatus||v(e.closeStatus)?(this.closeReasonCode=e.closeStatus,r=y.CLOSE_REASON_NORMAL):(this.closeReasonCode=e.closeStatus,r=y.CLOSE_REASON_PROTOCOL_ERROR),e.binaryPayload.length>1){if(!c(e.binaryPayload))return void this.drop(y.CLOSE_REASON_INVALID_DATA,"Invalid UTF-8 Data Received");this.closeDescription=e.binaryPayload.toString("utf8")}else this.closeDescription=y.CLOSE_DESCRIPTIONS[this.closeReasonCode];this._debug("------ Remote peer %s - code: %d - %s - close frame payload length: %d",this.remoteAddress,this.closeReasonCode,this.closeDescription,e.length),this._debug("------ responding to remote peer's close request."),this.sendCloseFrame(r,null),this.connected=!1;break;default:this._debug("-- Unrecognized Opcode %d",e.opcode),this.drop(y.CLOSE_REASON_PROTOCOL_ERROR,"Unrecognized Opcode: 0x"+e.opcode.toString(16))}},y.prototype.send=function(e,t){if(this._debug("send"),Buffer.isBuffer(e))this.sendBytes(e,t);else{if("function"!=typeof e.toString)throw new Error("Data provided must either be a Node Buffer or implement toString()");this.sendUTF(e,t)}},y.prototype.sendUTF=function(e,t){e=l(e.toString(),"utf8"),this._debug("sendUTF: %d bytes",e.length);var s=new o(this.maskBytes,this.frameHeader,this.config);s.opcode=1,s.binaryPayload=e,this.fragmentAndSend(s,t)},y.prototype.sendBytes=function(e,t){if(this._debug("sendBytes"),!Buffer.isBuffer(e))throw new Error("You must pass a Node Buffer object to WebSocketConnection.prototype.sendBytes()");var s=new o(this.maskBytes,this.frameHeader,this.config);s.opcode=2,s.binaryPayload=e,this.fragmentAndSend(s,t)},y.prototype.ping=function(e){this._debug("ping");var t=new o(this.maskBytes,this.frameHeader,this.config);t.opcode=9,t.fin=!0,e&&(Buffer.isBuffer(e)||(e=l(e.toString(),"utf8")),e.length>125&&(this._debug("WebSocket: Data for ping is longer than 125 bytes.  Truncating."),e=e.slice(0,124)),t.binaryPayload=e),this.sendFrame(t)},y.prototype.pong=function(e){this._debug("pong");var t=new o(this.maskBytes,this.frameHeader,this.config);t.opcode=10,Buffer.isBuffer(e)&&e.length>125&&(this._debug("WebSocket: Data for pong is longer than 125 bytes.  Truncating."),e=e.slice(0,124)),t.binaryPayload=e,t.fin=!0,this.sendFrame(t)},y.prototype.fragmentAndSend=function(e,t){if(this._debug("fragmentAndSend"),e.opcode>7)throw new Error("You cannot fragment control frames.");var s=this.config.fragmentationThreshold,i=e.binaryPayload.length;if(!this.config.fragmentOutgoingMessages||e.binaryPayload&&i<=s)return e.fin=!0,void this.sendFrame(e,t);for(var n=Math.ceil(i/s),r=0,a=function(e){e?"function"==typeof t&&(t(e),t=null):++r===n&&"function"==typeof t&&t()},c=1;c<=n;c++){var h=new o(this.maskBytes,this.frameHeader,this.config);h.opcode=1===c?e.opcode:0,h.fin=c===n;var l=c===n?i-s*(c-1):s,u=s*(c-1);h.binaryPayload=e.binaryPayload.slice(u,u+l),this.sendFrame(h,a)}},y.prototype.sendCloseFrame=function(e,t,s){if("number"!=typeof e&&(e=y.CLOSE_REASON_NORMAL),this._debug("sendCloseFrame state: %s, reasonCode: %d, description: %s",this.state,e,t),this.state===u||this.state===d){var i=new o(this.maskBytes,this.frameHeader,this.config);i.fin=!0,i.opcode=8,i.closeStatus=e,"string"==typeof t&&(i.binaryPayload=l(t,"utf8")),this.sendFrame(i,s),this.socket.end()}},y.prototype.sendFrame=function(e,t){this._debug("sendFrame"),e.mask=this.maskOutgoingPackets;var s=this.socket.write(e.toBuffer(),t);return this.outputBufferFull=!s,s},e.exports=y},9891:(e,t,s)=>{var i=s(796),n=s(8550).bufferAllocUnsafe;function r(e,t,s){this.maskBytes=e,this.frameHeader=t,this.config=s,this.maxReceivedFrameSize=s.maxReceivedFrameSize,this.protocolError=!1,this.frameTooLarge=!1,this.invalidCloseFrameLength=!1,this.parseState=1,this.closeStatus=-1}r.prototype.addData=function(e){if(1===this.parseState&&e.length>=2){e.joinInto(this.frameHeader,0,0,2),e.advance(2);var t=this.frameHeader[0],s=this.frameHeader[1];if(this.fin=Boolean(128&t),this.rsv1=Boolean(64&t),this.rsv2=Boolean(32&t),this.rsv3=Boolean(16&t),this.mask=Boolean(128&s),this.opcode=15&t,this.length=127&s,this.opcode>=8){if(this.length>125)return this.protocolError=!0,this.dropReason="Illegal control frame longer than 125 bytes.",!0;if(!this.fin)return this.protocolError=!0,this.dropReason="Control frames must not be fragmented.",!0}126===this.length?this.parseState=2:127===this.length?this.parseState=3:this.parseState=4}if(2===this.parseState)e.length>=2&&(e.joinInto(this.frameHeader,2,0,2),e.advance(2),this.length=this.frameHeader.readUInt16BE(2),this.parseState=4);else if(3===this.parseState&&e.length>=8){e.joinInto(this.frameHeader,2,0,8),e.advance(8);var r=[this.frameHeader.readUInt32BE(2),this.frameHeader.readUInt32BE(6)];if(0!==r[0])return this.protocolError=!0,this.dropReason="Unsupported 64-bit length frame received",!0;this.length=r[1],this.parseState=4}if(4===this.parseState&&(this.mask?e.length>=4&&(e.joinInto(this.maskBytes,0,0,4),e.advance(4),this.parseState=5):this.parseState=5),5===this.parseState){if(this.length>this.maxReceivedFrameSize)return this.frameTooLarge=!0,this.dropReason="Frame size of "+this.length.toString(10)+" bytes exceeds maximum accepted frame size",!0;if(0===this.length)return this.binaryPayload=n(0),this.parseState=6,!0;if(e.length>=this.length)return this.binaryPayload=e.take(this.length),e.advance(this.length),this.mask&&i.unmask(this.binaryPayload,this.maskBytes),8===this.opcode&&(1===this.length&&(this.binaryPayload=n(0),this.invalidCloseFrameLength=!0),this.length>=2&&(this.closeStatus=this.binaryPayload.readUInt16BE(0),this.binaryPayload=this.binaryPayload.slice(2))),this.parseState=6,!0}return!1},r.prototype.throwAwayPayload=function(e){return e.length>=this.length&&(e.advance(this.length),this.parseState=6,!0)},r.prototype.toBuffer=function(e){var t,s,r,o=2,a=0,c=0;this.fin&&(a|=128),this.rsv1&&(a|=64),this.rsv2&&(a|=32),this.rsv3&&(a|=16),this.mask&&(c|=128),a|=15&this.opcode,8===this.opcode?(this.length=2,this.binaryPayload&&(this.length+=this.binaryPayload.length),(s=n(this.length)).writeUInt16BE(this.closeStatus,0),this.length>2&&this.binaryPayload.copy(s,2)):this.binaryPayload?(s=this.binaryPayload,this.length=s.length):this.length=0,this.length<=125?c|=127&this.length:this.length>125&&this.length<=65535?(c|=126,o+=2):this.length>65535&&(c|=127,o+=8);var h=n(this.length+o+(this.mask?4:0));return h[0]=a,h[1]=c,r=2,this.length>125&&this.length<=65535?(h.writeUInt16BE(this.length,r),r+=2):this.length>65535&&(h.writeUInt32BE(0,r),h.writeUInt32BE(this.length,r+4),r+=8),this.mask?(t=e?0:4294967295*Math.random()>>>0,this.maskBytes.writeUInt32BE(t,0),this.maskBytes.copy(h,r),r+=4,s&&i.mask(s,this.maskBytes,h,r,this.length)):s&&s.copy(h,r),h},r.prototype.toString=function(){return"Opcode: "+this.opcode+", fin: "+this.fin+", length: "+this.length+", hasPayload: "+Boolean(this.binaryPayload)+", masked: "+this.mask},e.exports=r},948:(e,t,s)=>{for(var i=s(6113),n=s(3837),r=s(7310),o=s(2361).EventEmitter,a=s(7561),c=/,\s*/,h=/;\s*/,l=/[\r\n]/g,u=/,\s*/,d=["(",")","<",">","@",",",";",":","\\",'"',"/","[","]","?","=","{","}"," ",String.fromCharCode(9)],p=[String.fromCharCode(127)],f=0;f<31;f++)p.push(String.fromCharCode(f));var g=/([\x00-\x20\x22\x28\x29\x2c\x2f\x3a-\x3f\x40\x5b-\x5e\x7b\x7d\x7f])/,m=/[^\x21\x23-\x2b\x2d-\x3a\x3c-\x5b\x5d-\x7e]/,y=/^"[^"]*"$/,v=/[\x00-\x20\x3b]/g,w=/[;,] */,S={100:"Continue",101:"Switching Protocols",200:"OK",201:"Created",203:"Non-Authoritative Information",204:"No Content",205:"Reset Content",206:"Partial Content",300:"Multiple Choices",301:"Moved Permanently",302:"Found",303:"See Other",304:"Not Modified",305:"Use Proxy",307:"Temporary Redirect",400:"Bad Request",401:"Unauthorized",402:"Payment Required",403:"Forbidden",404:"Not Found",406:"Not Acceptable",407:"Proxy Authorization Required",408:"Request Timeout",409:"Conflict",410:"Gone",411:"Length Required",412:"Precondition Failed",413:"Request Entity Too Long",414:"Request-URI Too Long",415:"Unsupported Media Type",416:"Requested Range Not Satisfiable",417:"Expectation Failed",426:"Upgrade Required",500:"Internal Server Error",501:"Not Implemented",502:"Bad Gateway",503:"Service Unavailable",504:"Gateway Timeout",505:"HTTP Version Not Supported"};function b(e,t,s){o.call(this),this.socket=e,this.httpRequest=t,this.resource=t.url,this.remoteAddress=e.remoteAddress,this.remoteAddresses=[this.remoteAddress],this.serverConfig=s,this._socketIsClosing=!1,this._socketCloseHandler=this._handleSocketCloseBeforeAccept.bind(this),this.socket.on("end",this._socketCloseHandler),this.socket.on("close",this._socketCloseHandler),this._resolved=!1}function E(e){process.nextTick((function(){e.drop(1006,"TCP connection lost before handshake completed.",!0)}))}n.inherits(b,o),b.prototype.readHandshake=function(){var e=this,t=this.httpRequest;if(this.resourceURL=r.parse(this.resource,!0),this.host=t.headers.host,!this.host)throw new Error("Client must provide a Host header.");if(this.key=t.headers["sec-websocket-key"],!this.key)throw new Error("Client must provide a value for Sec-WebSocket-Key.");if(this.webSocketVersion=parseInt(t.headers["sec-websocket-version"],10),!this.webSocketVersion||isNaN(this.webSocketVersion))throw new Error("Client must provide a value for Sec-WebSocket-Version.");switch(this.webSocketVersion){case 8:case 13:break;default:var s=new Error("Unsupported websocket client version: "+this.webSocketVersion+"Only versions 8 and 13 are supported.");throw s.httpCode=426,s.headers={"Sec-WebSocket-Version":"13"},s}13===this.webSocketVersion?this.origin=t.headers.origin:8===this.webSocketVersion&&(this.origin=t.headers["sec-websocket-origin"]);var i=t.headers["sec-websocket-protocol"];if(this.protocolFullCaseMap={},this.requestedProtocols=[],i&&i.split(c).forEach((function(t){var s=t.toLocaleLowerCase();e.requestedProtocols.push(s),e.protocolFullCaseMap[s]=t})),!this.serverConfig.ignoreXForwardedFor&&t.headers["x-forwarded-for"]){var n=this.remoteAddress;this.remoteAddresses=t.headers["x-forwarded-for"].split(u),this.remoteAddresses.push(n),this.remoteAddress=this.remoteAddresses[0]}if(this.serverConfig.parseExtensions){var o=t.headers["sec-websocket-extensions"];this.requestedExtensions=this.parseExtensions(o)}else this.requestedExtensions=[];if(this.serverConfig.parseCookies){var a=t.headers.cookie;this.cookies=this.parseCookies(a)}else this.cookies=[]},b.prototype.parseExtensions=function(e){if(!e||0===e.length)return[];var t=e.toLocaleLowerCase().split(c);return t.forEach((function(e,t,s){var i=e.split(h),n=i[0],r=i.slice(1);r.forEach((function(e,t,s){var i=e.split("="),n={name:i[0],value:i[1]};s.splice(t,1,n)}));var o={name:n,params:r};s.splice(t,1,o)})),t},b.prototype.parseCookies=function(e){if(!e||"string"!=typeof e)return[];var t=[];return e.split(w).forEach((function(e){var s=e.indexOf("=");if(-1!==s){var i=e.substr(0,s).trim(),n=e.substr(++s,e.length).trim();'"'===n[0]&&(n=n.slice(1,-1)),t.push({name:i,value:decodeURIComponent(n)})}else t.push({name:e,value:null})})),t},b.prototype.accept=function(e,t,s){var n;this._verifyResolution(),e?void 0===(n=this.protocolFullCaseMap[e.toLocaleLowerCase()])&&(n=e):n=e,this.protocolFullCaseMap=null;var r=i.createHash("sha1");r.update(this.key+"258EAFA5-E914-47DA-95CA-C5AB0DC85B11");var o="HTTP/1.1 101 Switching Protocols\r\nUpgrade: websocket\r\nConnection: Upgrade\r\nSec-WebSocket-Accept: "+r.digest("base64")+"\r\n";if(n){for(var c=0;c<n.length;c++){var h=n.charCodeAt(c),u=n.charAt(c);if(h<33||h>126||-1!==d.indexOf(u))throw this.reject(500),new Error('Illegal character "'+String.fromCharCode(u)+'" in subprotocol.')}if(-1===this.requestedProtocols.indexOf(e))throw this.reject(500),new Error("Specified protocol was not requested by the client.");n=n.replace(l,""),o+="Sec-WebSocket-Protocol: "+n+"\r\n"}if(this.requestedProtocols=null,t&&(t=t.replace(l,""),13===this.webSocketVersion?o+="Origin: "+t+"\r\n":8===this.webSocketVersion&&(o+="Sec-WebSocket-Origin: "+t+"\r\n")),s){if(!Array.isArray(s))throw this.reject(500),new Error('Value supplied for "cookies" argument must be an array.');var p={};s.forEach(function(e){if(!e.name||!e.value)throw this.reject(500),new Error('Each cookie to set must at least provide a "name" and "value"');if(e.name=e.name.replace(v,""),e.value=e.value.replace(v,""),p[e.name])throw this.reject(500),new Error("You may not specify the same cookie name twice.");p[e.name]=!0;var t=e.name.match(g);if(t)throw this.reject(500),new Error("Illegal character "+t[0]+" in cookie name");if(t=e.value.match(y)?e.value.slice(1,-1).match(m):e.value.match(m))throw this.reject(500),new Error("Illegal character "+t[0]+" in cookie value");var s=[e.name+"="+e.value];if(e.path){if(t=e.path.match(v))throw this.reject(500),new Error("Illegal character "+t[0]+" in cookie path");s.push("Path="+e.path)}if(e.domain){if("string"!=typeof e.domain)throw this.reject(500),new Error("Domain must be specified and must be a string.");if(t=e.domain.match(v))throw this.reject(500),new Error("Illegal character "+t[0]+" in cookie domain");s.push("Domain="+e.domain.toLowerCase())}if(e.expires){if(!(e.expires instanceof Date))throw this.reject(500),new Error('Value supplied for cookie "expires" must be a vaild date object');s.push("Expires="+e.expires.toGMTString())}if(e.maxage){var i=e.maxage;if("string"==typeof i&&(i=parseInt(i,10)),isNaN(i)||i<=0)throw this.reject(500),new Error('Value supplied for cookie "maxage" must be a non-zero number');i=Math.round(i),s.push("Max-Age="+i.toString(10))}if(e.secure){if("boolean"!=typeof e.secure)throw this.reject(500),new Error('Value supplied for cookie "secure" must be of type boolean');s.push("Secure")}if(e.httponly){if("boolean"!=typeof e.httponly)throw this.reject(500),new Error('Value supplied for cookie "httponly" must be of type boolean');s.push("HttpOnly")}o+="Set-Cookie: "+s.join(";")+"\r\n"}.bind(this))}this._resolved=!0,this.emit("requestResolved",this),o+="\r\n";var f=new a(this.socket,[],e,!1,this.serverConfig);f.webSocketVersion=this.webSocketVersion,f.remoteAddress=this.remoteAddress,f.remoteAddresses=this.remoteAddresses;var w=this;return this._socketIsClosing?E(f):this.socket.write(o,"ascii",(function(e){e?E(f):(w._removeSocketCloseListeners(),f._addSocketEventListeners())})),this.emit("requestAccepted",f),f},b.prototype.reject=function(e,t,s){this._verifyResolution(),this._resolved=!0,this.emit("requestResolved",this),"number"!=typeof e&&(e=403);var i="HTTP/1.1 "+e+" "+S[e]+"\r\nConnection: close\r\n";if(t&&(i+="X-WebSocket-Reject-Reason: "+(t=t.replace(l,""))+"\r\n"),s)for(var n in s){var r=s[n].toString().replace(l,"");i+=n.replace(l,"")+": "+r+"\r\n"}i+="\r\n",this.socket.end(i,"ascii"),this.emit("requestRejected",this)},b.prototype._handleSocketCloseBeforeAccept=function(){this._socketIsClosing=!0,this._removeSocketCloseListeners()},b.prototype._removeSocketCloseListeners=function(){this.socket.removeListener("end",this._socketCloseHandler),this.socket.removeListener("close",this._socketCloseHandler)},b.prototype._verifyResolution=function(){if(this._resolved)throw new Error("WebSocketRequest may only be accepted or rejected one time.")},e.exports=b},1780:(e,t,s)=>{var i=s(8550).extend,n=s(3837),r=s(2361).EventEmitter,o=s(8873);function a(e){r.call(this),this.config={server:null},e&&i(this.config,e),this.handlers=[],this._requestHandler=this.handleRequest.bind(this),this.config.server&&this.attachServer(this.config.server)}n.inherits(a,r),a.prototype.attachServer=function(e){if(!e)throw new Error("You must specify a WebSocketServer instance to attach to.");this.server=e,this.server.on("request",this._requestHandler)},a.prototype.detachServer=function(){if(!this.server)throw new Error("Cannot detach from server: not attached.");this.server.removeListener("request",this._requestHandler),this.server=null},a.prototype.mount=function(e,t,s){if(!e)throw new Error("You must specify a path for this handler.");if(t||(t="____no_protocol____"),!s)throw new Error("You must specify a callback for this handler.");if(!((e=this.pathToRegExp(e))instanceof RegExp))throw new Error("Path must be specified as either a string or a RegExp.");var i=e.toString();if(t=t.toLocaleLowerCase(),-1!==this.findHandlerIndex(i,t))throw new Error("You may only mount one handler per path/protocol combination.");this.handlers.push({path:e,pathString:i,protocol:t,callback:s})},a.prototype.unmount=function(e,t){var s=this.findHandlerIndex(this.pathToRegExp(e).toString(),t);if(-1===s)throw new Error("Unable to find a route matching the specified path and protocol.");this.handlers.splice(s,1)},a.prototype.findHandlerIndex=function(e,t){t=t.toLocaleLowerCase();for(var s=0,i=this.handlers.length;s<i;s++){var n=this.handlers[s];if(n.pathString===e&&n.protocol===t)return s}return-1},a.prototype.pathToRegExp=function(e){return"string"==typeof e&&("*"===e?e=/^.*$/:(e=e.replace(/[-[\]{}()*+?.,\\^$|#\s]/g,"\\$&"),e=new RegExp("^"+e+"$"))),e},a.prototype.handleRequest=function(e){var t=e.requestedProtocols;0===t.length&&(t=["____no_protocol____"]);for(var s=0;s<t.length;s++)for(var i=t[s].toLocaleLowerCase(),n=0,r=this.handlers.length;n<r;n++){var a=this.handlers[n];if(a.path.test(e.resourceURL.pathname)&&(i===a.protocol||"*"===a.protocol)){var c=new o(e,i);return void a.callback(c)}}e.reject(404,"No handler is available for the given request.")},e.exports=a},8873:(e,t,s)=>{var i=s(3837),n=s(2361).EventEmitter;function r(e,t){n.call(this),this.webSocketRequest=e,this.protocol="____no_protocol____"===t?null:t,this.origin=e.origin,this.resource=e.resource,this.resourceURL=e.resourceURL,this.httpRequest=e.httpRequest,this.remoteAddress=e.remoteAddress,this.webSocketVersion=e.webSocketVersion,this.requestedExtensions=e.requestedExtensions,this.cookies=e.cookies}i.inherits(r,n),r.prototype.accept=function(e,t){var s=this.webSocketRequest.accept(this.protocol,e,t);return this.emit("requestAccepted",s),s},r.prototype.reject=function(e,t,s){this.webSocketRequest.reject(e,t,s),this.emit("requestRejected",this)},e.exports=r},6776:(e,t,s)=>{var i=s(8550).extend,n=s(8550),r=s(3837),o=s(3147)("websocket:server"),a=s(2361).EventEmitter,c=s(948),h=function(e){a.call(this),this._handlers={upgrade:this.handleUpgrade.bind(this),requestAccepted:this.handleRequestAccepted.bind(this),requestResolved:this.handleRequestResolved.bind(this)},this.connections=[],this.pendingRequests=[],e&&this.mount(e)};r.inherits(h,a),h.prototype.mount=function(e){if(this.config={httpServer:null,maxReceivedFrameSize:65536,maxReceivedMessageSize:1048576,fragmentOutgoingMessages:!0,fragmentationThreshold:16384,keepalive:!0,keepaliveInterval:2e4,dropConnectionOnKeepaliveTimeout:!0,keepaliveGracePeriod:1e4,useNativeKeepalive:!1,assembleFragments:!0,autoAcceptConnections:!1,ignoreXForwardedFor:!1,parseCookies:!0,parseExtensions:!0,disableNagleAlgorithm:!0,closeTimeout:5e3},i(this.config,e),!this.config.httpServer)throw new Error("You must specify an httpServer on which to mount the WebSocket server.");Array.isArray(this.config.httpServer)||(this.config.httpServer=[this.config.httpServer]);var t=this._handlers.upgrade;this.config.httpServer.forEach((function(e){e.on("upgrade",t)}))},h.prototype.unmount=function(){var e=this._handlers.upgrade;this.config.httpServer.forEach((function(t){t.removeListener("upgrade",e)}))},h.prototype.closeAllConnections=function(){this.connections.forEach((function(e){e.close()})),this.pendingRequests.forEach((function(e){process.nextTick((function(){e.reject(503)}))}))},h.prototype.broadcast=function(e){Buffer.isBuffer(e)?this.broadcastBytes(e):"function"==typeof e.toString&&this.broadcastUTF(e)},h.prototype.broadcastUTF=function(e){this.connections.forEach((function(t){t.sendUTF(e)}))},h.prototype.broadcastBytes=function(e){this.connections.forEach((function(t){t.sendBytes(e)}))},h.prototype.shutDown=function(){this.unmount(),this.closeAllConnections()},h.prototype.handleUpgrade=function(e,t){var s=this,i=new c(t,e,this.config);try{i.readHandshake()}catch(e){return i.reject(e.httpCode?e.httpCode:400,e.message,e.headers),o("Invalid handshake: %s",e.message),void this.emit("upgradeError",e)}this.pendingRequests.push(i),i.once("requestAccepted",this._handlers.requestAccepted),i.once("requestResolved",this._handlers.requestResolved),t.once("close",(function(){s._handlers.requestResolved(i)})),!this.config.autoAcceptConnections&&n.eventEmitterListenerCount(this,"request")>0?this.emit("request",i):this.config.autoAcceptConnections?i.accept(i.requestedProtocols[0],i.origin):i.reject(404,"No handler is configured to accept the connection.")},h.prototype.handleRequestAccepted=function(e){var t=this;e.once("close",(function(s,i){t.handleConnectionClose(e,s,i)})),this.connections.push(e),this.emit("connect",e)},h.prototype.handleConnectionClose=function(e,t,s){var i=this.connections.indexOf(e);-1!==i&&this.connections.splice(i,1),this.emit("close",e,t,s)},h.prototype.handleRequestResolved=function(e){var t=this.pendingRequests.indexOf(e);-1!==t&&this.pendingRequests.splice(t,1)},e.exports=h},8550:(e,t,s)=>{var i=t.noop=function(){};function n(e,t,s){this.logFunction=s,this.identifier=e,this.uniqueID=t,this.buffer=[]}t.extend=function(e,t){for(var s in t)e[s]=t[s]},t.eventEmitterListenerCount=s(2361).EventEmitter.listenerCount||function(e,t){return e.listeners(t).length},t.bufferAllocUnsafe=Buffer.allocUnsafe?Buffer.allocUnsafe:function(e){return new Buffer(e)},t.bufferFromString=Buffer.from?Buffer.from:function(e,t){return new Buffer(e,t)},t.BufferingLogger=function(e,t){var r=s(3147)(e);if(r.enabled){var o=new n(e,t,r),a=o.log.bind(o);return a.printOutput=o.printOutput.bind(o),a.enabled=r.enabled,a}return r.printOutput=i,r},n.prototype.log=function(){return this.buffer.push([new Date,Array.prototype.slice.call(arguments)]),this},n.prototype.clear=function(){return this.buffer=[],this},n.prototype.printOutput=function(e){e||(e=this.logFunction);var t=this.uniqueID;this.buffer.forEach((function(s){var i=s[0].toLocaleString(),n=s[1].slice(),r=n[0];null!=r&&(r="%s - %s - "+r.toString(),n.splice(0,1,r,i,t),e.apply(global,n))}))}},2630:(e,t,s)=>{e.exports=s(5232).version},7865:(e,t,s)=>{e.exports={server:s(6776),client:s(2283),router:s(1780),frame:s(9891),request:s(948),connection:s(7561),w3cwebsocket:s(8152),deprecation:s(205),version:s(2630)}},5435:(e,t,s)=>{function i(){var e;try{e=t.storage.debug}catch(e){}return!e&&"undefined"!=typeof process&&"env"in process&&(e=process.env.DEBUG),e}(t=e.exports=s(899)).log=function(){return"object"==typeof console&&console.log&&Function.prototype.apply.call(console.log,console,arguments)},t.formatArgs=function(e){var s=this.useColors;if(e[0]=(s?"%c":"")+this.namespace+(s?" %c":" ")+e[0]+(s?"%c ":" ")+"+"+t.humanize(this.diff),s){var i="color: "+this.color;e.splice(1,0,i,"color: inherit");var n=0,r=0;e[0].replace(/%[a-zA-Z%]/g,(function(e){"%%"!==e&&(n++,"%c"===e&&(r=n))})),e.splice(r,0,i)}},t.save=function(e){try{null==e?t.storage.removeItem("debug"):t.storage.debug=e}catch(e){}},t.load=i,t.useColors=function(){return!("undefined"==typeof window||!window.process||"renderer"!==window.process.type)||("undefined"!=typeof document&&document.documentElement&&document.documentElement.style&&document.documentElement.style.WebkitAppearance||"undefined"!=typeof window&&window.console&&(window.console.firebug||window.console.exception&&window.console.table)||"undefined"!=typeof navigator&&navigator.userAgent&&navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/)&&parseInt(RegExp.$1,10)>=31||"undefined"!=typeof navigator&&navigator.userAgent&&navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/))},t.storage="undefined"!=typeof chrome&&void 0!==chrome.storage?chrome.storage.local:function(){try{return window.localStorage}catch(e){}}(),t.colors=["lightseagreen","forestgreen","goldenrod","dodgerblue","darkorchid","crimson"],t.formatters.j=function(e){try{return JSON.stringify(e)}catch(e){return"[UnexpectedJSONParseError]: "+e.message}},t.enable(i())},899:(e,t,s)=>{var i;function n(e){function s(){if(s.enabled){var e=s,n=+new Date,r=n-(i||n);e.diff=r,e.prev=i,e.curr=n,i=n;for(var o=new Array(arguments.length),a=0;a<o.length;a++)o[a]=arguments[a];o[0]=t.coerce(o[0]),"string"!=typeof o[0]&&o.unshift("%O");var c=0;o[0]=o[0].replace(/%([a-zA-Z%])/g,(function(s,i){if("%%"===s)return s;c++;var n=t.formatters[i];if("function"==typeof n){var r=o[c];s=n.call(e,r),o.splice(c,1),c--}return s})),t.formatArgs.call(e,o);var h=s.log||t.log||console.log.bind(console);h.apply(e,o)}}return s.namespace=e,s.enabled=t.enabled(e),s.useColors=t.useColors(),s.color=function(e){var s,i=0;for(s in e)i=(i<<5)-i+e.charCodeAt(s),i|=0;return t.colors[Math.abs(i)%t.colors.length]}(e),"function"==typeof t.init&&t.init(s),s}(t=e.exports=n.debug=n.default=n).coerce=function(e){return e instanceof Error?e.stack||e.message:e},t.disable=function(){t.enable("")},t.enable=function(e){t.save(e),t.names=[],t.skips=[];for(var s=("string"==typeof e?e:"").split(/[\s,]+/),i=s.length,n=0;n<i;n++)s[n]&&("-"===(e=s[n].replace(/\*/g,".*?"))[0]?t.skips.push(new RegExp("^"+e.substr(1)+"$")):t.names.push(new RegExp("^"+e+"$")))},t.enabled=function(e){var s,i;for(s=0,i=t.skips.length;s<i;s++)if(t.skips[s].test(e))return!1;for(s=0,i=t.names.length;s<i;s++)if(t.names[s].test(e))return!0;return!1},t.humanize=s(4701),t.names=[],t.skips=[],t.formatters={}},3147:(e,t,s)=>{"undefined"!=typeof process&&"renderer"===process.type?e.exports=s(5435):e.exports=s(401)},401:(e,t,s)=>{var i=s(6224),n=s(3837);(t=e.exports=s(899)).init=function(e){e.inspectOpts={};for(var s=Object.keys(t.inspectOpts),i=0;i<s.length;i++)e.inspectOpts[s[i]]=t.inspectOpts[s[i]]},t.log=function(){return o.write(n.format.apply(n,arguments)+"\n")},t.formatArgs=function(e){var s=this.namespace;if(this.useColors){var i=this.color,n="  [3"+i+";1m"+s+" [0m";e[0]=n+e[0].split("\n").join("\n"+n),e.push("[3"+i+"m+"+t.humanize(this.diff)+"[0m")}else e[0]=(new Date).toUTCString()+" "+s+" "+e[0]},t.save=function(e){null==e?delete process.env.DEBUG:process.env.DEBUG=e},t.load=a,t.useColors=function(){return"colors"in t.inspectOpts?Boolean(t.inspectOpts.colors):i.isatty(r)},t.colors=[6,2,3,4,5,1],t.inspectOpts=Object.keys(process.env).filter((function(e){return/^debug_/i.test(e)})).reduce((function(e,t){var s=t.substring(6).toLowerCase().replace(/_([a-z])/g,(function(e,t){return t.toUpperCase()})),i=process.env[t];return i=!!/^(yes|on|true|enabled)$/i.test(i)||!/^(no|off|false|disabled)$/i.test(i)&&("null"===i?null:Number(i)),e[s]=i,e}),{});var r=parseInt(process.env.DEBUG_FD,10)||2;1!==r&&2!==r&&n.deprecate((function(){}),"except for stderr(2) and stdout(1), any other usage of DEBUG_FD is deprecated. Override debug.log if you want to use a different log function (https://git.io/debug_fd)")();var o=1===r?process.stdout:2===r?process.stderr:function(e){var t;switch(process.binding("tty_wrap").guessHandleType(e)){case"TTY":(t=new i.WriteStream(e))._type="tty",t._handle&&t._handle.unref&&t._handle.unref();break;case"FILE":(t=new(s(7147).SyncWriteStream)(e,{autoClose:!1}))._type="fs";break;case"PIPE":case"TCP":(t=new(s(1808).Socket)({fd:e,readable:!1,writable:!0})).readable=!1,t.read=null,t._type="pipe",t._handle&&t._handle.unref&&t._handle.unref();break;default:throw new Error("Implement me. Unknown stream file type!")}return t.fd=e,t._isStdio=!0,t}(r);function a(){return process.env.DEBUG}t.formatters.o=function(e){return this.inspectOpts.colors=this.useColors,n.inspect(e,this.inspectOpts).split("\n").map((function(e){return e.trim()})).join(" ")},t.formatters.O=function(e){return this.inspectOpts.colors=this.useColors,n.inspect(e,this.inspectOpts)},t.enable(a())},4701:e=>{var t=1e3,s=60*t,i=60*s,n=24*i;function r(e,t,s){if(!(e<t))return e<1.5*t?Math.floor(e/t)+" "+s:Math.ceil(e/t)+" "+s+"s"}e.exports=function(e,o){o=o||{};var a,c=typeof e;if("string"===c&&e.length>0)return function(e){if(!((e=String(e)).length>100)){var r=/^((?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|years?|yrs?|y)?$/i.exec(e);if(r){var o=parseFloat(r[1]);switch((r[2]||"ms").toLowerCase()){case"years":case"year":case"yrs":case"yr":case"y":return 315576e5*o;case"days":case"day":case"d":return o*n;case"hours":case"hour":case"hrs":case"hr":case"h":return o*i;case"minutes":case"minute":case"mins":case"min":case"m":return o*s;case"seconds":case"second":case"secs":case"sec":case"s":return o*t;case"milliseconds":case"millisecond":case"msecs":case"msec":case"ms":return o;default:return}}}}(e);if("number"===c&&!1===isNaN(e))return o.long?r(a=e,n,"day")||r(a,i,"hour")||r(a,s,"minute")||r(a,t,"second")||a+" ms":function(e){return e>=n?Math.round(e/n)+"d":e>=i?Math.round(e/i)+"h":e>=s?Math.round(e/s)+"m":e>=t?Math.round(e/t)+"s":e+"ms"}(e);throw new Error("val is not a non-empty string or a valid number. val="+JSON.stringify(e))}},8671:(e,t,s)=>{var i=s(4300).Buffer,n=s(2361).EventEmitter,r=s(8550).bufferAllocUnsafe;function o(e){if(!(this instanceof o))return new o(e);n.call(this);var t=this;void 0===e&&(e={}),t.encoding=e.encoding;var s={next:null,buffer:null},a={next:null,buffer:null},c=0;t.__defineGetter__("length",(function(){return c}));var h=0;t.write=function(e){return s.buffer?(a.next={next:null,buffer:e},a=a.next):(s.buffer=e,a=s),c+=e.length,t.emit("write",e),!0},t.end=function(e){i.isBuffer(e)&&t.write(e)},t.push=function(){var e=[].concat.apply([],arguments);return e.forEach(t.write),t},t.forEach=function(e){if(!s.buffer)return r(0);if(s.buffer.length-h<=0)return t;for(var i={buffer:s.buffer.slice(h),next:s.next};i&&i.buffer&&!e(i.buffer);)i=i.next;return t},t.join=function(e,i){if(!s.buffer)return r(0);null==e&&(e=0),null==i&&(i=t.length);var n=r(i-e),o=0;return t.forEach((function(t){if(e<o+t.length&&o<i&&t.copy(n,Math.max(0,o-e),Math.max(0,e-o),Math.min(t.length,i-o)),(o+=t.length)>i)return!0})),n},t.joinInto=function(e,i,n,o){if(!s.buffer)return new r(0);null==n&&(n=0),null==o&&(o=t.length);var a=e;if(a.length-i<o-n)throw new Error("Insufficient space available in target Buffer.");var c=0;return t.forEach((function(e){if(n<c+e.length&&c<o&&e.copy(a,Math.max(i,i+c-n),Math.max(0,n-c),Math.min(e.length,o-c)),(c+=e.length)>o)return!0})),a},t.advance=function(e){for(h+=e,c-=e;s.buffer&&h>=s.buffer.length;)h-=s.buffer.length,s=s.next?s.next:{buffer:null,next:null};return null===s.buffer&&(a={next:null,buffer:null}),t.emit("advance",e),t},t.take=function(e,s){if(null==e?e=t.length:"number"!=typeof e&&(s=e,e=t.length),s||(s=t.encoding),s){var i="";return t.forEach((function(t){if(e<=0)return!0;i+=t.toString(s,0,Math.min(e,t.length)),e-=t.length})),i}return t.join(0,e)},t.toString=function(){return t.take("binary")}}e.exports=o,e.exports.BufferList=o,s(3837).inherits(o,n)},41:(e,t,s)=>{e.exports={EventTarget:s(2666),Event:s(4652)}},4652:e=>{e.exports=function(e){this.type=e,this.isTrusted=!1,this._yaeti=!0}},2666:e=>{function t(){"function"!=typeof this.addEventListener&&(this._listeners={},this.addEventListener=s,this.removeEventListener=i,this.dispatchEvent=n)}function s(e,t){var s,i,n;if(e&&t){for(void 0===(s=this._listeners[e])&&(this._listeners[e]=s=[]),i=0;n=s[i];i++)if(n===t)return;s.push(t)}}function i(e,t){var s,i,n;if(e&&t&&void 0!==(s=this._listeners[e])){for(i=0;n=s[i];i++)if(n===t){s.splice(i,1);break}0===s.length&&delete this._listeners[e]}}function n(e){var t,s,i,n,r,o=!1;if(!e||"string"!=typeof e.type)throw new Error("`event` must have a valid `type` property");e._yaeti&&(e.target=this,e.cancelable=!0);try{e.stopImmediatePropagation=function(){o=!0}}catch(e){}for(t=e.type,s=this._listeners[t]||[],"function"==typeof(i=this["on"+t])&&i.call(this,e),n=0;(r=s[n])&&!o;n++)r.call(this,e);return!e.defaultPrevented}e.exports=t,Object.defineProperties(t.prototype,{listeners:{get:function(){return this._listeners}}})},3121:e=>{"use strict";e.exports=JSON.parse('{"name":"@vs/vs-ssh","version":"3.7.4","description":"SSH library for Visual Studio tools","keywords":["SSH"],"dependencies":{"buffer":"^5.2.1","debug":"^4.1.1","diffie-hellman":"^5.0.3","vscode-jsonrpc":"^4.0.0"},"author":"Microsoft","main":"./index.js"}')},5232:e=>{"use strict";e.exports={version:"1.0.34"}}};